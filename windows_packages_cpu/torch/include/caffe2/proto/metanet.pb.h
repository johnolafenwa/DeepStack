// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe2/proto/metanet.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_caffe2_2fproto_2fmetanet_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_caffe2_2fproto_2fmetanet_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "caffe2/proto/caffe2.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fmetanet_2eproto CAFFE2_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct CAFFE2_API TableStruct_caffe2_2fproto_2fmetanet_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern CAFFE2_API const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_caffe2_2fproto_2fmetanet_2eproto;
namespace caffe2 { const ::std::string& GetEmptyStringAlreadyInited(); 
class BlobsMap;
class BlobsMapDefaultTypeInternal;
CAFFE2_API extern BlobsMapDefaultTypeInternal _BlobsMap_default_instance_;
class MetaNetDef;
class MetaNetDefDefaultTypeInternal;
CAFFE2_API extern MetaNetDefDefaultTypeInternal _MetaNetDef_default_instance_;
class ModelInfo;
class ModelInfoDefaultTypeInternal;
CAFFE2_API extern ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
class NetsMap;
class NetsMapDefaultTypeInternal;
CAFFE2_API extern NetsMapDefaultTypeInternal _NetsMap_default_instance_;
class PlansMap;
class PlansMapDefaultTypeInternal;
CAFFE2_API extern PlansMapDefaultTypeInternal _PlansMap_default_instance_;
class StringMap;
class StringMapDefaultTypeInternal;
CAFFE2_API extern StringMapDefaultTypeInternal _StringMap_default_instance_;
}  // namespace caffe2
PROTOBUF_NAMESPACE_OPEN
template<> CAFFE2_API ::caffe2::BlobsMap* Arena::CreateMaybeMessage<::caffe2::BlobsMap>(Arena*);
template<> CAFFE2_API ::caffe2::MetaNetDef* Arena::CreateMaybeMessage<::caffe2::MetaNetDef>(Arena*);
template<> CAFFE2_API ::caffe2::ModelInfo* Arena::CreateMaybeMessage<::caffe2::ModelInfo>(Arena*);
template<> CAFFE2_API ::caffe2::NetsMap* Arena::CreateMaybeMessage<::caffe2::NetsMap>(Arena*);
template<> CAFFE2_API ::caffe2::PlansMap* Arena::CreateMaybeMessage<::caffe2::PlansMap>(Arena*);
template<> CAFFE2_API ::caffe2::StringMap* Arena::CreateMaybeMessage<::caffe2::StringMap>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace caffe2 {

// ===================================================================

class CAFFE2_API ModelInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.ModelInfo) */ {
 public:
  ModelInfo();
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);
  ModelInfo(ModelInfo&& from) noexcept
    : ModelInfo() {
    *this = ::std::move(from);
  }

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInfo& operator=(ModelInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo* internal_default_instance() {
    return reinterpret_cast<const ModelInfo*>(
               &_ModelInfo_default_instance_);
  }
  static int const kIndexInFileMessages =
    0;

  friend void swap(ModelInfo& a, ModelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo* New() const final {
    return CreateMaybeMessage<ModelInfo>(nullptr);
  }

  ModelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.ModelInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fmetanet_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fmetanet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProjectFieldNumber = 1,
    kModelClassFieldNumber = 2,
    kVersionFieldNumber = 3,
    kPredictorTypeFieldNumber = 4,
    kModelIdFieldNumber = 5,
  };
  // optional string project = 1;
  bool has_project() const;
  private:
  bool _internal_has_project() const;
  public:
  void clear_project();
  const std::string& project() const;
  void set_project(const std::string& value);
  void set_project(std::string&& value);
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  std::string* mutable_project();
  std::string* release_project();
  void set_allocated_project(std::string* project);
  private:
  const std::string& _internal_project() const;
  void _internal_set_project(const std::string& value);
  std::string* _internal_mutable_project();
  public:

  // optional string modelClass = 2;
  bool has_modelclass() const;
  private:
  bool _internal_has_modelclass() const;
  public:
  void clear_modelclass();
  const std::string& modelclass() const;
  void set_modelclass(const std::string& value);
  void set_modelclass(std::string&& value);
  void set_modelclass(const char* value);
  void set_modelclass(const char* value, size_t size);
  std::string* mutable_modelclass();
  std::string* release_modelclass();
  void set_allocated_modelclass(std::string* modelclass);
  private:
  const std::string& _internal_modelclass() const;
  void _internal_set_modelclass(const std::string& value);
  std::string* _internal_mutable_modelclass();
  public:

  // optional string version = 3;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string predictorType = 4 [default = "SINGLE_PREDICTOR"];
  bool has_predictortype() const;
  private:
  bool _internal_has_predictortype() const;
  public:
  void clear_predictortype();
  const std::string& predictortype() const;
  void set_predictortype(const std::string& value);
  void set_predictortype(std::string&& value);
  void set_predictortype(const char* value);
  void set_predictortype(const char* value, size_t size);
  std::string* mutable_predictortype();
  std::string* release_predictortype();
  void set_allocated_predictortype(std::string* predictortype);
  private:
  const std::string& _internal_predictortype() const;
  void _internal_set_predictortype(const std::string& value);
  std::string* _internal_mutable_predictortype();
  public:

  // optional string modelId = 5;
  bool has_modelid() const;
  private:
  bool _internal_has_modelid() const;
  public:
  void clear_modelid();
  const std::string& modelid() const;
  void set_modelid(const std::string& value);
  void set_modelid(std::string&& value);
  void set_modelid(const char* value);
  void set_modelid(const char* value, size_t size);
  std::string* mutable_modelid();
  std::string* release_modelid();
  void set_allocated_modelid(std::string* modelid);
  private:
  const std::string& _internal_modelid() const;
  void _internal_set_modelid(const std::string& value);
  std::string* _internal_mutable_modelid();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.ModelInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr project_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelclass_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  public:
  static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> _i_give_permission_to_break_this_code_default_predictortype_;
  private:
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr predictortype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelid_;
  friend struct ::TableStruct_caffe2_2fproto_2fmetanet_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API BlobsMap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.BlobsMap) */ {
 public:
  BlobsMap();
  virtual ~BlobsMap();

  BlobsMap(const BlobsMap& from);
  BlobsMap(BlobsMap&& from) noexcept
    : BlobsMap() {
    *this = ::std::move(from);
  }

  inline BlobsMap& operator=(const BlobsMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobsMap& operator=(BlobsMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlobsMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlobsMap* internal_default_instance() {
    return reinterpret_cast<const BlobsMap*>(
               &_BlobsMap_default_instance_);
  }
  static int const kIndexInFileMessages =
    1;

  friend void swap(BlobsMap& a, BlobsMap& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobsMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlobsMap* New() const final {
    return CreateMaybeMessage<BlobsMap>(nullptr);
  }

  BlobsMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlobsMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlobsMap& from);
  void MergeFrom(const BlobsMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobsMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.BlobsMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fmetanet_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fmetanet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kKeyFieldNumber = 1,
  };
  // repeated string value = 2;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  const std::string& value(int index) const;
  std::string* mutable_value(int index);
  void set_value(int index, const std::string& value);
  void set_value(int index, std::string&& value);
  void set_value(int index, const char* value);
  void set_value(int index, const char* value, size_t size);
  std::string* add_value();
  void add_value(const std::string& value);
  void add_value(std::string&& value);
  void add_value(const char* value);
  void add_value(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& value() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_value();
  private:
  const std::string& _internal_value(int index) const;
  std::string* _internal_add_value();
  public:

  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.BlobsMap)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_caffe2_2fproto_2fmetanet_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API NetsMap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.NetsMap) */ {
 public:
  NetsMap();
  virtual ~NetsMap();

  NetsMap(const NetsMap& from);
  NetsMap(NetsMap&& from) noexcept
    : NetsMap() {
    *this = ::std::move(from);
  }

  inline NetsMap& operator=(const NetsMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetsMap& operator=(NetsMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NetsMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetsMap* internal_default_instance() {
    return reinterpret_cast<const NetsMap*>(
               &_NetsMap_default_instance_);
  }
  static int const kIndexInFileMessages =
    2;

  friend void swap(NetsMap& a, NetsMap& b) {
    a.Swap(&b);
  }
  inline void Swap(NetsMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NetsMap* New() const final {
    return CreateMaybeMessage<NetsMap>(nullptr);
  }

  NetsMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NetsMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NetsMap& from);
  void MergeFrom(const NetsMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetsMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.NetsMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fmetanet_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fmetanet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required .caffe2.NetDef value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::caffe2::NetDef& value() const;
  ::caffe2::NetDef* release_value();
  ::caffe2::NetDef* mutable_value();
  void set_allocated_value(::caffe2::NetDef* value);
  private:
  const ::caffe2::NetDef& _internal_value() const;
  ::caffe2::NetDef* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.NetsMap)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::caffe2::NetDef* value_;
  friend struct ::TableStruct_caffe2_2fproto_2fmetanet_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API PlansMap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.PlansMap) */ {
 public:
  PlansMap();
  virtual ~PlansMap();

  PlansMap(const PlansMap& from);
  PlansMap(PlansMap&& from) noexcept
    : PlansMap() {
    *this = ::std::move(from);
  }

  inline PlansMap& operator=(const PlansMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlansMap& operator=(PlansMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlansMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlansMap* internal_default_instance() {
    return reinterpret_cast<const PlansMap*>(
               &_PlansMap_default_instance_);
  }
  static int const kIndexInFileMessages =
    3;

  friend void swap(PlansMap& a, PlansMap& b) {
    a.Swap(&b);
  }
  inline void Swap(PlansMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlansMap* New() const final {
    return CreateMaybeMessage<PlansMap>(nullptr);
  }

  PlansMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlansMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlansMap& from);
  void MergeFrom(const PlansMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlansMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.PlansMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fmetanet_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fmetanet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required .caffe2.PlanDef value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::caffe2::PlanDef& value() const;
  ::caffe2::PlanDef* release_value();
  ::caffe2::PlanDef* mutable_value();
  void set_allocated_value(::caffe2::PlanDef* value);
  private:
  const ::caffe2::PlanDef& _internal_value() const;
  ::caffe2::PlanDef* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.PlansMap)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::caffe2::PlanDef* value_;
  friend struct ::TableStruct_caffe2_2fproto_2fmetanet_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API StringMap :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.StringMap) */ {
 public:
  StringMap();
  virtual ~StringMap();

  StringMap(const StringMap& from);
  StringMap(StringMap&& from) noexcept
    : StringMap() {
    *this = ::std::move(from);
  }

  inline StringMap& operator=(const StringMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline StringMap& operator=(StringMap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StringMap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringMap* internal_default_instance() {
    return reinterpret_cast<const StringMap*>(
               &_StringMap_default_instance_);
  }
  static int const kIndexInFileMessages =
    4;

  friend void swap(StringMap& a, StringMap& b) {
    a.Swap(&b);
  }
  inline void Swap(StringMap* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StringMap* New() const final {
    return CreateMaybeMessage<StringMap>(nullptr);
  }

  StringMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StringMap>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StringMap& from);
  void MergeFrom(const StringMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringMap* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.StringMap";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fmetanet_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fmetanet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.StringMap)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_caffe2_2fproto_2fmetanet_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API MetaNetDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.MetaNetDef) */ {
 public:
  MetaNetDef();
  virtual ~MetaNetDef();

  MetaNetDef(const MetaNetDef& from);
  MetaNetDef(MetaNetDef&& from) noexcept
    : MetaNetDef() {
    *this = ::std::move(from);
  }

  inline MetaNetDef& operator=(const MetaNetDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaNetDef& operator=(MetaNetDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MetaNetDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MetaNetDef* internal_default_instance() {
    return reinterpret_cast<const MetaNetDef*>(
               &_MetaNetDef_default_instance_);
  }
  static int const kIndexInFileMessages =
    5;

  friend void swap(MetaNetDef& a, MetaNetDef& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaNetDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MetaNetDef* New() const final {
    return CreateMaybeMessage<MetaNetDef>(nullptr);
  }

  MetaNetDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MetaNetDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MetaNetDef& from);
  void MergeFrom(const MetaNetDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaNetDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.MetaNetDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fmetanet_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fmetanet_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobsFieldNumber = 1,
    kNetsFieldNumber = 2,
    kPlansFieldNumber = 4,
    kApplicationSpecificInfoFieldNumber = 5,
    kBlobsOrderFieldNumber = 6,
    kPreLoadBlobsFieldNumber = 7,
    kModelInfoFieldNumber = 3,
    kTensorBoundShapesFieldNumber = 8,
  };
  // repeated .caffe2.BlobsMap blobs = 1;
  int blobs_size() const;
  private:
  int _internal_blobs_size() const;
  public:
  void clear_blobs();
  ::caffe2::BlobsMap* mutable_blobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::BlobsMap >*
      mutable_blobs();
  private:
  const ::caffe2::BlobsMap& _internal_blobs(int index) const;
  ::caffe2::BlobsMap* _internal_add_blobs();
  public:
  const ::caffe2::BlobsMap& blobs(int index) const;
  ::caffe2::BlobsMap* add_blobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::BlobsMap >&
      blobs() const;

  // repeated .caffe2.NetsMap nets = 2;
  int nets_size() const;
  private:
  int _internal_nets_size() const;
  public:
  void clear_nets();
  ::caffe2::NetsMap* mutable_nets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetsMap >*
      mutable_nets();
  private:
  const ::caffe2::NetsMap& _internal_nets(int index) const;
  ::caffe2::NetsMap* _internal_add_nets();
  public:
  const ::caffe2::NetsMap& nets(int index) const;
  ::caffe2::NetsMap* add_nets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetsMap >&
      nets() const;

  // repeated .caffe2.PlansMap plans = 4;
  int plans_size() const;
  private:
  int _internal_plans_size() const;
  public:
  void clear_plans();
  ::caffe2::PlansMap* mutable_plans(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::PlansMap >*
      mutable_plans();
  private:
  const ::caffe2::PlansMap& _internal_plans(int index) const;
  ::caffe2::PlansMap* _internal_add_plans();
  public:
  const ::caffe2::PlansMap& plans(int index) const;
  ::caffe2::PlansMap* add_plans();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::PlansMap >&
      plans() const;

  // repeated .caffe2.StringMap applicationSpecificInfo = 5;
  int applicationspecificinfo_size() const;
  private:
  int _internal_applicationspecificinfo_size() const;
  public:
  void clear_applicationspecificinfo();
  ::caffe2::StringMap* mutable_applicationspecificinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::StringMap >*
      mutable_applicationspecificinfo();
  private:
  const ::caffe2::StringMap& _internal_applicationspecificinfo(int index) const;
  ::caffe2::StringMap* _internal_add_applicationspecificinfo();
  public:
  const ::caffe2::StringMap& applicationspecificinfo(int index) const;
  ::caffe2::StringMap* add_applicationspecificinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::StringMap >&
      applicationspecificinfo() const;

  // repeated string blobsOrder = 6;
  int blobsorder_size() const;
  private:
  int _internal_blobsorder_size() const;
  public:
  void clear_blobsorder();
  const std::string& blobsorder(int index) const;
  std::string* mutable_blobsorder(int index);
  void set_blobsorder(int index, const std::string& value);
  void set_blobsorder(int index, std::string&& value);
  void set_blobsorder(int index, const char* value);
  void set_blobsorder(int index, const char* value, size_t size);
  std::string* add_blobsorder();
  void add_blobsorder(const std::string& value);
  void add_blobsorder(std::string&& value);
  void add_blobsorder(const char* value);
  void add_blobsorder(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& blobsorder() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_blobsorder();
  private:
  const std::string& _internal_blobsorder(int index) const;
  std::string* _internal_add_blobsorder();
  public:

  // repeated string preLoadBlobs = 7;
  int preloadblobs_size() const;
  private:
  int _internal_preloadblobs_size() const;
  public:
  void clear_preloadblobs();
  const std::string& preloadblobs(int index) const;
  std::string* mutable_preloadblobs(int index);
  void set_preloadblobs(int index, const std::string& value);
  void set_preloadblobs(int index, std::string&& value);
  void set_preloadblobs(int index, const char* value);
  void set_preloadblobs(int index, const char* value, size_t size);
  std::string* add_preloadblobs();
  void add_preloadblobs(const std::string& value);
  void add_preloadblobs(std::string&& value);
  void add_preloadblobs(const char* value);
  void add_preloadblobs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& preloadblobs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_preloadblobs();
  private:
  const std::string& _internal_preloadblobs(int index) const;
  std::string* _internal_add_preloadblobs();
  public:

  // optional .caffe2.ModelInfo modelInfo = 3;
  bool has_modelinfo() const;
  private:
  bool _internal_has_modelinfo() const;
  public:
  void clear_modelinfo();
  const ::caffe2::ModelInfo& modelinfo() const;
  ::caffe2::ModelInfo* release_modelinfo();
  ::caffe2::ModelInfo* mutable_modelinfo();
  void set_allocated_modelinfo(::caffe2::ModelInfo* modelinfo);
  private:
  const ::caffe2::ModelInfo& _internal_modelinfo() const;
  ::caffe2::ModelInfo* _internal_mutable_modelinfo();
  public:

  // optional .caffe2.TensorBoundShapes tensorBoundShapes = 8;
  bool has_tensorboundshapes() const;
  private:
  bool _internal_has_tensorboundshapes() const;
  public:
  void clear_tensorboundshapes();
  const ::caffe2::TensorBoundShapes& tensorboundshapes() const;
  ::caffe2::TensorBoundShapes* release_tensorboundshapes();
  ::caffe2::TensorBoundShapes* mutable_tensorboundshapes();
  void set_allocated_tensorboundshapes(::caffe2::TensorBoundShapes* tensorboundshapes);
  private:
  const ::caffe2::TensorBoundShapes& _internal_tensorboundshapes() const;
  ::caffe2::TensorBoundShapes* _internal_mutable_tensorboundshapes();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.MetaNetDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::BlobsMap > blobs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetsMap > nets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::PlansMap > plans_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::StringMap > applicationspecificinfo_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> blobsorder_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> preloadblobs_;
  ::caffe2::ModelInfo* modelinfo_;
  ::caffe2::TensorBoundShapes* tensorboundshapes_;
  friend struct ::TableStruct_caffe2_2fproto_2fmetanet_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ModelInfo

// optional string project = 1;
inline bool ModelInfo::_internal_has_project() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModelInfo::has_project() const {
  return _internal_has_project();
}
inline void ModelInfo::clear_project() {
  project_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModelInfo::project() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.project)
  return _internal_project();
}
inline void ModelInfo::set_project(const std::string& value) {
  _internal_set_project(value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.project)
}
inline std::string* ModelInfo::mutable_project() {
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.project)
  return _internal_mutable_project();
}
inline const std::string& ModelInfo::_internal_project() const {
  return project_.GetNoArena();
}
inline void ModelInfo::_internal_set_project(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  project_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ModelInfo::set_project(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  project_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ModelInfo.project)
}
inline void ModelInfo::set_project(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  project_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.project)
}
inline void ModelInfo::set_project(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  project_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.project)
}
inline std::string* ModelInfo::_internal_mutable_project() {
  _has_bits_[0] |= 0x00000001u;
  return project_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ModelInfo::release_project() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.project)
  if (!_internal_has_project()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return project_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_project(std::string* project) {
  if (project != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  project_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.project)
}

// optional string modelClass = 2;
inline bool ModelInfo::_internal_has_modelclass() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ModelInfo::has_modelclass() const {
  return _internal_has_modelclass();
}
inline void ModelInfo::clear_modelclass() {
  modelclass_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ModelInfo::modelclass() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.modelClass)
  return _internal_modelclass();
}
inline void ModelInfo::set_modelclass(const std::string& value) {
  _internal_set_modelclass(value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.modelClass)
}
inline std::string* ModelInfo::mutable_modelclass() {
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.modelClass)
  return _internal_mutable_modelclass();
}
inline const std::string& ModelInfo::_internal_modelclass() const {
  return modelclass_.GetNoArena();
}
inline void ModelInfo::_internal_set_modelclass(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  modelclass_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ModelInfo::set_modelclass(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  modelclass_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ModelInfo.modelClass)
}
inline void ModelInfo::set_modelclass(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  modelclass_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.modelClass)
}
inline void ModelInfo::set_modelclass(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  modelclass_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.modelClass)
}
inline std::string* ModelInfo::_internal_mutable_modelclass() {
  _has_bits_[0] |= 0x00000002u;
  return modelclass_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ModelInfo::release_modelclass() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.modelClass)
  if (!_internal_has_modelclass()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return modelclass_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_modelclass(std::string* modelclass) {
  if (modelclass != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  modelclass_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), modelclass);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.modelClass)
}

// optional string version = 3;
inline bool ModelInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ModelInfo::has_version() const {
  return _internal_has_version();
}
inline void ModelInfo::clear_version() {
  version_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ModelInfo::version() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.version)
  return _internal_version();
}
inline void ModelInfo::set_version(const std::string& value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.version)
}
inline std::string* ModelInfo::mutable_version() {
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.version)
  return _internal_mutable_version();
}
inline const std::string& ModelInfo::_internal_version() const {
  return version_.GetNoArena();
}
inline void ModelInfo::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ModelInfo::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ModelInfo.version)
}
inline void ModelInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.version)
}
inline void ModelInfo::set_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  version_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.version)
}
inline std::string* ModelInfo::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000004u;
  return version_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ModelInfo::release_version() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return version_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  version_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.version)
}

// optional string predictorType = 4 [default = "SINGLE_PREDICTOR"];
inline bool ModelInfo::_internal_has_predictortype() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ModelInfo::has_predictortype() const {
  return _internal_has_predictortype();
}
inline void ModelInfo::clear_predictortype() {
  predictortype_.ClearToDefaultNoArena(&::caffe2::ModelInfo::_i_give_permission_to_break_this_code_default_predictortype_.get());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ModelInfo::predictortype() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.predictorType)
  return _internal_predictortype();
}
inline void ModelInfo::set_predictortype(const std::string& value) {
  _internal_set_predictortype(value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.predictorType)
}
inline std::string* ModelInfo::mutable_predictortype() {
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.predictorType)
  return _internal_mutable_predictortype();
}
inline const std::string& ModelInfo::_internal_predictortype() const {
  return predictortype_.GetNoArena();
}
inline void ModelInfo::_internal_set_predictortype(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  predictortype_.SetNoArena(&::caffe2::ModelInfo::_i_give_permission_to_break_this_code_default_predictortype_.get(), value);
}
inline void ModelInfo::set_predictortype(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  predictortype_.SetNoArena(
    &::caffe2::ModelInfo::_i_give_permission_to_break_this_code_default_predictortype_.get(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ModelInfo.predictorType)
}
inline void ModelInfo::set_predictortype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  predictortype_.SetNoArena(&::caffe2::ModelInfo::_i_give_permission_to_break_this_code_default_predictortype_.get(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.predictorType)
}
inline void ModelInfo::set_predictortype(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  predictortype_.SetNoArena(&::caffe2::ModelInfo::_i_give_permission_to_break_this_code_default_predictortype_.get(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.predictorType)
}
inline std::string* ModelInfo::_internal_mutable_predictortype() {
  _has_bits_[0] |= 0x00000008u;
  return predictortype_.MutableNoArena(&::caffe2::ModelInfo::_i_give_permission_to_break_this_code_default_predictortype_.get());
}
inline std::string* ModelInfo::release_predictortype() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.predictorType)
  if (!_internal_has_predictortype()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return predictortype_.ReleaseNonDefaultNoArena(&::caffe2::ModelInfo::_i_give_permission_to_break_this_code_default_predictortype_.get());
}
inline void ModelInfo::set_allocated_predictortype(std::string* predictortype) {
  if (predictortype != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  predictortype_.SetAllocatedNoArena(&::caffe2::ModelInfo::_i_give_permission_to_break_this_code_default_predictortype_.get(), predictortype);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.predictorType)
}

// optional string modelId = 5;
inline bool ModelInfo::_internal_has_modelid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ModelInfo::has_modelid() const {
  return _internal_has_modelid();
}
inline void ModelInfo::clear_modelid() {
  modelid_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& ModelInfo::modelid() const {
  // @@protoc_insertion_point(field_get:caffe2.ModelInfo.modelId)
  return _internal_modelid();
}
inline void ModelInfo::set_modelid(const std::string& value) {
  _internal_set_modelid(value);
  // @@protoc_insertion_point(field_set:caffe2.ModelInfo.modelId)
}
inline std::string* ModelInfo::mutable_modelid() {
  // @@protoc_insertion_point(field_mutable:caffe2.ModelInfo.modelId)
  return _internal_mutable_modelid();
}
inline const std::string& ModelInfo::_internal_modelid() const {
  return modelid_.GetNoArena();
}
inline void ModelInfo::_internal_set_modelid(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  modelid_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ModelInfo::set_modelid(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  modelid_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ModelInfo.modelId)
}
inline void ModelInfo::set_modelid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  modelid_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ModelInfo.modelId)
}
inline void ModelInfo::set_modelid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  modelid_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ModelInfo.modelId)
}
inline std::string* ModelInfo::_internal_mutable_modelid() {
  _has_bits_[0] |= 0x00000010u;
  return modelid_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ModelInfo::release_modelid() {
  // @@protoc_insertion_point(field_release:caffe2.ModelInfo.modelId)
  if (!_internal_has_modelid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return modelid_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModelInfo::set_allocated_modelid(std::string* modelid) {
  if (modelid != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  modelid_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), modelid);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ModelInfo.modelId)
}

// -------------------------------------------------------------------

// BlobsMap

// required string key = 1;
inline bool BlobsMap::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BlobsMap::has_key() const {
  return _internal_has_key();
}
inline void BlobsMap::clear_key() {
  key_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlobsMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobsMap.key)
  return _internal_key();
}
inline void BlobsMap::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:caffe2.BlobsMap.key)
}
inline std::string* BlobsMap::mutable_key() {
  // @@protoc_insertion_point(field_mutable:caffe2.BlobsMap.key)
  return _internal_mutable_key();
}
inline const std::string& BlobsMap::_internal_key() const {
  return key_.GetNoArena();
}
inline void BlobsMap::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void BlobsMap::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.BlobsMap.key)
}
inline void BlobsMap::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.BlobsMap.key)
}
inline void BlobsMap::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobsMap.key)
}
inline std::string* BlobsMap::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* BlobsMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.BlobsMap.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void BlobsMap::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobsMap.key)
}

// repeated string value = 2;
inline int BlobsMap::_internal_value_size() const {
  return value_.size();
}
inline int BlobsMap::value_size() const {
  return _internal_value_size();
}
inline void BlobsMap::clear_value() {
  value_.Clear();
}
inline std::string* BlobsMap::add_value() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.BlobsMap.value)
  return _internal_add_value();
}
inline const std::string& BlobsMap::_internal_value(int index) const {
  return value_.Get(index);
}
inline const std::string& BlobsMap::value(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.BlobsMap.value)
  return _internal_value(index);
}
inline std::string* BlobsMap::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.BlobsMap.value)
  return value_.Mutable(index);
}
inline void BlobsMap::set_value(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.BlobsMap.value)
  value_.Mutable(index)->assign(value);
}
inline void BlobsMap::set_value(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.BlobsMap.value)
  value_.Mutable(index)->assign(std::move(value));
}
inline void BlobsMap::set_value(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.BlobsMap.value)
}
inline void BlobsMap::set_value(int index, const char* value, size_t size) {
  value_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobsMap.value)
}
inline std::string* BlobsMap::_internal_add_value() {
  return value_.Add();
}
inline void BlobsMap::add_value(const std::string& value) {
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.BlobsMap.value)
}
inline void BlobsMap::add_value(std::string&& value) {
  value_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.BlobsMap.value)
}
inline void BlobsMap::add_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  value_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.BlobsMap.value)
}
inline void BlobsMap::add_value(const char* value, size_t size) {
  value_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.BlobsMap.value)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlobsMap::value() const {
  // @@protoc_insertion_point(field_list:caffe2.BlobsMap.value)
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlobsMap::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.BlobsMap.value)
  return &value_;
}

// -------------------------------------------------------------------

// NetsMap

// required string key = 1;
inline bool NetsMap::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NetsMap::has_key() const {
  return _internal_has_key();
}
inline void NetsMap::clear_key() {
  key_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetsMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.NetsMap.key)
  return _internal_key();
}
inline void NetsMap::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:caffe2.NetsMap.key)
}
inline std::string* NetsMap::mutable_key() {
  // @@protoc_insertion_point(field_mutable:caffe2.NetsMap.key)
  return _internal_mutable_key();
}
inline const std::string& NetsMap::_internal_key() const {
  return key_.GetNoArena();
}
inline void NetsMap::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void NetsMap::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.NetsMap.key)
}
inline void NetsMap::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.NetsMap.key)
}
inline void NetsMap::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetsMap.key)
}
inline std::string* NetsMap::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* NetsMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.NetsMap.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void NetsMap::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetsMap.key)
}

// required .caffe2.NetDef value = 2;
inline bool NetsMap::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool NetsMap::has_value() const {
  return _internal_has_value();
}
inline const ::caffe2::NetDef& NetsMap::_internal_value() const {
  const ::caffe2::NetDef* p = value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::NetDef*>(
      &::caffe2::_NetDef_default_instance_);
}
inline const ::caffe2::NetDef& NetsMap::value() const {
  // @@protoc_insertion_point(field_get:caffe2.NetsMap.value)
  return _internal_value();
}
inline ::caffe2::NetDef* NetsMap::release_value() {
  // @@protoc_insertion_point(field_release:caffe2.NetsMap.value)
  _has_bits_[0] &= ~0x00000002u;
  ::caffe2::NetDef* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::caffe2::NetDef* NetsMap::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::NetDef>(GetArenaNoVirtual());
    value_ = p;
  }
  return value_;
}
inline ::caffe2::NetDef* NetsMap::mutable_value() {
  // @@protoc_insertion_point(field_mutable:caffe2.NetsMap.value)
  return _internal_mutable_value();
}
inline void NetsMap::set_allocated_value(::caffe2::NetDef* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetsMap.value)
}

// -------------------------------------------------------------------

// PlansMap

// required string key = 1;
inline bool PlansMap::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlansMap::has_key() const {
  return _internal_has_key();
}
inline void PlansMap::clear_key() {
  key_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlansMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.PlansMap.key)
  return _internal_key();
}
inline void PlansMap::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:caffe2.PlansMap.key)
}
inline std::string* PlansMap::mutable_key() {
  // @@protoc_insertion_point(field_mutable:caffe2.PlansMap.key)
  return _internal_mutable_key();
}
inline const std::string& PlansMap::_internal_key() const {
  return key_.GetNoArena();
}
inline void PlansMap::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void PlansMap::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.PlansMap.key)
}
inline void PlansMap::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.PlansMap.key)
}
inline void PlansMap::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.PlansMap.key)
}
inline std::string* PlansMap::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* PlansMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.PlansMap.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void PlansMap::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.PlansMap.key)
}

// required .caffe2.PlanDef value = 2;
inline bool PlansMap::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || value_ != nullptr);
  return value;
}
inline bool PlansMap::has_value() const {
  return _internal_has_value();
}
inline const ::caffe2::PlanDef& PlansMap::_internal_value() const {
  const ::caffe2::PlanDef* p = value_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::PlanDef*>(
      &::caffe2::_PlanDef_default_instance_);
}
inline const ::caffe2::PlanDef& PlansMap::value() const {
  // @@protoc_insertion_point(field_get:caffe2.PlansMap.value)
  return _internal_value();
}
inline ::caffe2::PlanDef* PlansMap::release_value() {
  // @@protoc_insertion_point(field_release:caffe2.PlansMap.value)
  _has_bits_[0] &= ~0x00000002u;
  ::caffe2::PlanDef* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::caffe2::PlanDef* PlansMap::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::PlanDef>(GetArenaNoVirtual());
    value_ = p;
  }
  return value_;
}
inline ::caffe2::PlanDef* PlansMap::mutable_value() {
  // @@protoc_insertion_point(field_mutable:caffe2.PlansMap.value)
  return _internal_mutable_value();
}
inline void PlansMap::set_allocated_value(::caffe2::PlanDef* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:caffe2.PlansMap.value)
}

// -------------------------------------------------------------------

// StringMap

// required string key = 1;
inline bool StringMap::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StringMap::has_key() const {
  return _internal_has_key();
}
inline void StringMap::clear_key() {
  key_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StringMap::key() const {
  // @@protoc_insertion_point(field_get:caffe2.StringMap.key)
  return _internal_key();
}
inline void StringMap::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:caffe2.StringMap.key)
}
inline std::string* StringMap::mutable_key() {
  // @@protoc_insertion_point(field_mutable:caffe2.StringMap.key)
  return _internal_mutable_key();
}
inline const std::string& StringMap::_internal_key() const {
  return key_.GetNoArena();
}
inline void StringMap::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void StringMap::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.StringMap.key)
}
inline void StringMap::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.StringMap.key)
}
inline void StringMap::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.StringMap.key)
}
inline std::string* StringMap::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* StringMap::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.StringMap.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void StringMap::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.StringMap.key)
}

// required string value = 2;
inline bool StringMap::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StringMap::has_value() const {
  return _internal_has_value();
}
inline void StringMap::clear_value() {
  value_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StringMap::value() const {
  // @@protoc_insertion_point(field_get:caffe2.StringMap.value)
  return _internal_value();
}
inline void StringMap::set_value(const std::string& value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:caffe2.StringMap.value)
}
inline std::string* StringMap::mutable_value() {
  // @@protoc_insertion_point(field_mutable:caffe2.StringMap.value)
  return _internal_mutable_value();
}
inline const std::string& StringMap::_internal_value() const {
  return value_.GetNoArena();
}
inline void StringMap::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void StringMap::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.StringMap.value)
}
inline void StringMap::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.StringMap.value)
}
inline void StringMap::set_value(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.StringMap.value)
}
inline std::string* StringMap::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* StringMap::release_value() {
  // @@protoc_insertion_point(field_release:caffe2.StringMap.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void StringMap::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:caffe2.StringMap.value)
}

// -------------------------------------------------------------------

// MetaNetDef

// repeated .caffe2.BlobsMap blobs = 1;
inline int MetaNetDef::_internal_blobs_size() const {
  return blobs_.size();
}
inline int MetaNetDef::blobs_size() const {
  return _internal_blobs_size();
}
inline void MetaNetDef::clear_blobs() {
  blobs_.Clear();
}
inline ::caffe2::BlobsMap* MetaNetDef::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.blobs)
  return blobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::BlobsMap >*
MetaNetDef::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.blobs)
  return &blobs_;
}
inline const ::caffe2::BlobsMap& MetaNetDef::_internal_blobs(int index) const {
  return blobs_.Get(index);
}
inline const ::caffe2::BlobsMap& MetaNetDef::blobs(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.blobs)
  return _internal_blobs(index);
}
inline ::caffe2::BlobsMap* MetaNetDef::_internal_add_blobs() {
  return blobs_.Add();
}
inline ::caffe2::BlobsMap* MetaNetDef::add_blobs() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.blobs)
  return _internal_add_blobs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::BlobsMap >&
MetaNetDef::blobs() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.blobs)
  return blobs_;
}

// repeated .caffe2.NetsMap nets = 2;
inline int MetaNetDef::_internal_nets_size() const {
  return nets_.size();
}
inline int MetaNetDef::nets_size() const {
  return _internal_nets_size();
}
inline void MetaNetDef::clear_nets() {
  nets_.Clear();
}
inline ::caffe2::NetsMap* MetaNetDef::mutable_nets(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.nets)
  return nets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetsMap >*
MetaNetDef::mutable_nets() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.nets)
  return &nets_;
}
inline const ::caffe2::NetsMap& MetaNetDef::_internal_nets(int index) const {
  return nets_.Get(index);
}
inline const ::caffe2::NetsMap& MetaNetDef::nets(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.nets)
  return _internal_nets(index);
}
inline ::caffe2::NetsMap* MetaNetDef::_internal_add_nets() {
  return nets_.Add();
}
inline ::caffe2::NetsMap* MetaNetDef::add_nets() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.nets)
  return _internal_add_nets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetsMap >&
MetaNetDef::nets() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.nets)
  return nets_;
}

// optional .caffe2.ModelInfo modelInfo = 3;
inline bool MetaNetDef::_internal_has_modelinfo() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || modelinfo_ != nullptr);
  return value;
}
inline bool MetaNetDef::has_modelinfo() const {
  return _internal_has_modelinfo();
}
inline void MetaNetDef::clear_modelinfo() {
  if (modelinfo_ != nullptr) modelinfo_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::caffe2::ModelInfo& MetaNetDef::_internal_modelinfo() const {
  const ::caffe2::ModelInfo* p = modelinfo_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::ModelInfo*>(
      &::caffe2::_ModelInfo_default_instance_);
}
inline const ::caffe2::ModelInfo& MetaNetDef::modelinfo() const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.modelInfo)
  return _internal_modelinfo();
}
inline ::caffe2::ModelInfo* MetaNetDef::release_modelinfo() {
  // @@protoc_insertion_point(field_release:caffe2.MetaNetDef.modelInfo)
  _has_bits_[0] &= ~0x00000001u;
  ::caffe2::ModelInfo* temp = modelinfo_;
  modelinfo_ = nullptr;
  return temp;
}
inline ::caffe2::ModelInfo* MetaNetDef::_internal_mutable_modelinfo() {
  _has_bits_[0] |= 0x00000001u;
  if (modelinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::ModelInfo>(GetArenaNoVirtual());
    modelinfo_ = p;
  }
  return modelinfo_;
}
inline ::caffe2::ModelInfo* MetaNetDef::mutable_modelinfo() {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.modelInfo)
  return _internal_mutable_modelinfo();
}
inline void MetaNetDef::set_allocated_modelinfo(::caffe2::ModelInfo* modelinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete modelinfo_;
  }
  if (modelinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      modelinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, modelinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  modelinfo_ = modelinfo;
  // @@protoc_insertion_point(field_set_allocated:caffe2.MetaNetDef.modelInfo)
}

// repeated .caffe2.PlansMap plans = 4;
inline int MetaNetDef::_internal_plans_size() const {
  return plans_.size();
}
inline int MetaNetDef::plans_size() const {
  return _internal_plans_size();
}
inline void MetaNetDef::clear_plans() {
  plans_.Clear();
}
inline ::caffe2::PlansMap* MetaNetDef::mutable_plans(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.plans)
  return plans_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::PlansMap >*
MetaNetDef::mutable_plans() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.plans)
  return &plans_;
}
inline const ::caffe2::PlansMap& MetaNetDef::_internal_plans(int index) const {
  return plans_.Get(index);
}
inline const ::caffe2::PlansMap& MetaNetDef::plans(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.plans)
  return _internal_plans(index);
}
inline ::caffe2::PlansMap* MetaNetDef::_internal_add_plans() {
  return plans_.Add();
}
inline ::caffe2::PlansMap* MetaNetDef::add_plans() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.plans)
  return _internal_add_plans();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::PlansMap >&
MetaNetDef::plans() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.plans)
  return plans_;
}

// repeated .caffe2.StringMap applicationSpecificInfo = 5;
inline int MetaNetDef::_internal_applicationspecificinfo_size() const {
  return applicationspecificinfo_.size();
}
inline int MetaNetDef::applicationspecificinfo_size() const {
  return _internal_applicationspecificinfo_size();
}
inline void MetaNetDef::clear_applicationspecificinfo() {
  applicationspecificinfo_.Clear();
}
inline ::caffe2::StringMap* MetaNetDef::mutable_applicationspecificinfo(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::StringMap >*
MetaNetDef::mutable_applicationspecificinfo() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.applicationSpecificInfo)
  return &applicationspecificinfo_;
}
inline const ::caffe2::StringMap& MetaNetDef::_internal_applicationspecificinfo(int index) const {
  return applicationspecificinfo_.Get(index);
}
inline const ::caffe2::StringMap& MetaNetDef::applicationspecificinfo(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.applicationSpecificInfo)
  return _internal_applicationspecificinfo(index);
}
inline ::caffe2::StringMap* MetaNetDef::_internal_add_applicationspecificinfo() {
  return applicationspecificinfo_.Add();
}
inline ::caffe2::StringMap* MetaNetDef::add_applicationspecificinfo() {
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.applicationSpecificInfo)
  return _internal_add_applicationspecificinfo();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::StringMap >&
MetaNetDef::applicationspecificinfo() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.applicationSpecificInfo)
  return applicationspecificinfo_;
}

// repeated string blobsOrder = 6;
inline int MetaNetDef::_internal_blobsorder_size() const {
  return blobsorder_.size();
}
inline int MetaNetDef::blobsorder_size() const {
  return _internal_blobsorder_size();
}
inline void MetaNetDef::clear_blobsorder() {
  blobsorder_.Clear();
}
inline std::string* MetaNetDef::add_blobsorder() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.MetaNetDef.blobsOrder)
  return _internal_add_blobsorder();
}
inline const std::string& MetaNetDef::_internal_blobsorder(int index) const {
  return blobsorder_.Get(index);
}
inline const std::string& MetaNetDef::blobsorder(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.blobsOrder)
  return _internal_blobsorder(index);
}
inline std::string* MetaNetDef::mutable_blobsorder(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.blobsOrder)
  return blobsorder_.Mutable(index);
}
inline void MetaNetDef::set_blobsorder(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.MetaNetDef.blobsOrder)
  blobsorder_.Mutable(index)->assign(value);
}
inline void MetaNetDef::set_blobsorder(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.MetaNetDef.blobsOrder)
  blobsorder_.Mutable(index)->assign(std::move(value));
}
inline void MetaNetDef::set_blobsorder(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blobsorder_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.MetaNetDef.blobsOrder)
}
inline void MetaNetDef::set_blobsorder(int index, const char* value, size_t size) {
  blobsorder_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.MetaNetDef.blobsOrder)
}
inline std::string* MetaNetDef::_internal_add_blobsorder() {
  return blobsorder_.Add();
}
inline void MetaNetDef::add_blobsorder(const std::string& value) {
  blobsorder_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.blobsOrder)
}
inline void MetaNetDef::add_blobsorder(std::string&& value) {
  blobsorder_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.blobsOrder)
}
inline void MetaNetDef::add_blobsorder(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  blobsorder_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.MetaNetDef.blobsOrder)
}
inline void MetaNetDef::add_blobsorder(const char* value, size_t size) {
  blobsorder_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.MetaNetDef.blobsOrder)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MetaNetDef::blobsorder() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.blobsOrder)
  return blobsorder_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MetaNetDef::mutable_blobsorder() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.blobsOrder)
  return &blobsorder_;
}

// repeated string preLoadBlobs = 7;
inline int MetaNetDef::_internal_preloadblobs_size() const {
  return preloadblobs_.size();
}
inline int MetaNetDef::preloadblobs_size() const {
  return _internal_preloadblobs_size();
}
inline void MetaNetDef::clear_preloadblobs() {
  preloadblobs_.Clear();
}
inline std::string* MetaNetDef::add_preloadblobs() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.MetaNetDef.preLoadBlobs)
  return _internal_add_preloadblobs();
}
inline const std::string& MetaNetDef::_internal_preloadblobs(int index) const {
  return preloadblobs_.Get(index);
}
inline const std::string& MetaNetDef::preloadblobs(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.preLoadBlobs)
  return _internal_preloadblobs(index);
}
inline std::string* MetaNetDef::mutable_preloadblobs(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.preLoadBlobs)
  return preloadblobs_.Mutable(index);
}
inline void MetaNetDef::set_preloadblobs(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.MetaNetDef.preLoadBlobs)
  preloadblobs_.Mutable(index)->assign(value);
}
inline void MetaNetDef::set_preloadblobs(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.MetaNetDef.preLoadBlobs)
  preloadblobs_.Mutable(index)->assign(std::move(value));
}
inline void MetaNetDef::set_preloadblobs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  preloadblobs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.MetaNetDef.preLoadBlobs)
}
inline void MetaNetDef::set_preloadblobs(int index, const char* value, size_t size) {
  preloadblobs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.MetaNetDef.preLoadBlobs)
}
inline std::string* MetaNetDef::_internal_add_preloadblobs() {
  return preloadblobs_.Add();
}
inline void MetaNetDef::add_preloadblobs(const std::string& value) {
  preloadblobs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.preLoadBlobs)
}
inline void MetaNetDef::add_preloadblobs(std::string&& value) {
  preloadblobs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.MetaNetDef.preLoadBlobs)
}
inline void MetaNetDef::add_preloadblobs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  preloadblobs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.MetaNetDef.preLoadBlobs)
}
inline void MetaNetDef::add_preloadblobs(const char* value, size_t size) {
  preloadblobs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.MetaNetDef.preLoadBlobs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MetaNetDef::preloadblobs() const {
  // @@protoc_insertion_point(field_list:caffe2.MetaNetDef.preLoadBlobs)
  return preloadblobs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MetaNetDef::mutable_preloadblobs() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.MetaNetDef.preLoadBlobs)
  return &preloadblobs_;
}

// optional .caffe2.TensorBoundShapes tensorBoundShapes = 8;
inline bool MetaNetDef::_internal_has_tensorboundshapes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || tensorboundshapes_ != nullptr);
  return value;
}
inline bool MetaNetDef::has_tensorboundshapes() const {
  return _internal_has_tensorboundshapes();
}
inline const ::caffe2::TensorBoundShapes& MetaNetDef::_internal_tensorboundshapes() const {
  const ::caffe2::TensorBoundShapes* p = tensorboundshapes_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::TensorBoundShapes*>(
      &::caffe2::_TensorBoundShapes_default_instance_);
}
inline const ::caffe2::TensorBoundShapes& MetaNetDef::tensorboundshapes() const {
  // @@protoc_insertion_point(field_get:caffe2.MetaNetDef.tensorBoundShapes)
  return _internal_tensorboundshapes();
}
inline ::caffe2::TensorBoundShapes* MetaNetDef::release_tensorboundshapes() {
  // @@protoc_insertion_point(field_release:caffe2.MetaNetDef.tensorBoundShapes)
  _has_bits_[0] &= ~0x00000002u;
  ::caffe2::TensorBoundShapes* temp = tensorboundshapes_;
  tensorboundshapes_ = nullptr;
  return temp;
}
inline ::caffe2::TensorBoundShapes* MetaNetDef::_internal_mutable_tensorboundshapes() {
  _has_bits_[0] |= 0x00000002u;
  if (tensorboundshapes_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::TensorBoundShapes>(GetArenaNoVirtual());
    tensorboundshapes_ = p;
  }
  return tensorboundshapes_;
}
inline ::caffe2::TensorBoundShapes* MetaNetDef::mutable_tensorboundshapes() {
  // @@protoc_insertion_point(field_mutable:caffe2.MetaNetDef.tensorBoundShapes)
  return _internal_mutable_tensorboundshapes();
}
inline void MetaNetDef::set_allocated_tensorboundshapes(::caffe2::TensorBoundShapes* tensorboundshapes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tensorboundshapes_);
  }
  if (tensorboundshapes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tensorboundshapes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensorboundshapes, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  tensorboundshapes_ = tensorboundshapes;
  // @@protoc_insertion_point(field_set_allocated:caffe2.MetaNetDef.tensorBoundShapes)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace caffe2

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_caffe2_2fproto_2fmetanet_2eproto
