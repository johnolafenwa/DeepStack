// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe2/proto/caffe2.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_caffe2_2fproto_2fcaffe2_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_caffe2_2fproto_2fcaffe2_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2fcaffe2_2eproto CAFFE2_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct CAFFE2_API TableStruct_caffe2_2fproto_2fcaffe2_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern CAFFE2_API const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_caffe2_2fproto_2fcaffe2_2eproto;
namespace caffe2 { const ::std::string& GetEmptyStringAlreadyInited(); 
class Argument;
class ArgumentDefaultTypeInternal;
CAFFE2_API extern ArgumentDefaultTypeInternal _Argument_default_instance_;
class BackendOptions;
class BackendOptionsDefaultTypeInternal;
CAFFE2_API extern BackendOptionsDefaultTypeInternal _BackendOptions_default_instance_;
class BlobProto;
class BlobProtoDefaultTypeInternal;
CAFFE2_API extern BlobProtoDefaultTypeInternal _BlobProto_default_instance_;
class DBReaderProto;
class DBReaderProtoDefaultTypeInternal;
CAFFE2_API extern DBReaderProtoDefaultTypeInternal _DBReaderProto_default_instance_;
class DeviceOption;
class DeviceOptionDefaultTypeInternal;
CAFFE2_API extern DeviceOptionDefaultTypeInternal _DeviceOption_default_instance_;
class ExecutionStep;
class ExecutionStepDefaultTypeInternal;
CAFFE2_API extern ExecutionStepDefaultTypeInternal _ExecutionStep_default_instance_;
class ExternalDataProto;
class ExternalDataProtoDefaultTypeInternal;
CAFFE2_API extern ExternalDataProtoDefaultTypeInternal _ExternalDataProto_default_instance_;
class MapFieldEntry;
class MapFieldEntryDefaultTypeInternal;
CAFFE2_API extern MapFieldEntryDefaultTypeInternal _MapFieldEntry_default_instance_;
class NetDef;
class NetDefDefaultTypeInternal;
CAFFE2_API extern NetDefDefaultTypeInternal _NetDef_default_instance_;
class OperatorDef;
class OperatorDefDefaultTypeInternal;
CAFFE2_API extern OperatorDefDefaultTypeInternal _OperatorDef_default_instance_;
class PartitionInfo;
class PartitionInfoDefaultTypeInternal;
CAFFE2_API extern PartitionInfoDefaultTypeInternal _PartitionInfo_default_instance_;
class PlanDef;
class PlanDefDefaultTypeInternal;
CAFFE2_API extern PlanDefDefaultTypeInternal _PlanDef_default_instance_;
class QTensorProto;
class QTensorProtoDefaultTypeInternal;
CAFFE2_API extern QTensorProtoDefaultTypeInternal _QTensorProto_default_instance_;
class TensorBoundShape;
class TensorBoundShapeDefaultTypeInternal;
CAFFE2_API extern TensorBoundShapeDefaultTypeInternal _TensorBoundShape_default_instance_;
class TensorBoundShapes;
class TensorBoundShapesDefaultTypeInternal;
CAFFE2_API extern TensorBoundShapesDefaultTypeInternal _TensorBoundShapes_default_instance_;
class TensorProto;
class TensorProtoDefaultTypeInternal;
CAFFE2_API extern TensorProtoDefaultTypeInternal _TensorProto_default_instance_;
class TensorProto_Segment;
class TensorProto_SegmentDefaultTypeInternal;
CAFFE2_API extern TensorProto_SegmentDefaultTypeInternal _TensorProto_Segment_default_instance_;
class TensorProtos;
class TensorProtosDefaultTypeInternal;
CAFFE2_API extern TensorProtosDefaultTypeInternal _TensorProtos_default_instance_;
class TensorShape;
class TensorShapeDefaultTypeInternal;
CAFFE2_API extern TensorShapeDefaultTypeInternal _TensorShape_default_instance_;
class TensorShapes;
class TensorShapesDefaultTypeInternal;
CAFFE2_API extern TensorShapesDefaultTypeInternal _TensorShapes_default_instance_;
}  // namespace caffe2
PROTOBUF_NAMESPACE_OPEN
template<> CAFFE2_API ::caffe2::Argument* Arena::CreateMaybeMessage<::caffe2::Argument>(Arena*);
template<> CAFFE2_API ::caffe2::BackendOptions* Arena::CreateMaybeMessage<::caffe2::BackendOptions>(Arena*);
template<> CAFFE2_API ::caffe2::BlobProto* Arena::CreateMaybeMessage<::caffe2::BlobProto>(Arena*);
template<> CAFFE2_API ::caffe2::DBReaderProto* Arena::CreateMaybeMessage<::caffe2::DBReaderProto>(Arena*);
template<> CAFFE2_API ::caffe2::DeviceOption* Arena::CreateMaybeMessage<::caffe2::DeviceOption>(Arena*);
template<> CAFFE2_API ::caffe2::ExecutionStep* Arena::CreateMaybeMessage<::caffe2::ExecutionStep>(Arena*);
template<> CAFFE2_API ::caffe2::ExternalDataProto* Arena::CreateMaybeMessage<::caffe2::ExternalDataProto>(Arena*);
template<> CAFFE2_API ::caffe2::MapFieldEntry* Arena::CreateMaybeMessage<::caffe2::MapFieldEntry>(Arena*);
template<> CAFFE2_API ::caffe2::NetDef* Arena::CreateMaybeMessage<::caffe2::NetDef>(Arena*);
template<> CAFFE2_API ::caffe2::OperatorDef* Arena::CreateMaybeMessage<::caffe2::OperatorDef>(Arena*);
template<> CAFFE2_API ::caffe2::PartitionInfo* Arena::CreateMaybeMessage<::caffe2::PartitionInfo>(Arena*);
template<> CAFFE2_API ::caffe2::PlanDef* Arena::CreateMaybeMessage<::caffe2::PlanDef>(Arena*);
template<> CAFFE2_API ::caffe2::QTensorProto* Arena::CreateMaybeMessage<::caffe2::QTensorProto>(Arena*);
template<> CAFFE2_API ::caffe2::TensorBoundShape* Arena::CreateMaybeMessage<::caffe2::TensorBoundShape>(Arena*);
template<> CAFFE2_API ::caffe2::TensorBoundShapes* Arena::CreateMaybeMessage<::caffe2::TensorBoundShapes>(Arena*);
template<> CAFFE2_API ::caffe2::TensorProto* Arena::CreateMaybeMessage<::caffe2::TensorProto>(Arena*);
template<> CAFFE2_API ::caffe2::TensorProto_Segment* Arena::CreateMaybeMessage<::caffe2::TensorProto_Segment>(Arena*);
template<> CAFFE2_API ::caffe2::TensorProtos* Arena::CreateMaybeMessage<::caffe2::TensorProtos>(Arena*);
template<> CAFFE2_API ::caffe2::TensorShape* Arena::CreateMaybeMessage<::caffe2::TensorShape>(Arena*);
template<> CAFFE2_API ::caffe2::TensorShapes* Arena::CreateMaybeMessage<::caffe2::TensorShapes>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace caffe2 {

enum ExternalDataProto_SourceType : int {
  ExternalDataProto_SourceType_INLINE_CONTAINER = 0,
  ExternalDataProto_SourceType_SIMPLE_FILE = 1
};
CAFFE2_API bool ExternalDataProto_SourceType_IsValid(int value);
constexpr ExternalDataProto_SourceType ExternalDataProto_SourceType_SourceType_MIN = ExternalDataProto_SourceType_INLINE_CONTAINER;
constexpr ExternalDataProto_SourceType ExternalDataProto_SourceType_SourceType_MAX = ExternalDataProto_SourceType_SIMPLE_FILE;
constexpr int ExternalDataProto_SourceType_SourceType_ARRAYSIZE = ExternalDataProto_SourceType_SourceType_MAX + 1;

CAFFE2_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExternalDataProto_SourceType_descriptor();
template<typename T>
inline const std::string& ExternalDataProto_SourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExternalDataProto_SourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExternalDataProto_SourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExternalDataProto_SourceType_descriptor(), enum_t_value);
}
inline bool ExternalDataProto_SourceType_Parse(
    const std::string& name, ExternalDataProto_SourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExternalDataProto_SourceType>(
    ExternalDataProto_SourceType_descriptor(), name, value);
}
enum TensorProto_DataType : int {
  TensorProto_DataType_UNDEFINED = 0,
  TensorProto_DataType_FLOAT = 1,
  TensorProto_DataType_INT32 = 2,
  TensorProto_DataType_BYTE = 3,
  TensorProto_DataType_STRING = 4,
  TensorProto_DataType_BOOL = 5,
  TensorProto_DataType_UINT8 = 6,
  TensorProto_DataType_INT8 = 7,
  TensorProto_DataType_UINT16 = 8,
  TensorProto_DataType_INT16 = 9,
  TensorProto_DataType_INT64 = 10,
  TensorProto_DataType_FLOAT16 = 12,
  TensorProto_DataType_DOUBLE = 13,
  TensorProto_DataType_ZERO_COLLISION_HASH = 14
};
CAFFE2_API bool TensorProto_DataType_IsValid(int value);
constexpr TensorProto_DataType TensorProto_DataType_DataType_MIN = TensorProto_DataType_UNDEFINED;
constexpr TensorProto_DataType TensorProto_DataType_DataType_MAX = TensorProto_DataType_ZERO_COLLISION_HASH;
constexpr int TensorProto_DataType_DataType_ARRAYSIZE = TensorProto_DataType_DataType_MAX + 1;

CAFFE2_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TensorProto_DataType_descriptor();
template<typename T>
inline const std::string& TensorProto_DataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TensorProto_DataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TensorProto_DataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TensorProto_DataType_descriptor(), enum_t_value);
}
inline bool TensorProto_DataType_Parse(
    const std::string& name, TensorProto_DataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TensorProto_DataType>(
    TensorProto_DataType_descriptor(), name, value);
}
enum TensorProto_StorageType : int {
  TensorProto_StorageType_TYPED = 1,
  TensorProto_StorageType_RAW = 2,
  TensorProto_StorageType_EXTERNAL = 3,
  TensorProto_StorageType_NO_CONTENT = 4
};
CAFFE2_API bool TensorProto_StorageType_IsValid(int value);
constexpr TensorProto_StorageType TensorProto_StorageType_StorageType_MIN = TensorProto_StorageType_TYPED;
constexpr TensorProto_StorageType TensorProto_StorageType_StorageType_MAX = TensorProto_StorageType_NO_CONTENT;
constexpr int TensorProto_StorageType_StorageType_ARRAYSIZE = TensorProto_StorageType_StorageType_MAX + 1;

CAFFE2_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TensorProto_StorageType_descriptor();
template<typename T>
inline const std::string& TensorProto_StorageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TensorProto_StorageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TensorProto_StorageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TensorProto_StorageType_descriptor(), enum_t_value);
}
inline bool TensorProto_StorageType_Parse(
    const std::string& name, TensorProto_StorageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TensorProto_StorageType>(
    TensorProto_StorageType_descriptor(), name, value);
}
enum TensorBoundShape_DimType : int {
  TensorBoundShape_DimType_UNKNOWN = 0,
  TensorBoundShape_DimType_CONSTANT = 1,
  TensorBoundShape_DimType_BATCH = 2,
  TensorBoundShape_DimType_BATCH_OF_FEATURE_MAX = 3,
  TensorBoundShape_DimType_BATCH_OF_FEATURE_MAX_DEFAULT = 4,
  TensorBoundShape_DimType_FEATURE_MAX = 5,
  TensorBoundShape_DimType_FEATURE_MAX_DEFAULT = 6
};
CAFFE2_API bool TensorBoundShape_DimType_IsValid(int value);
constexpr TensorBoundShape_DimType TensorBoundShape_DimType_DimType_MIN = TensorBoundShape_DimType_UNKNOWN;
constexpr TensorBoundShape_DimType TensorBoundShape_DimType_DimType_MAX = TensorBoundShape_DimType_FEATURE_MAX_DEFAULT;
constexpr int TensorBoundShape_DimType_DimType_ARRAYSIZE = TensorBoundShape_DimType_DimType_MAX + 1;

CAFFE2_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TensorBoundShape_DimType_descriptor();
template<typename T>
inline const std::string& TensorBoundShape_DimType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TensorBoundShape_DimType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TensorBoundShape_DimType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TensorBoundShape_DimType_descriptor(), enum_t_value);
}
inline bool TensorBoundShape_DimType_Parse(
    const std::string& name, TensorBoundShape_DimType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TensorBoundShape_DimType>(
    TensorBoundShape_DimType_descriptor(), name, value);
}
enum DeviceTypeProto : int {
  PROTO_CPU = 0,
  PROTO_CUDA = 1,
  PROTO_MKLDNN = 2,
  PROTO_OPENGL = 3,
  PROTO_OPENCL = 4,
  PROTO_IDEEP = 5,
  PROTO_HIP = 6,
  PROTO_FPGA = 7,
  PROTO_MSNPU = 8,
  PROTO_XLA = 9,
  PROTO_COMPILE_TIME_MAX_DEVICE_TYPES = 10,
  PROTO_ONLY_FOR_TEST = 20901
};
CAFFE2_API bool DeviceTypeProto_IsValid(int value);
constexpr DeviceTypeProto DeviceTypeProto_MIN = PROTO_CPU;
constexpr DeviceTypeProto DeviceTypeProto_MAX = PROTO_ONLY_FOR_TEST;
constexpr int DeviceTypeProto_ARRAYSIZE = DeviceTypeProto_MAX + 1;

CAFFE2_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeviceTypeProto_descriptor();
template<typename T>
inline const std::string& DeviceTypeProto_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeviceTypeProto>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeviceTypeProto_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeviceTypeProto_descriptor(), enum_t_value);
}
inline bool DeviceTypeProto_Parse(
    const std::string& name, DeviceTypeProto* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeviceTypeProto>(
    DeviceTypeProto_descriptor(), name, value);
}
// ===================================================================

class CAFFE2_API ExternalDataProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.ExternalDataProto) */ {
 public:
  ExternalDataProto();
  virtual ~ExternalDataProto();

  ExternalDataProto(const ExternalDataProto& from);
  ExternalDataProto(ExternalDataProto&& from) noexcept
    : ExternalDataProto() {
    *this = ::std::move(from);
  }

  inline ExternalDataProto& operator=(const ExternalDataProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExternalDataProto& operator=(ExternalDataProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExternalDataProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExternalDataProto* internal_default_instance() {
    return reinterpret_cast<const ExternalDataProto*>(
               &_ExternalDataProto_default_instance_);
  }
  static int const kIndexInFileMessages =
    0;

  friend void swap(ExternalDataProto& a, ExternalDataProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ExternalDataProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExternalDataProto* New() const final {
    return CreateMaybeMessage<ExternalDataProto>(nullptr);
  }

  ExternalDataProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExternalDataProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExternalDataProto& from);
  void MergeFrom(const ExternalDataProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternalDataProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.ExternalDataProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ExternalDataProto_SourceType SourceType;
  static SourceType const INLINE_CONTAINER =
    ExternalDataProto_SourceType_INLINE_CONTAINER;
  static SourceType const SIMPLE_FILE =
    ExternalDataProto_SourceType_SIMPLE_FILE;
  static inline bool SourceType_IsValid(int value) {
    return ExternalDataProto_SourceType_IsValid(value);
  }
  static SourceType const SourceType_MIN =
    ExternalDataProto_SourceType_SourceType_MIN;
  static SourceType const SourceType_MAX =
    ExternalDataProto_SourceType_SourceType_MAX;
  static int const SourceType_ARRAYSIZE =
    ExternalDataProto_SourceType_SourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SourceType_descriptor() {
    return ExternalDataProto_SourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& SourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SourceType_Name.");
    return ExternalDataProto_SourceType_Name(enum_t_value);
  }
  static inline bool SourceType_Parse(const std::string& name,
      SourceType* value) {
    return ExternalDataProto_SourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStridesFieldNumber = 4,
    kRecordIdFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kRecordSizeFieldNumber = 5,
    kSourceTypeFieldNumber = 1,
  };
  // repeated int64 strides = 4;
  int strides_size() const;
  private:
  int _internal_strides_size() const;
  public:
  void clear_strides();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_strides(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_strides() const;
  void _internal_add_strides(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_strides();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 strides(int index) const;
  void set_strides(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_strides(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      strides() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_strides();

  // optional string record_id = 2;
  bool has_record_id() const;
  private:
  bool _internal_has_record_id() const;
  public:
  void clear_record_id();
  const std::string& record_id() const;
  void set_record_id(const std::string& value);
  void set_record_id(std::string&& value);
  void set_record_id(const char* value);
  void set_record_id(const char* value, size_t size);
  std::string* mutable_record_id();
  std::string* release_record_id();
  void set_allocated_record_id(std::string* record_id);
  private:
  const std::string& _internal_record_id() const;
  void _internal_set_record_id(const std::string& value);
  std::string* _internal_mutable_record_id();
  public:

  // optional int64 offset = 3 [default = 0];
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional uint64 record_size = 5;
  bool has_record_size() const;
  private:
  bool _internal_has_record_size() const;
  public:
  void clear_record_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 record_size() const;
  void set_record_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_record_size() const;
  void _internal_set_record_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional .caffe2.ExternalDataProto.SourceType source_type = 1 [default = INLINE_CONTAINER];
  bool has_source_type() const;
  private:
  bool _internal_has_source_type() const;
  public:
  void clear_source_type();
  ::caffe2::ExternalDataProto_SourceType source_type() const;
  void set_source_type(::caffe2::ExternalDataProto_SourceType value);
  private:
  ::caffe2::ExternalDataProto_SourceType _internal_source_type() const;
  void _internal_set_source_type(::caffe2::ExternalDataProto_SourceType value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.ExternalDataProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > strides_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr record_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  ::PROTOBUF_NAMESPACE_ID::uint64 record_size_;
  int source_type_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API TensorProto_Segment :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorProto.Segment) */ {
 public:
  TensorProto_Segment();
  virtual ~TensorProto_Segment();

  TensorProto_Segment(const TensorProto_Segment& from);
  TensorProto_Segment(TensorProto_Segment&& from) noexcept
    : TensorProto_Segment() {
    *this = ::std::move(from);
  }

  inline TensorProto_Segment& operator=(const TensorProto_Segment& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorProto_Segment& operator=(TensorProto_Segment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TensorProto_Segment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorProto_Segment* internal_default_instance() {
    return reinterpret_cast<const TensorProto_Segment*>(
               &_TensorProto_Segment_default_instance_);
  }
  static int const kIndexInFileMessages =
    1;

  friend void swap(TensorProto_Segment& a, TensorProto_Segment& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorProto_Segment* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TensorProto_Segment* New() const final {
    return CreateMaybeMessage<TensorProto_Segment>(nullptr);
  }

  TensorProto_Segment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TensorProto_Segment>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TensorProto_Segment& from);
  void MergeFrom(const TensorProto_Segment& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorProto_Segment* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.TensorProto.Segment";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBeginFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // required int64 begin = 1;
  bool has_begin() const;
  private:
  bool _internal_has_begin() const;
  public:
  void clear_begin();
  ::PROTOBUF_NAMESPACE_ID::int64 begin() const;
  void set_begin(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_begin() const;
  void _internal_set_begin(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // required int64 end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  ::PROTOBUF_NAMESPACE_ID::int64 end() const;
  void set_end(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_end() const;
  void _internal_set_end(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.TensorProto.Segment)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 begin_;
  ::PROTOBUF_NAMESPACE_ID::int64 end_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API TensorProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorProto) */ {
 public:
  TensorProto();
  virtual ~TensorProto();

  TensorProto(const TensorProto& from);
  TensorProto(TensorProto&& from) noexcept
    : TensorProto() {
    *this = ::std::move(from);
  }

  inline TensorProto& operator=(const TensorProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorProto& operator=(TensorProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TensorProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorProto* internal_default_instance() {
    return reinterpret_cast<const TensorProto*>(
               &_TensorProto_default_instance_);
  }
  static int const kIndexInFileMessages =
    2;

  friend void swap(TensorProto& a, TensorProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TensorProto* New() const final {
    return CreateMaybeMessage<TensorProto>(nullptr);
  }

  TensorProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TensorProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TensorProto& from);
  void MergeFrom(const TensorProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.TensorProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TensorProto_Segment Segment;

  typedef TensorProto_DataType DataType;
  static DataType const UNDEFINED =
    TensorProto_DataType_UNDEFINED;
  static DataType const FLOAT =
    TensorProto_DataType_FLOAT;
  static DataType const INT32 =
    TensorProto_DataType_INT32;
  static DataType const BYTE =
    TensorProto_DataType_BYTE;
  static DataType const STRING =
    TensorProto_DataType_STRING;
  static DataType const BOOL =
    TensorProto_DataType_BOOL;
  static DataType const UINT8 =
    TensorProto_DataType_UINT8;
  static DataType const INT8 =
    TensorProto_DataType_INT8;
  static DataType const UINT16 =
    TensorProto_DataType_UINT16;
  static DataType const INT16 =
    TensorProto_DataType_INT16;
  static DataType const INT64 =
    TensorProto_DataType_INT64;
  static DataType const FLOAT16 =
    TensorProto_DataType_FLOAT16;
  static DataType const DOUBLE =
    TensorProto_DataType_DOUBLE;
  static DataType const ZERO_COLLISION_HASH =
    TensorProto_DataType_ZERO_COLLISION_HASH;
  static inline bool DataType_IsValid(int value) {
    return TensorProto_DataType_IsValid(value);
  }
  static DataType const DataType_MIN =
    TensorProto_DataType_DataType_MIN;
  static DataType const DataType_MAX =
    TensorProto_DataType_DataType_MAX;
  static int const DataType_ARRAYSIZE =
    TensorProto_DataType_DataType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DataType_descriptor() {
    return TensorProto_DataType_descriptor();
  }
  template<typename T>
  static inline const std::string& DataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DataType_Name.");
    return TensorProto_DataType_Name(enum_t_value);
  }
  static inline bool DataType_Parse(const std::string& name,
      DataType* value) {
    return TensorProto_DataType_Parse(name, value);
  }

  typedef TensorProto_StorageType StorageType;
  static StorageType const TYPED =
    TensorProto_StorageType_TYPED;
  static StorageType const RAW =
    TensorProto_StorageType_RAW;
  static StorageType const EXTERNAL =
    TensorProto_StorageType_EXTERNAL;
  static StorageType const NO_CONTENT =
    TensorProto_StorageType_NO_CONTENT;
  static inline bool StorageType_IsValid(int value) {
    return TensorProto_StorageType_IsValid(value);
  }
  static StorageType const StorageType_MIN =
    TensorProto_StorageType_StorageType_MIN;
  static StorageType const StorageType_MAX =
    TensorProto_StorageType_StorageType_MAX;
  static int const StorageType_ARRAYSIZE =
    TensorProto_StorageType_StorageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StorageType_descriptor() {
    return TensorProto_StorageType_descriptor();
  }
  template<typename T>
  static inline const std::string& StorageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StorageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StorageType_Name.");
    return TensorProto_StorageType_Name(enum_t_value);
  }
  static inline bool StorageType_Parse(const std::string& name,
      StorageType* value) {
    return TensorProto_StorageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 1,
    kFloatDataFieldNumber = 3,
    kInt32DataFieldNumber = 4,
    kStringDataFieldNumber = 6,
    kDoubleDataFieldNumber = 9,
    kInt64DataFieldNumber = 10,
    kByteDataFieldNumber = 5,
    kNameFieldNumber = 7,
    kRawDataFieldNumber = 13,
    kDeviceDetailFieldNumber = 8,
    kSegmentFieldNumber = 11,
    kExternalDataFieldNumber = 14,
    kDataTypeFieldNumber = 2,
    kStorageTypeFieldNumber = 12,
  };
  // repeated int64 dims = 1;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_dims() const;
  void _internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_dims();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 dims(int index) const;
  void set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_dims();

  // repeated float float_data = 3 [packed = true];
  int float_data_size() const;
  private:
  int _internal_float_data_size() const;
  public:
  void clear_float_data();
  private:
  float _internal_float_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_float_data() const;
  void _internal_add_float_data(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_float_data();
  public:
  float float_data(int index) const;
  void set_float_data(int index, float value);
  void add_float_data(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      float_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_float_data();

  // repeated int32 int32_data = 4 [packed = true];
  int int32_data_size() const;
  private:
  int _internal_int32_data_size() const;
  public:
  void clear_int32_data();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_int32_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_int32_data() const;
  void _internal_add_int32_data(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_int32_data();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 int32_data(int index) const;
  void set_int32_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_int32_data(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      int32_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_int32_data();

  // repeated bytes string_data = 6;
  int string_data_size() const;
  private:
  int _internal_string_data_size() const;
  public:
  void clear_string_data();
  const std::string& string_data(int index) const;
  std::string* mutable_string_data(int index);
  void set_string_data(int index, const std::string& value);
  void set_string_data(int index, std::string&& value);
  void set_string_data(int index, const char* value);
  void set_string_data(int index, const void* value, size_t size);
  std::string* add_string_data();
  void add_string_data(const std::string& value);
  void add_string_data(std::string&& value);
  void add_string_data(const char* value);
  void add_string_data(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& string_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_string_data();
  private:
  const std::string& _internal_string_data(int index) const;
  std::string* _internal_add_string_data();
  public:

  // repeated double double_data = 9 [packed = true];
  int double_data_size() const;
  private:
  int _internal_double_data_size() const;
  public:
  void clear_double_data();
  private:
  double _internal_double_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_double_data() const;
  void _internal_add_double_data(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_double_data();
  public:
  double double_data(int index) const;
  void set_double_data(int index, double value);
  void add_double_data(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      double_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_double_data();

  // repeated int64 int64_data = 10 [packed = true];
  int int64_data_size() const;
  private:
  int _internal_int64_data_size() const;
  public:
  void clear_int64_data();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_int64_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_int64_data() const;
  void _internal_add_int64_data(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_int64_data();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 int64_data(int index) const;
  void set_int64_data(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_int64_data(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      int64_data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_int64_data();

  // optional bytes byte_data = 5;
  bool has_byte_data() const;
  private:
  bool _internal_has_byte_data() const;
  public:
  void clear_byte_data();
  const std::string& byte_data() const;
  void set_byte_data(const std::string& value);
  void set_byte_data(std::string&& value);
  void set_byte_data(const char* value);
  void set_byte_data(const void* value, size_t size);
  std::string* mutable_byte_data();
  std::string* release_byte_data();
  void set_allocated_byte_data(std::string* byte_data);
  private:
  const std::string& _internal_byte_data() const;
  void _internal_set_byte_data(const std::string& value);
  std::string* _internal_mutable_byte_data();
  public:

  // optional string name = 7;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bytes raw_data = 13;
  bool has_raw_data() const;
  private:
  bool _internal_has_raw_data() const;
  public:
  void clear_raw_data();
  const std::string& raw_data() const;
  void set_raw_data(const std::string& value);
  void set_raw_data(std::string&& value);
  void set_raw_data(const char* value);
  void set_raw_data(const void* value, size_t size);
  std::string* mutable_raw_data();
  std::string* release_raw_data();
  void set_allocated_raw_data(std::string* raw_data);
  private:
  const std::string& _internal_raw_data() const;
  void _internal_set_raw_data(const std::string& value);
  std::string* _internal_mutable_raw_data();
  public:

  // optional .caffe2.DeviceOption device_detail = 8;
  bool has_device_detail() const;
  private:
  bool _internal_has_device_detail() const;
  public:
  void clear_device_detail();
  const ::caffe2::DeviceOption& device_detail() const;
  ::caffe2::DeviceOption* release_device_detail();
  ::caffe2::DeviceOption* mutable_device_detail();
  void set_allocated_device_detail(::caffe2::DeviceOption* device_detail);
  private:
  const ::caffe2::DeviceOption& _internal_device_detail() const;
  ::caffe2::DeviceOption* _internal_mutable_device_detail();
  public:

  // optional .caffe2.TensorProto.Segment segment = 11;
  bool has_segment() const;
  private:
  bool _internal_has_segment() const;
  public:
  void clear_segment();
  const ::caffe2::TensorProto_Segment& segment() const;
  ::caffe2::TensorProto_Segment* release_segment();
  ::caffe2::TensorProto_Segment* mutable_segment();
  void set_allocated_segment(::caffe2::TensorProto_Segment* segment);
  private:
  const ::caffe2::TensorProto_Segment& _internal_segment() const;
  ::caffe2::TensorProto_Segment* _internal_mutable_segment();
  public:

  // optional .caffe2.ExternalDataProto external_data = 14;
  bool has_external_data() const;
  private:
  bool _internal_has_external_data() const;
  public:
  void clear_external_data();
  const ::caffe2::ExternalDataProto& external_data() const;
  ::caffe2::ExternalDataProto* release_external_data();
  ::caffe2::ExternalDataProto* mutable_external_data();
  void set_allocated_external_data(::caffe2::ExternalDataProto* external_data);
  private:
  const ::caffe2::ExternalDataProto& _internal_external_data() const;
  ::caffe2::ExternalDataProto* _internal_mutable_external_data();
  public:

  // optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
  bool has_data_type() const;
  private:
  bool _internal_has_data_type() const;
  public:
  void clear_data_type();
  ::caffe2::TensorProto_DataType data_type() const;
  void set_data_type(::caffe2::TensorProto_DataType value);
  private:
  ::caffe2::TensorProto_DataType _internal_data_type() const;
  void _internal_set_data_type(::caffe2::TensorProto_DataType value);
  public:

  // optional .caffe2.TensorProto.StorageType storage_type = 12 [default = TYPED];
  bool has_storage_type() const;
  private:
  bool _internal_has_storage_type() const;
  public:
  void clear_storage_type();
  ::caffe2::TensorProto_StorageType storage_type() const;
  void set_storage_type(::caffe2::TensorProto_StorageType value);
  private:
  ::caffe2::TensorProto_StorageType _internal_storage_type() const;
  void _internal_set_storage_type(::caffe2::TensorProto_StorageType value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.TensorProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > dims_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > float_data_;
  mutable std::atomic<int> _float_data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > int32_data_;
  mutable std::atomic<int> _int32_data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> string_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > double_data_;
  mutable std::atomic<int> _double_data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > int64_data_;
  mutable std::atomic<int> _int64_data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr byte_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_data_;
  ::caffe2::DeviceOption* device_detail_;
  ::caffe2::TensorProto_Segment* segment_;
  ::caffe2::ExternalDataProto* external_data_;
  int data_type_;
  int storage_type_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API QTensorProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.QTensorProto) */ {
 public:
  QTensorProto();
  virtual ~QTensorProto();

  QTensorProto(const QTensorProto& from);
  QTensorProto(QTensorProto&& from) noexcept
    : QTensorProto() {
    *this = ::std::move(from);
  }

  inline QTensorProto& operator=(const QTensorProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline QTensorProto& operator=(QTensorProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QTensorProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QTensorProto* internal_default_instance() {
    return reinterpret_cast<const QTensorProto*>(
               &_QTensorProto_default_instance_);
  }
  static int const kIndexInFileMessages =
    3;

  friend void swap(QTensorProto& a, QTensorProto& b) {
    a.Swap(&b);
  }
  inline void Swap(QTensorProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QTensorProto* New() const final {
    return CreateMaybeMessage<QTensorProto>(nullptr);
  }

  QTensorProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QTensorProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QTensorProto& from);
  void MergeFrom(const QTensorProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QTensorProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.QTensorProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 1,
    kDataFieldNumber = 6,
    kScalesFieldNumber = 9,
    kBiasesFieldNumber = 10,
    kNameFieldNumber = 7,
    kScaleFieldNumber = 3,
    kBiasFieldNumber = 4,
    kPrecisionFieldNumber = 2,
    kIsSignedFieldNumber = 5,
    kIsMultiparamFieldNumber = 12,
    kAxisFieldNumber = 11,
    kDataTypeFieldNumber = 8,
  };
  // repeated int64 dims = 1;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_dims() const;
  void _internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_dims();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 dims(int index) const;
  void set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_dims();

  // repeated int32 data = 6 [packed = true];
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_data(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_data() const;
  void _internal_add_data(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_data();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 data(int index) const;
  void set_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_data(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      data() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_data();

  // repeated double scales = 9;
  int scales_size() const;
  private:
  int _internal_scales_size() const;
  public:
  void clear_scales();
  private:
  double _internal_scales(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_scales() const;
  void _internal_add_scales(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_scales();
  public:
  double scales(int index) const;
  void set_scales(int index, double value);
  void add_scales(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      scales() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_scales();

  // repeated double biases = 10;
  int biases_size() const;
  private:
  int _internal_biases_size() const;
  public:
  void clear_biases();
  private:
  double _internal_biases(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_biases() const;
  void _internal_add_biases(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_biases();
  public:
  double biases(int index) const;
  void set_biases(int index, double value);
  void add_biases(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      biases() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_biases();

  // optional string name = 7;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required double scale = 3;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  double scale() const;
  void set_scale(double value);
  private:
  double _internal_scale() const;
  void _internal_set_scale(double value);
  public:

  // required double bias = 4;
  bool has_bias() const;
  private:
  bool _internal_has_bias() const;
  public:
  void clear_bias();
  double bias() const;
  void set_bias(double value);
  private:
  double _internal_bias() const;
  void _internal_set_bias(double value);
  public:

  // required int32 precision = 2;
  bool has_precision() const;
  private:
  bool _internal_has_precision() const;
  public:
  void clear_precision();
  ::PROTOBUF_NAMESPACE_ID::int32 precision() const;
  void set_precision(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_precision() const;
  void _internal_set_precision(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // required bool is_signed = 5;
  bool has_is_signed() const;
  private:
  bool _internal_has_is_signed() const;
  public:
  void clear_is_signed();
  bool is_signed() const;
  void set_is_signed(bool value);
  private:
  bool _internal_is_signed() const;
  void _internal_set_is_signed(bool value);
  public:

  // optional bool is_multiparam = 12 [default = false];
  bool has_is_multiparam() const;
  private:
  bool _internal_has_is_multiparam() const;
  public:
  void clear_is_multiparam();
  bool is_multiparam() const;
  void set_is_multiparam(bool value);
  private:
  bool _internal_is_multiparam() const;
  void _internal_set_is_multiparam(bool value);
  public:

  // optional int32 axis = 11;
  bool has_axis() const;
  private:
  bool _internal_has_axis() const;
  public:
  void clear_axis();
  ::PROTOBUF_NAMESPACE_ID::int32 axis() const;
  void set_axis(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_axis() const;
  void _internal_set_axis(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .caffe2.TensorProto.DataType data_type = 8 [default = INT32];
  bool has_data_type() const;
  private:
  bool _internal_has_data_type() const;
  public:
  void clear_data_type();
  ::caffe2::TensorProto_DataType data_type() const;
  void set_data_type(::caffe2::TensorProto_DataType value);
  private:
  ::caffe2::TensorProto_DataType _internal_data_type() const;
  void _internal_set_data_type(::caffe2::TensorProto_DataType value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.QTensorProto)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > dims_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > data_;
  mutable std::atomic<int> _data_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > scales_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > biases_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double scale_;
  double bias_;
  ::PROTOBUF_NAMESPACE_ID::int32 precision_;
  bool is_signed_;
  bool is_multiparam_;
  ::PROTOBUF_NAMESPACE_ID::int32 axis_;
  int data_type_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API TensorProtos :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorProtos) */ {
 public:
  TensorProtos();
  virtual ~TensorProtos();

  TensorProtos(const TensorProtos& from);
  TensorProtos(TensorProtos&& from) noexcept
    : TensorProtos() {
    *this = ::std::move(from);
  }

  inline TensorProtos& operator=(const TensorProtos& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorProtos& operator=(TensorProtos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TensorProtos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorProtos* internal_default_instance() {
    return reinterpret_cast<const TensorProtos*>(
               &_TensorProtos_default_instance_);
  }
  static int const kIndexInFileMessages =
    4;

  friend void swap(TensorProtos& a, TensorProtos& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorProtos* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TensorProtos* New() const final {
    return CreateMaybeMessage<TensorProtos>(nullptr);
  }

  TensorProtos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TensorProtos>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TensorProtos& from);
  void MergeFrom(const TensorProtos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorProtos* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.TensorProtos";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProtosFieldNumber = 1,
  };
  // repeated .caffe2.TensorProto protos = 1;
  int protos_size() const;
  private:
  int _internal_protos_size() const;
  public:
  void clear_protos();
  ::caffe2::TensorProto* mutable_protos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorProto >*
      mutable_protos();
  private:
  const ::caffe2::TensorProto& _internal_protos(int index) const;
  ::caffe2::TensorProto* _internal_add_protos();
  public:
  const ::caffe2::TensorProto& protos(int index) const;
  ::caffe2::TensorProto* add_protos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorProto >&
      protos() const;

  // @@protoc_insertion_point(class_scope:caffe2.TensorProtos)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorProto > protos_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API TensorShape :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorShape) */ {
 public:
  TensorShape();
  virtual ~TensorShape();

  TensorShape(const TensorShape& from);
  TensorShape(TensorShape&& from) noexcept
    : TensorShape() {
    *this = ::std::move(from);
  }

  inline TensorShape& operator=(const TensorShape& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorShape& operator=(TensorShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TensorShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorShape* internal_default_instance() {
    return reinterpret_cast<const TensorShape*>(
               &_TensorShape_default_instance_);
  }
  static int const kIndexInFileMessages =
    5;

  friend void swap(TensorShape& a, TensorShape& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorShape* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TensorShape* New() const final {
    return CreateMaybeMessage<TensorShape>(nullptr);
  }

  TensorShape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TensorShape>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TensorShape& from);
  void MergeFrom(const TensorShape& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorShape* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.TensorShape";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 1,
    kUnknownDimsFieldNumber = 3,
    kNameFieldNumber = 5,
    kUnknownShapeFieldNumber = 4,
    kDataTypeFieldNumber = 2,
  };
  // repeated int64 dims = 1;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_dims() const;
  void _internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_dims();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 dims(int index) const;
  void set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_dims();

  // repeated int32 unknown_dims = 3;
  int unknown_dims_size() const;
  private:
  int _internal_unknown_dims_size() const;
  public:
  void clear_unknown_dims();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_unknown_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_unknown_dims() const;
  void _internal_add_unknown_dims(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_unknown_dims();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 unknown_dims(int index) const;
  void set_unknown_dims(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_unknown_dims(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      unknown_dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_unknown_dims();

  // optional string name = 5;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bool unknown_shape = 4 [default = false];
  bool has_unknown_shape() const;
  private:
  bool _internal_has_unknown_shape() const;
  public:
  void clear_unknown_shape();
  bool unknown_shape() const;
  void set_unknown_shape(bool value);
  private:
  bool _internal_unknown_shape() const;
  void _internal_set_unknown_shape(bool value);
  public:

  // optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
  bool has_data_type() const;
  private:
  bool _internal_has_data_type() const;
  public:
  void clear_data_type();
  ::caffe2::TensorProto_DataType data_type() const;
  void set_data_type(::caffe2::TensorProto_DataType value);
  private:
  ::caffe2::TensorProto_DataType _internal_data_type() const;
  void _internal_set_data_type(::caffe2::TensorProto_DataType value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.TensorShape)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > dims_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > unknown_dims_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  bool unknown_shape_;
  int data_type_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API TensorShapes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorShapes) */ {
 public:
  TensorShapes();
  virtual ~TensorShapes();

  TensorShapes(const TensorShapes& from);
  TensorShapes(TensorShapes&& from) noexcept
    : TensorShapes() {
    *this = ::std::move(from);
  }

  inline TensorShapes& operator=(const TensorShapes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorShapes& operator=(TensorShapes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TensorShapes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorShapes* internal_default_instance() {
    return reinterpret_cast<const TensorShapes*>(
               &_TensorShapes_default_instance_);
  }
  static int const kIndexInFileMessages =
    6;

  friend void swap(TensorShapes& a, TensorShapes& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorShapes* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TensorShapes* New() const final {
    return CreateMaybeMessage<TensorShapes>(nullptr);
  }

  TensorShapes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TensorShapes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TensorShapes& from);
  void MergeFrom(const TensorShapes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorShapes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.TensorShapes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapesFieldNumber = 1,
  };
  // repeated .caffe2.TensorShape shapes = 1;
  int shapes_size() const;
  private:
  int _internal_shapes_size() const;
  public:
  void clear_shapes();
  ::caffe2::TensorShape* mutable_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorShape >*
      mutable_shapes();
  private:
  const ::caffe2::TensorShape& _internal_shapes(int index) const;
  ::caffe2::TensorShape* _internal_add_shapes();
  public:
  const ::caffe2::TensorShape& shapes(int index) const;
  ::caffe2::TensorShape* add_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorShape >&
      shapes() const;

  // @@protoc_insertion_point(class_scope:caffe2.TensorShapes)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorShape > shapes_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API TensorBoundShape :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorBoundShape) */ {
 public:
  TensorBoundShape();
  virtual ~TensorBoundShape();

  TensorBoundShape(const TensorBoundShape& from);
  TensorBoundShape(TensorBoundShape&& from) noexcept
    : TensorBoundShape() {
    *this = ::std::move(from);
  }

  inline TensorBoundShape& operator=(const TensorBoundShape& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorBoundShape& operator=(TensorBoundShape&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TensorBoundShape& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorBoundShape* internal_default_instance() {
    return reinterpret_cast<const TensorBoundShape*>(
               &_TensorBoundShape_default_instance_);
  }
  static int const kIndexInFileMessages =
    7;

  friend void swap(TensorBoundShape& a, TensorBoundShape& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorBoundShape* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TensorBoundShape* New() const final {
    return CreateMaybeMessage<TensorBoundShape>(nullptr);
  }

  TensorBoundShape* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TensorBoundShape>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TensorBoundShape& from);
  void MergeFrom(const TensorBoundShape& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorBoundShape* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.TensorBoundShape";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TensorBoundShape_DimType DimType;
  static DimType const UNKNOWN =
    TensorBoundShape_DimType_UNKNOWN;
  static DimType const CONSTANT =
    TensorBoundShape_DimType_CONSTANT;
  static DimType const BATCH =
    TensorBoundShape_DimType_BATCH;
  static DimType const BATCH_OF_FEATURE_MAX =
    TensorBoundShape_DimType_BATCH_OF_FEATURE_MAX;
  static DimType const BATCH_OF_FEATURE_MAX_DEFAULT =
    TensorBoundShape_DimType_BATCH_OF_FEATURE_MAX_DEFAULT;
  static DimType const FEATURE_MAX =
    TensorBoundShape_DimType_FEATURE_MAX;
  static DimType const FEATURE_MAX_DEFAULT =
    TensorBoundShape_DimType_FEATURE_MAX_DEFAULT;
  static inline bool DimType_IsValid(int value) {
    return TensorBoundShape_DimType_IsValid(value);
  }
  static DimType const DimType_MIN =
    TensorBoundShape_DimType_DimType_MIN;
  static DimType const DimType_MAX =
    TensorBoundShape_DimType_DimType_MAX;
  static int const DimType_ARRAYSIZE =
    TensorBoundShape_DimType_DimType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DimType_descriptor() {
    return TensorBoundShape_DimType_descriptor();
  }
  template<typename T>
  static inline const std::string& DimType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DimType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DimType_Name.");
    return TensorBoundShape_DimType_Name(enum_t_value);
  }
  static inline bool DimType_Parse(const std::string& name,
      DimType* value) {
    return TensorBoundShape_DimType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDimTypeFieldNumber = 2,
    kNameFieldNumber = 3,
    kShapeFieldNumber = 1,
  };
  // repeated .caffe2.TensorBoundShape.DimType dim_type = 2;
  int dim_type_size() const;
  private:
  int _internal_dim_type_size() const;
  public:
  void clear_dim_type();
  private:
  ::caffe2::TensorBoundShape_DimType _internal_dim_type(int index) const;
  void _internal_add_dim_type(::caffe2::TensorBoundShape_DimType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_dim_type();
  public:
  ::caffe2::TensorBoundShape_DimType dim_type(int index) const;
  void set_dim_type(int index, ::caffe2::TensorBoundShape_DimType value);
  void add_dim_type(::caffe2::TensorBoundShape_DimType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& dim_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_dim_type();

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .caffe2.TensorShape shape = 1;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const ::caffe2::TensorShape& shape() const;
  ::caffe2::TensorShape* release_shape();
  ::caffe2::TensorShape* mutable_shape();
  void set_allocated_shape(::caffe2::TensorShape* shape);
  private:
  const ::caffe2::TensorShape& _internal_shape() const;
  ::caffe2::TensorShape* _internal_mutable_shape();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.TensorBoundShape)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> dim_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::caffe2::TensorShape* shape_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API TensorBoundShapes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.TensorBoundShapes) */ {
 public:
  TensorBoundShapes();
  virtual ~TensorBoundShapes();

  TensorBoundShapes(const TensorBoundShapes& from);
  TensorBoundShapes(TensorBoundShapes&& from) noexcept
    : TensorBoundShapes() {
    *this = ::std::move(from);
  }

  inline TensorBoundShapes& operator=(const TensorBoundShapes& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorBoundShapes& operator=(TensorBoundShapes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TensorBoundShapes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorBoundShapes* internal_default_instance() {
    return reinterpret_cast<const TensorBoundShapes*>(
               &_TensorBoundShapes_default_instance_);
  }
  static int const kIndexInFileMessages =
    8;

  friend void swap(TensorBoundShapes& a, TensorBoundShapes& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorBoundShapes* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TensorBoundShapes* New() const final {
    return CreateMaybeMessage<TensorBoundShapes>(nullptr);
  }

  TensorBoundShapes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TensorBoundShapes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TensorBoundShapes& from);
  void MergeFrom(const TensorBoundShapes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorBoundShapes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.TensorBoundShapes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapesFieldNumber = 1,
    kMaxBatchSizeFieldNumber = 2,
    kMaxFeatureLenFieldNumber = 3,
  };
  // repeated .caffe2.TensorBoundShape shapes = 1;
  int shapes_size() const;
  private:
  int _internal_shapes_size() const;
  public:
  void clear_shapes();
  ::caffe2::TensorBoundShape* mutable_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorBoundShape >*
      mutable_shapes();
  private:
  const ::caffe2::TensorBoundShape& _internal_shapes(int index) const;
  ::caffe2::TensorBoundShape* _internal_add_shapes();
  public:
  const ::caffe2::TensorBoundShape& shapes(int index) const;
  ::caffe2::TensorBoundShape* add_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorBoundShape >&
      shapes() const;

  // optional int64 max_batch_size = 2;
  bool has_max_batch_size() const;
  private:
  bool _internal_has_max_batch_size() const;
  public:
  void clear_max_batch_size();
  ::PROTOBUF_NAMESPACE_ID::int64 max_batch_size() const;
  void set_max_batch_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_batch_size() const;
  void _internal_set_max_batch_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 max_feature_len = 3;
  bool has_max_feature_len() const;
  private:
  bool _internal_has_max_feature_len() const;
  public:
  void clear_max_feature_len();
  ::PROTOBUF_NAMESPACE_ID::int64 max_feature_len() const;
  void set_max_feature_len(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_feature_len() const;
  void _internal_set_max_feature_len(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.TensorBoundShapes)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorBoundShape > shapes_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_batch_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_feature_len_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API Argument :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.Argument) */ {
 public:
  Argument();
  virtual ~Argument();

  Argument(const Argument& from);
  Argument(Argument&& from) noexcept
    : Argument() {
    *this = ::std::move(from);
  }

  inline Argument& operator=(const Argument& from) {
    CopyFrom(from);
    return *this;
  }
  inline Argument& operator=(Argument&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Argument& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Argument* internal_default_instance() {
    return reinterpret_cast<const Argument*>(
               &_Argument_default_instance_);
  }
  static int const kIndexInFileMessages =
    9;

  friend void swap(Argument& a, Argument& b) {
    a.Swap(&b);
  }
  inline void Swap(Argument* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Argument* New() const final {
    return CreateMaybeMessage<Argument>(nullptr);
  }

  Argument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Argument>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Argument& from);
  void MergeFrom(const Argument& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Argument* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.Argument";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFloatsFieldNumber = 5,
    kIntsFieldNumber = 6,
    kStringsFieldNumber = 7,
    kNetsFieldNumber = 9,
    kTensorsFieldNumber = 11,
    kQtensorsFieldNumber = 12,
    kNameFieldNumber = 1,
    kSFieldNumber = 4,
    kNFieldNumber = 8,
    kTFieldNumber = 10,
    kIFieldNumber = 3,
    kFFieldNumber = 2,
  };
  // repeated float floats = 5;
  int floats_size() const;
  private:
  int _internal_floats_size() const;
  public:
  void clear_floats();
  private:
  float _internal_floats(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_floats() const;
  void _internal_add_floats(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_floats();
  public:
  float floats(int index) const;
  void set_floats(int index, float value);
  void add_floats(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      floats() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_floats();

  // repeated int64 ints = 6;
  int ints_size() const;
  private:
  int _internal_ints_size() const;
  public:
  void clear_ints();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_ints(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_ints() const;
  void _internal_add_ints(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_ints();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 ints(int index) const;
  void set_ints(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_ints(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      ints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_ints();

  // repeated bytes strings = 7;
  int strings_size() const;
  private:
  int _internal_strings_size() const;
  public:
  void clear_strings();
  const std::string& strings(int index) const;
  std::string* mutable_strings(int index);
  void set_strings(int index, const std::string& value);
  void set_strings(int index, std::string&& value);
  void set_strings(int index, const char* value);
  void set_strings(int index, const void* value, size_t size);
  std::string* add_strings();
  void add_strings(const std::string& value);
  void add_strings(std::string&& value);
  void add_strings(const char* value);
  void add_strings(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& strings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_strings();
  private:
  const std::string& _internal_strings(int index) const;
  std::string* _internal_add_strings();
  public:

  // repeated .caffe2.NetDef nets = 9;
  int nets_size() const;
  private:
  int _internal_nets_size() const;
  public:
  void clear_nets();
  ::caffe2::NetDef* mutable_nets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >*
      mutable_nets();
  private:
  const ::caffe2::NetDef& _internal_nets(int index) const;
  ::caffe2::NetDef* _internal_add_nets();
  public:
  const ::caffe2::NetDef& nets(int index) const;
  ::caffe2::NetDef* add_nets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >&
      nets() const;

  // repeated .caffe2.TensorProto tensors = 11;
  int tensors_size() const;
  private:
  int _internal_tensors_size() const;
  public:
  void clear_tensors();
  ::caffe2::TensorProto* mutable_tensors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorProto >*
      mutable_tensors();
  private:
  const ::caffe2::TensorProto& _internal_tensors(int index) const;
  ::caffe2::TensorProto* _internal_add_tensors();
  public:
  const ::caffe2::TensorProto& tensors(int index) const;
  ::caffe2::TensorProto* add_tensors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorProto >&
      tensors() const;

  // repeated .caffe2.QTensorProto qtensors = 12;
  int qtensors_size() const;
  private:
  int _internal_qtensors_size() const;
  public:
  void clear_qtensors();
  ::caffe2::QTensorProto* mutable_qtensors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::QTensorProto >*
      mutable_qtensors();
  private:
  const ::caffe2::QTensorProto& _internal_qtensors(int index) const;
  ::caffe2::QTensorProto* _internal_add_qtensors();
  public:
  const ::caffe2::QTensorProto& qtensors(int index) const;
  ::caffe2::QTensorProto* add_qtensors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::QTensorProto >&
      qtensors() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional bytes s = 4;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const std::string& s() const;
  void set_s(const std::string& value);
  void set_s(std::string&& value);
  void set_s(const char* value);
  void set_s(const void* value, size_t size);
  std::string* mutable_s();
  std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // optional .caffe2.NetDef n = 8;
  bool has_n() const;
  private:
  bool _internal_has_n() const;
  public:
  void clear_n();
  const ::caffe2::NetDef& n() const;
  ::caffe2::NetDef* release_n();
  ::caffe2::NetDef* mutable_n();
  void set_allocated_n(::caffe2::NetDef* n);
  private:
  const ::caffe2::NetDef& _internal_n() const;
  ::caffe2::NetDef* _internal_mutable_n();
  public:

  // optional .caffe2.TensorProto t = 10;
  bool has_t() const;
  private:
  bool _internal_has_t() const;
  public:
  void clear_t();
  const ::caffe2::TensorProto& t() const;
  ::caffe2::TensorProto* release_t();
  ::caffe2::TensorProto* mutable_t();
  void set_allocated_t(::caffe2::TensorProto* t);
  private:
  const ::caffe2::TensorProto& _internal_t() const;
  ::caffe2::TensorProto* _internal_mutable_t();
  public:

  // optional int64 i = 3;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  ::PROTOBUF_NAMESPACE_ID::int64 i() const;
  void set_i(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_i() const;
  void _internal_set_i(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional float f = 2;
  bool has_f() const;
  private:
  bool _internal_has_f() const;
  public:
  void clear_f();
  float f() const;
  void set_f(float value);
  private:
  float _internal_f() const;
  void _internal_set_f(float value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.Argument)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > floats_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > ints_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> strings_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef > nets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorProto > tensors_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::QTensorProto > qtensors_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
  ::caffe2::NetDef* n_;
  ::caffe2::TensorProto* t_;
  ::PROTOBUF_NAMESPACE_ID::int64 i_;
  float f_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API DeviceOption :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.DeviceOption) */ {
 public:
  DeviceOption();
  virtual ~DeviceOption();

  DeviceOption(const DeviceOption& from);
  DeviceOption(DeviceOption&& from) noexcept
    : DeviceOption() {
    *this = ::std::move(from);
  }

  inline DeviceOption& operator=(const DeviceOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceOption& operator=(DeviceOption&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeviceOption& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceOption* internal_default_instance() {
    return reinterpret_cast<const DeviceOption*>(
               &_DeviceOption_default_instance_);
  }
  static int const kIndexInFileMessages =
    10;

  friend void swap(DeviceOption& a, DeviceOption& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceOption* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeviceOption* New() const final {
    return CreateMaybeMessage<DeviceOption>(nullptr);
  }

  DeviceOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeviceOption>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeviceOption& from);
  void MergeFrom(const DeviceOption& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceOption* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.DeviceOption";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtraInfoFieldNumber = 6,
    kNodeNameFieldNumber = 4,
    kDeviceTypeFieldNumber = 1,
    kDeviceIdFieldNumber = 2,
    kRandomSeedFieldNumber = 3,
    kNumaNodeIdFieldNumber = 5,
  };
  // repeated string extra_info = 6;
  int extra_info_size() const;
  private:
  int _internal_extra_info_size() const;
  public:
  void clear_extra_info();
  const std::string& extra_info(int index) const;
  std::string* mutable_extra_info(int index);
  void set_extra_info(int index, const std::string& value);
  void set_extra_info(int index, std::string&& value);
  void set_extra_info(int index, const char* value);
  void set_extra_info(int index, const char* value, size_t size);
  std::string* add_extra_info();
  void add_extra_info(const std::string& value);
  void add_extra_info(std::string&& value);
  void add_extra_info(const char* value);
  void add_extra_info(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& extra_info() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_extra_info();
  private:
  const std::string& _internal_extra_info(int index) const;
  std::string* _internal_add_extra_info();
  public:

  // optional string node_name = 4;
  bool has_node_name() const;
  private:
  bool _internal_has_node_name() const;
  public:
  void clear_node_name();
  const std::string& node_name() const;
  void set_node_name(const std::string& value);
  void set_node_name(std::string&& value);
  void set_node_name(const char* value);
  void set_node_name(const char* value, size_t size);
  std::string* mutable_node_name();
  std::string* release_node_name();
  void set_allocated_node_name(std::string* node_name);
  private:
  const std::string& _internal_node_name() const;
  void _internal_set_node_name(const std::string& value);
  std::string* _internal_mutable_node_name();
  public:

  // optional int32 device_type = 1 [default = 0];
  bool has_device_type() const;
  private:
  bool _internal_has_device_type() const;
  public:
  void clear_device_type();
  ::PROTOBUF_NAMESPACE_ID::int32 device_type() const;
  void set_device_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_device_type() const;
  void _internal_set_device_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 device_id = 2;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  ::PROTOBUF_NAMESPACE_ID::int32 device_id() const;
  void set_device_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_device_id() const;
  void _internal_set_device_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional uint32 random_seed = 3;
  bool has_random_seed() const;
  private:
  bool _internal_has_random_seed() const;
  public:
  void clear_random_seed();
  ::PROTOBUF_NAMESPACE_ID::uint32 random_seed() const;
  void set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_random_seed() const;
  void _internal_set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional int32 numa_node_id = 5;
  bool has_numa_node_id() const;
  private:
  bool _internal_has_numa_node_id() const;
  public:
  void clear_numa_node_id();
  ::PROTOBUF_NAMESPACE_ID::int32 numa_node_id() const;
  void set_numa_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_numa_node_id() const;
  void _internal_set_numa_node_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.DeviceOption)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> extra_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_name_;
  ::PROTOBUF_NAMESPACE_ID::int32 device_type_;
  ::PROTOBUF_NAMESPACE_ID::int32 device_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 random_seed_;
  ::PROTOBUF_NAMESPACE_ID::int32 numa_node_id_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API OperatorDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.OperatorDef) */ {
 public:
  OperatorDef();
  virtual ~OperatorDef();

  OperatorDef(const OperatorDef& from);
  OperatorDef(OperatorDef&& from) noexcept
    : OperatorDef() {
    *this = ::std::move(from);
  }

  inline OperatorDef& operator=(const OperatorDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline OperatorDef& operator=(OperatorDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OperatorDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OperatorDef* internal_default_instance() {
    return reinterpret_cast<const OperatorDef*>(
               &_OperatorDef_default_instance_);
  }
  static int const kIndexInFileMessages =
    11;

  friend void swap(OperatorDef& a, OperatorDef& b) {
    a.Swap(&b);
  }
  inline void Swap(OperatorDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OperatorDef* New() const final {
    return CreateMaybeMessage<OperatorDef>(nullptr);
  }

  OperatorDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OperatorDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OperatorDef& from);
  void MergeFrom(const OperatorDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OperatorDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.OperatorDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputFieldNumber = 1,
    kOutputFieldNumber = 2,
    kArgFieldNumber = 5,
    kControlInputFieldNumber = 8,
    kNameFieldNumber = 3,
    kTypeFieldNumber = 4,
    kEngineFieldNumber = 7,
    kDebugInfoFieldNumber = 10,
    kDomainFieldNumber = 11,
    kDeviceOptionFieldNumber = 6,
    kOpVersionFieldNumber = 12,
    kIsGradientOpFieldNumber = 9,
  };
  // repeated string input = 1;
  int input_size() const;
  private:
  int _internal_input_size() const;
  public:
  void clear_input();
  const std::string& input(int index) const;
  std::string* mutable_input(int index);
  void set_input(int index, const std::string& value);
  void set_input(int index, std::string&& value);
  void set_input(int index, const char* value);
  void set_input(int index, const char* value, size_t size);
  std::string* add_input();
  void add_input(const std::string& value);
  void add_input(std::string&& value);
  void add_input(const char* value);
  void add_input(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& input() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_input();
  private:
  const std::string& _internal_input(int index) const;
  std::string* _internal_add_input();
  public:

  // repeated string output = 2;
  int output_size() const;
  private:
  int _internal_output_size() const;
  public:
  void clear_output();
  const std::string& output(int index) const;
  std::string* mutable_output(int index);
  void set_output(int index, const std::string& value);
  void set_output(int index, std::string&& value);
  void set_output(int index, const char* value);
  void set_output(int index, const char* value, size_t size);
  std::string* add_output();
  void add_output(const std::string& value);
  void add_output(std::string&& value);
  void add_output(const char* value);
  void add_output(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& output() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_output();
  private:
  const std::string& _internal_output(int index) const;
  std::string* _internal_add_output();
  public:

  // repeated .caffe2.Argument arg = 5;
  int arg_size() const;
  private:
  int _internal_arg_size() const;
  public:
  void clear_arg();
  ::caffe2::Argument* mutable_arg(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::Argument >*
      mutable_arg();
  private:
  const ::caffe2::Argument& _internal_arg(int index) const;
  ::caffe2::Argument* _internal_add_arg();
  public:
  const ::caffe2::Argument& arg(int index) const;
  ::caffe2::Argument* add_arg();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::Argument >&
      arg() const;

  // repeated string control_input = 8;
  int control_input_size() const;
  private:
  int _internal_control_input_size() const;
  public:
  void clear_control_input();
  const std::string& control_input(int index) const;
  std::string* mutable_control_input(int index);
  void set_control_input(int index, const std::string& value);
  void set_control_input(int index, std::string&& value);
  void set_control_input(int index, const char* value);
  void set_control_input(int index, const char* value, size_t size);
  std::string* add_control_input();
  void add_control_input(const std::string& value);
  void add_control_input(std::string&& value);
  void add_control_input(const char* value);
  void add_control_input(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& control_input() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_control_input();
  private:
  const std::string& _internal_control_input(int index) const;
  std::string* _internal_add_control_input();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string type = 4;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string engine = 7;
  bool has_engine() const;
  private:
  bool _internal_has_engine() const;
  public:
  void clear_engine();
  const std::string& engine() const;
  void set_engine(const std::string& value);
  void set_engine(std::string&& value);
  void set_engine(const char* value);
  void set_engine(const char* value, size_t size);
  std::string* mutable_engine();
  std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // optional string debug_info = 10;
  bool has_debug_info() const;
  private:
  bool _internal_has_debug_info() const;
  public:
  void clear_debug_info();
  const std::string& debug_info() const;
  void set_debug_info(const std::string& value);
  void set_debug_info(std::string&& value);
  void set_debug_info(const char* value);
  void set_debug_info(const char* value, size_t size);
  std::string* mutable_debug_info();
  std::string* release_debug_info();
  void set_allocated_debug_info(std::string* debug_info);
  private:
  const std::string& _internal_debug_info() const;
  void _internal_set_debug_info(const std::string& value);
  std::string* _internal_mutable_debug_info();
  public:

  // optional string domain = 11;
  bool has_domain() const;
  private:
  bool _internal_has_domain() const;
  public:
  void clear_domain();
  const std::string& domain() const;
  void set_domain(const std::string& value);
  void set_domain(std::string&& value);
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  std::string* mutable_domain();
  std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // optional .caffe2.DeviceOption device_option = 6;
  bool has_device_option() const;
  private:
  bool _internal_has_device_option() const;
  public:
  void clear_device_option();
  const ::caffe2::DeviceOption& device_option() const;
  ::caffe2::DeviceOption* release_device_option();
  ::caffe2::DeviceOption* mutable_device_option();
  void set_allocated_device_option(::caffe2::DeviceOption* device_option);
  private:
  const ::caffe2::DeviceOption& _internal_device_option() const;
  ::caffe2::DeviceOption* _internal_mutable_device_option();
  public:

  // optional int64 op_version = 12;
  bool has_op_version() const;
  private:
  bool _internal_has_op_version() const;
  public:
  void clear_op_version();
  ::PROTOBUF_NAMESPACE_ID::int64 op_version() const;
  void set_op_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_op_version() const;
  void _internal_set_op_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_gradient_op = 9 [default = false];
  bool has_is_gradient_op() const;
  private:
  bool _internal_has_is_gradient_op() const;
  public:
  void clear_is_gradient_op();
  bool is_gradient_op() const;
  void set_is_gradient_op(bool value);
  private:
  bool _internal_is_gradient_op() const;
  void _internal_set_is_gradient_op(bool value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.OperatorDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> input_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> output_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::Argument > arg_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> control_input_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::caffe2::DeviceOption* device_option_;
  ::PROTOBUF_NAMESPACE_ID::int64 op_version_;
  bool is_gradient_op_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API MapFieldEntry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.MapFieldEntry) */ {
 public:
  MapFieldEntry();
  virtual ~MapFieldEntry();

  MapFieldEntry(const MapFieldEntry& from);
  MapFieldEntry(MapFieldEntry&& from) noexcept
    : MapFieldEntry() {
    *this = ::std::move(from);
  }

  inline MapFieldEntry& operator=(const MapFieldEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapFieldEntry& operator=(MapFieldEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MapFieldEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapFieldEntry* internal_default_instance() {
    return reinterpret_cast<const MapFieldEntry*>(
               &_MapFieldEntry_default_instance_);
  }
  static int const kIndexInFileMessages =
    12;

  friend void swap(MapFieldEntry& a, MapFieldEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(MapFieldEntry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MapFieldEntry* New() const final {
    return CreateMaybeMessage<MapFieldEntry>(nullptr);
  }

  MapFieldEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MapFieldEntry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MapFieldEntry& from);
  void MergeFrom(const MapFieldEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapFieldEntry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.MapFieldEntry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValFieldNumber = 2,
  };
  // required string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required string val = 2;
  bool has_val() const;
  private:
  bool _internal_has_val() const;
  public:
  void clear_val();
  const std::string& val() const;
  void set_val(const std::string& value);
  void set_val(std::string&& value);
  void set_val(const char* value);
  void set_val(const char* value, size_t size);
  std::string* mutable_val();
  std::string* release_val();
  void set_allocated_val(std::string* val);
  private:
  const std::string& _internal_val() const;
  void _internal_set_val(const std::string& value);
  std::string* _internal_mutable_val();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.MapFieldEntry)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr val_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API BackendOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.BackendOptions) */ {
 public:
  BackendOptions();
  virtual ~BackendOptions();

  BackendOptions(const BackendOptions& from);
  BackendOptions(BackendOptions&& from) noexcept
    : BackendOptions() {
    *this = ::std::move(from);
  }

  inline BackendOptions& operator=(const BackendOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline BackendOptions& operator=(BackendOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BackendOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BackendOptions* internal_default_instance() {
    return reinterpret_cast<const BackendOptions*>(
               &_BackendOptions_default_instance_);
  }
  static int const kIndexInFileMessages =
    13;

  friend void swap(BackendOptions& a, BackendOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(BackendOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BackendOptions* New() const final {
    return CreateMaybeMessage<BackendOptions>(nullptr);
  }

  BackendOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BackendOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BackendOptions& from);
  void MergeFrom(const BackendOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BackendOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.BackendOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionFieldNumber = 2,
    kBackendNameFieldNumber = 1,
  };
  // repeated .caffe2.MapFieldEntry option = 2;
  int option_size() const;
  private:
  int _internal_option_size() const;
  public:
  void clear_option();
  ::caffe2::MapFieldEntry* mutable_option(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::MapFieldEntry >*
      mutable_option();
  private:
  const ::caffe2::MapFieldEntry& _internal_option(int index) const;
  ::caffe2::MapFieldEntry* _internal_add_option();
  public:
  const ::caffe2::MapFieldEntry& option(int index) const;
  ::caffe2::MapFieldEntry* add_option();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::MapFieldEntry >&
      option() const;

  // required string backend_name = 1;
  bool has_backend_name() const;
  private:
  bool _internal_has_backend_name() const;
  public:
  void clear_backend_name();
  const std::string& backend_name() const;
  void set_backend_name(const std::string& value);
  void set_backend_name(std::string&& value);
  void set_backend_name(const char* value);
  void set_backend_name(const char* value, size_t size);
  std::string* mutable_backend_name();
  std::string* release_backend_name();
  void set_allocated_backend_name(std::string* backend_name);
  private:
  const std::string& _internal_backend_name() const;
  void _internal_set_backend_name(const std::string& value);
  std::string* _internal_mutable_backend_name();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.BackendOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::MapFieldEntry > option_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backend_name_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API PartitionInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.PartitionInfo) */ {
 public:
  PartitionInfo();
  virtual ~PartitionInfo();

  PartitionInfo(const PartitionInfo& from);
  PartitionInfo(PartitionInfo&& from) noexcept
    : PartitionInfo() {
    *this = ::std::move(from);
  }

  inline PartitionInfo& operator=(const PartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PartitionInfo& operator=(PartitionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PartitionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionInfo* internal_default_instance() {
    return reinterpret_cast<const PartitionInfo*>(
               &_PartitionInfo_default_instance_);
  }
  static int const kIndexInFileMessages =
    14;

  friend void swap(PartitionInfo& a, PartitionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PartitionInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PartitionInfo* New() const final {
    return CreateMaybeMessage<PartitionInfo>(nullptr);
  }

  PartitionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PartitionInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PartitionInfo& from);
  void MergeFrom(const PartitionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.PartitionInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 2,
    kBackendOptionsFieldNumber = 4,
    kNameFieldNumber = 1,
    kExtraInfoFieldNumber = 3,
  };
  // repeated int32 device_id = 2;
  int device_id_size() const;
  private:
  int _internal_device_id_size() const;
  public:
  void clear_device_id();
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_device_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      _internal_device_id() const;
  void _internal_add_device_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      _internal_mutable_device_id();
  public:
  ::PROTOBUF_NAMESPACE_ID::int32 device_id(int index) const;
  void set_device_id(int index, ::PROTOBUF_NAMESPACE_ID::int32 value);
  void add_device_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
      device_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
      mutable_device_id();

  // repeated .caffe2.BackendOptions backend_options = 4;
  int backend_options_size() const;
  private:
  int _internal_backend_options_size() const;
  public:
  void clear_backend_options();
  ::caffe2::BackendOptions* mutable_backend_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::BackendOptions >*
      mutable_backend_options();
  private:
  const ::caffe2::BackendOptions& _internal_backend_options(int index) const;
  ::caffe2::BackendOptions* _internal_add_backend_options();
  public:
  const ::caffe2::BackendOptions& backend_options(int index) const;
  ::caffe2::BackendOptions* add_backend_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::BackendOptions >&
      backend_options() const;

  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string extra_info = 3;
  bool has_extra_info() const;
  private:
  bool _internal_has_extra_info() const;
  public:
  void clear_extra_info();
  const std::string& extra_info() const;
  void set_extra_info(const std::string& value);
  void set_extra_info(std::string&& value);
  void set_extra_info(const char* value);
  void set_extra_info(const char* value, size_t size);
  std::string* mutable_extra_info();
  std::string* release_extra_info();
  void set_allocated_extra_info(std::string* extra_info);
  private:
  const std::string& _internal_extra_info() const;
  void _internal_set_extra_info(const std::string& value);
  std::string* _internal_mutable_extra_info();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.PartitionInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 > device_id_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::BackendOptions > backend_options_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_info_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API NetDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.NetDef) */ {
 public:
  NetDef();
  virtual ~NetDef();

  NetDef(const NetDef& from);
  NetDef(NetDef&& from) noexcept
    : NetDef() {
    *this = ::std::move(from);
  }

  inline NetDef& operator=(const NetDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline NetDef& operator=(NetDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NetDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetDef* internal_default_instance() {
    return reinterpret_cast<const NetDef*>(
               &_NetDef_default_instance_);
  }
  static int const kIndexInFileMessages =
    15;

  friend void swap(NetDef& a, NetDef& b) {
    a.Swap(&b);
  }
  inline void Swap(NetDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NetDef* New() const final {
    return CreateMaybeMessage<NetDef>(nullptr);
  }

  NetDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NetDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NetDef& from);
  void MergeFrom(const NetDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NetDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.NetDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpFieldNumber = 2,
    kArgFieldNumber = 6,
    kExternalInputFieldNumber = 7,
    kExternalOutputFieldNumber = 8,
    kPartitionInfoFieldNumber = 9,
    kNameFieldNumber = 1,
    kTypeFieldNumber = 3,
    kDeviceOptionFieldNumber = 5,
    kNumWorkersFieldNumber = 4,
  };
  // repeated .caffe2.OperatorDef op = 2;
  int op_size() const;
  private:
  int _internal_op_size() const;
  public:
  void clear_op();
  ::caffe2::OperatorDef* mutable_op(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::OperatorDef >*
      mutable_op();
  private:
  const ::caffe2::OperatorDef& _internal_op(int index) const;
  ::caffe2::OperatorDef* _internal_add_op();
  public:
  const ::caffe2::OperatorDef& op(int index) const;
  ::caffe2::OperatorDef* add_op();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::OperatorDef >&
      op() const;

  // repeated .caffe2.Argument arg = 6;
  int arg_size() const;
  private:
  int _internal_arg_size() const;
  public:
  void clear_arg();
  ::caffe2::Argument* mutable_arg(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::Argument >*
      mutable_arg();
  private:
  const ::caffe2::Argument& _internal_arg(int index) const;
  ::caffe2::Argument* _internal_add_arg();
  public:
  const ::caffe2::Argument& arg(int index) const;
  ::caffe2::Argument* add_arg();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::Argument >&
      arg() const;

  // repeated string external_input = 7;
  int external_input_size() const;
  private:
  int _internal_external_input_size() const;
  public:
  void clear_external_input();
  const std::string& external_input(int index) const;
  std::string* mutable_external_input(int index);
  void set_external_input(int index, const std::string& value);
  void set_external_input(int index, std::string&& value);
  void set_external_input(int index, const char* value);
  void set_external_input(int index, const char* value, size_t size);
  std::string* add_external_input();
  void add_external_input(const std::string& value);
  void add_external_input(std::string&& value);
  void add_external_input(const char* value);
  void add_external_input(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& external_input() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_external_input();
  private:
  const std::string& _internal_external_input(int index) const;
  std::string* _internal_add_external_input();
  public:

  // repeated string external_output = 8;
  int external_output_size() const;
  private:
  int _internal_external_output_size() const;
  public:
  void clear_external_output();
  const std::string& external_output(int index) const;
  std::string* mutable_external_output(int index);
  void set_external_output(int index, const std::string& value);
  void set_external_output(int index, std::string&& value);
  void set_external_output(int index, const char* value);
  void set_external_output(int index, const char* value, size_t size);
  std::string* add_external_output();
  void add_external_output(const std::string& value);
  void add_external_output(std::string&& value);
  void add_external_output(const char* value);
  void add_external_output(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& external_output() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_external_output();
  private:
  const std::string& _internal_external_output(int index) const;
  std::string* _internal_add_external_output();
  public:

  // repeated .caffe2.PartitionInfo partition_info = 9;
  int partition_info_size() const;
  private:
  int _internal_partition_info_size() const;
  public:
  void clear_partition_info();
  ::caffe2::PartitionInfo* mutable_partition_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::PartitionInfo >*
      mutable_partition_info();
  private:
  const ::caffe2::PartitionInfo& _internal_partition_info(int index) const;
  ::caffe2::PartitionInfo* _internal_add_partition_info();
  public:
  const ::caffe2::PartitionInfo& partition_info(int index) const;
  ::caffe2::PartitionInfo* add_partition_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::PartitionInfo >&
      partition_info() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional .caffe2.DeviceOption device_option = 5;
  bool has_device_option() const;
  private:
  bool _internal_has_device_option() const;
  public:
  void clear_device_option();
  const ::caffe2::DeviceOption& device_option() const;
  ::caffe2::DeviceOption* release_device_option();
  ::caffe2::DeviceOption* mutable_device_option();
  void set_allocated_device_option(::caffe2::DeviceOption* device_option);
  private:
  const ::caffe2::DeviceOption& _internal_device_option() const;
  ::caffe2::DeviceOption* _internal_mutable_device_option();
  public:

  // optional int32 num_workers = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_num_workers() const;
  private:
  bool _internal_has_num_workers() const;
  public:
  PROTOBUF_DEPRECATED void clear_num_workers();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 num_workers() const;
  PROTOBUF_DEPRECATED void set_num_workers(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_workers() const;
  void _internal_set_num_workers(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.NetDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::OperatorDef > op_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::Argument > arg_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> external_input_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> external_output_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::PartitionInfo > partition_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::caffe2::DeviceOption* device_option_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_workers_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API ExecutionStep :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.ExecutionStep) */ {
 public:
  ExecutionStep();
  virtual ~ExecutionStep();

  ExecutionStep(const ExecutionStep& from);
  ExecutionStep(ExecutionStep&& from) noexcept
    : ExecutionStep() {
    *this = ::std::move(from);
  }

  inline ExecutionStep& operator=(const ExecutionStep& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionStep& operator=(ExecutionStep&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ExecutionStep& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecutionStep* internal_default_instance() {
    return reinterpret_cast<const ExecutionStep*>(
               &_ExecutionStep_default_instance_);
  }
  static int const kIndexInFileMessages =
    16;

  friend void swap(ExecutionStep& a, ExecutionStep& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionStep* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecutionStep* New() const final {
    return CreateMaybeMessage<ExecutionStep>(nullptr);
  }

  ExecutionStep* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecutionStep>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ExecutionStep& from);
  void MergeFrom(const ExecutionStep& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionStep* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.ExecutionStep";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubstepFieldNumber = 2,
    kNetworkFieldNumber = 3,
    kNameFieldNumber = 1,
    kCriteriaNetworkFieldNumber = 5,
    kReportNetFieldNumber = 7,
    kShouldStopBlobFieldNumber = 9,
    kNumIterFieldNumber = 4,
    kReportIntervalFieldNumber = 8,
    kConcurrentSubstepsFieldNumber = 6,
    kOnlyOnceFieldNumber = 10,
    kCreateWorkspaceFieldNumber = 12,
    kRunEveryMsFieldNumber = 11,
    kNumConcurrentInstancesFieldNumber = 13,
  };
  // repeated .caffe2.ExecutionStep substep = 2;
  int substep_size() const;
  private:
  int _internal_substep_size() const;
  public:
  void clear_substep();
  ::caffe2::ExecutionStep* mutable_substep(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::ExecutionStep >*
      mutable_substep();
  private:
  const ::caffe2::ExecutionStep& _internal_substep(int index) const;
  ::caffe2::ExecutionStep* _internal_add_substep();
  public:
  const ::caffe2::ExecutionStep& substep(int index) const;
  ::caffe2::ExecutionStep* add_substep();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::ExecutionStep >&
      substep() const;

  // repeated string network = 3;
  int network_size() const;
  private:
  int _internal_network_size() const;
  public:
  void clear_network();
  const std::string& network(int index) const;
  std::string* mutable_network(int index);
  void set_network(int index, const std::string& value);
  void set_network(int index, std::string&& value);
  void set_network(int index, const char* value);
  void set_network(int index, const char* value, size_t size);
  std::string* add_network();
  void add_network(const std::string& value);
  void add_network(std::string&& value);
  void add_network(const char* value);
  void add_network(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& network() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_network();
  private:
  const std::string& _internal_network(int index) const;
  std::string* _internal_add_network();
  public:

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string criteria_network = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_criteria_network() const;
  private:
  bool _internal_has_criteria_network() const;
  public:
  PROTOBUF_DEPRECATED void clear_criteria_network();
  PROTOBUF_DEPRECATED const std::string& criteria_network() const;
  PROTOBUF_DEPRECATED void set_criteria_network(const std::string& value);
  PROTOBUF_DEPRECATED void set_criteria_network(std::string&& value);
  PROTOBUF_DEPRECATED void set_criteria_network(const char* value);
  PROTOBUF_DEPRECATED void set_criteria_network(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_criteria_network();
  PROTOBUF_DEPRECATED std::string* release_criteria_network();
  PROTOBUF_DEPRECATED void set_allocated_criteria_network(std::string* criteria_network);
  private:
  const std::string& _internal_criteria_network() const;
  void _internal_set_criteria_network(const std::string& value);
  std::string* _internal_mutable_criteria_network();
  public:

  // optional string report_net = 7;
  bool has_report_net() const;
  private:
  bool _internal_has_report_net() const;
  public:
  void clear_report_net();
  const std::string& report_net() const;
  void set_report_net(const std::string& value);
  void set_report_net(std::string&& value);
  void set_report_net(const char* value);
  void set_report_net(const char* value, size_t size);
  std::string* mutable_report_net();
  std::string* release_report_net();
  void set_allocated_report_net(std::string* report_net);
  private:
  const std::string& _internal_report_net() const;
  void _internal_set_report_net(const std::string& value);
  std::string* _internal_mutable_report_net();
  public:

  // optional string should_stop_blob = 9;
  bool has_should_stop_blob() const;
  private:
  bool _internal_has_should_stop_blob() const;
  public:
  void clear_should_stop_blob();
  const std::string& should_stop_blob() const;
  void set_should_stop_blob(const std::string& value);
  void set_should_stop_blob(std::string&& value);
  void set_should_stop_blob(const char* value);
  void set_should_stop_blob(const char* value, size_t size);
  std::string* mutable_should_stop_blob();
  std::string* release_should_stop_blob();
  void set_allocated_should_stop_blob(std::string* should_stop_blob);
  private:
  const std::string& _internal_should_stop_blob() const;
  void _internal_set_should_stop_blob(const std::string& value);
  std::string* _internal_mutable_should_stop_blob();
  public:

  // optional int64 num_iter = 4;
  bool has_num_iter() const;
  private:
  bool _internal_has_num_iter() const;
  public:
  void clear_num_iter();
  ::PROTOBUF_NAMESPACE_ID::int64 num_iter() const;
  void set_num_iter(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_iter() const;
  void _internal_set_num_iter(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 report_interval = 8;
  bool has_report_interval() const;
  private:
  bool _internal_has_report_interval() const;
  public:
  void clear_report_interval();
  ::PROTOBUF_NAMESPACE_ID::int32 report_interval() const;
  void set_report_interval(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_report_interval() const;
  void _internal_set_report_interval(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool concurrent_substeps = 6;
  bool has_concurrent_substeps() const;
  private:
  bool _internal_has_concurrent_substeps() const;
  public:
  void clear_concurrent_substeps();
  bool concurrent_substeps() const;
  void set_concurrent_substeps(bool value);
  private:
  bool _internal_concurrent_substeps() const;
  void _internal_set_concurrent_substeps(bool value);
  public:

  // optional bool only_once = 10;
  bool has_only_once() const;
  private:
  bool _internal_has_only_once() const;
  public:
  void clear_only_once();
  bool only_once() const;
  void set_only_once(bool value);
  private:
  bool _internal_only_once() const;
  void _internal_set_only_once(bool value);
  public:

  // optional bool create_workspace = 12;
  bool has_create_workspace() const;
  private:
  bool _internal_has_create_workspace() const;
  public:
  void clear_create_workspace();
  bool create_workspace() const;
  void set_create_workspace(bool value);
  private:
  bool _internal_create_workspace() const;
  void _internal_set_create_workspace(bool value);
  public:

  // optional int64 run_every_ms = 11;
  bool has_run_every_ms() const;
  private:
  bool _internal_has_run_every_ms() const;
  public:
  void clear_run_every_ms();
  ::PROTOBUF_NAMESPACE_ID::int64 run_every_ms() const;
  void set_run_every_ms(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_run_every_ms() const;
  void _internal_set_run_every_ms(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 num_concurrent_instances = 13;
  bool has_num_concurrent_instances() const;
  private:
  bool _internal_has_num_concurrent_instances() const;
  public:
  void clear_num_concurrent_instances();
  ::PROTOBUF_NAMESPACE_ID::int32 num_concurrent_instances() const;
  void set_num_concurrent_instances(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_num_concurrent_instances() const;
  void _internal_set_num_concurrent_instances(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.ExecutionStep)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::ExecutionStep > substep_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr criteria_network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr report_net_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr should_stop_blob_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_iter_;
  ::PROTOBUF_NAMESPACE_ID::int32 report_interval_;
  bool concurrent_substeps_;
  bool only_once_;
  bool create_workspace_;
  ::PROTOBUF_NAMESPACE_ID::int64 run_every_ms_;
  ::PROTOBUF_NAMESPACE_ID::int32 num_concurrent_instances_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API PlanDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.PlanDef) */ {
 public:
  PlanDef();
  virtual ~PlanDef();

  PlanDef(const PlanDef& from);
  PlanDef(PlanDef&& from) noexcept
    : PlanDef() {
    *this = ::std::move(from);
  }

  inline PlanDef& operator=(const PlanDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanDef& operator=(PlanDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PlanDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanDef* internal_default_instance() {
    return reinterpret_cast<const PlanDef*>(
               &_PlanDef_default_instance_);
  }
  static int const kIndexInFileMessages =
    17;

  friend void swap(PlanDef& a, PlanDef& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PlanDef* New() const final {
    return CreateMaybeMessage<PlanDef>(nullptr);
  }

  PlanDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PlanDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PlanDef& from);
  void MergeFrom(const PlanDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.PlanDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkFieldNumber = 2,
    kExecutionStepFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // repeated .caffe2.NetDef network = 2;
  int network_size() const;
  private:
  int _internal_network_size() const;
  public:
  void clear_network();
  ::caffe2::NetDef* mutable_network(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >*
      mutable_network();
  private:
  const ::caffe2::NetDef& _internal_network(int index) const;
  ::caffe2::NetDef* _internal_add_network();
  public:
  const ::caffe2::NetDef& network(int index) const;
  ::caffe2::NetDef* add_network();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >&
      network() const;

  // repeated .caffe2.ExecutionStep execution_step = 3;
  int execution_step_size() const;
  private:
  int _internal_execution_step_size() const;
  public:
  void clear_execution_step();
  ::caffe2::ExecutionStep* mutable_execution_step(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::ExecutionStep >*
      mutable_execution_step();
  private:
  const ::caffe2::ExecutionStep& _internal_execution_step(int index) const;
  ::caffe2::ExecutionStep* _internal_add_execution_step();
  public:
  const ::caffe2::ExecutionStep& execution_step(int index) const;
  ::caffe2::ExecutionStep* add_execution_step();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::ExecutionStep >&
      execution_step() const;

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.PlanDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef > network_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::ExecutionStep > execution_step_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API BlobProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.BlobProto) */ {
 public:
  BlobProto();
  virtual ~BlobProto();

  BlobProto(const BlobProto& from);
  BlobProto(BlobProto&& from) noexcept
    : BlobProto() {
    *this = ::std::move(from);
  }

  inline BlobProto& operator=(const BlobProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlobProto& operator=(BlobProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BlobProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BlobProto* internal_default_instance() {
    return reinterpret_cast<const BlobProto*>(
               &_BlobProto_default_instance_);
  }
  static int const kIndexInFileMessages =
    18;

  friend void swap(BlobProto& a, BlobProto& b) {
    a.Swap(&b);
  }
  inline void Swap(BlobProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlobProto* New() const final {
    return CreateMaybeMessage<BlobProto>(nullptr);
  }

  BlobProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlobProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BlobProto& from);
  void MergeFrom(const BlobProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlobProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.BlobProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kContentFieldNumber = 4,
    kTensorFieldNumber = 3,
    kQtensorFieldNumber = 5,
    kContentNumChunksFieldNumber = 6,
    kContentChunkIdFieldNumber = 7,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional bytes content = 4;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const std::string& content() const;
  void set_content(const std::string& value);
  void set_content(std::string&& value);
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  std::string* mutable_content();
  std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // optional .caffe2.TensorProto tensor = 3;
  bool has_tensor() const;
  private:
  bool _internal_has_tensor() const;
  public:
  void clear_tensor();
  const ::caffe2::TensorProto& tensor() const;
  ::caffe2::TensorProto* release_tensor();
  ::caffe2::TensorProto* mutable_tensor();
  void set_allocated_tensor(::caffe2::TensorProto* tensor);
  private:
  const ::caffe2::TensorProto& _internal_tensor() const;
  ::caffe2::TensorProto* _internal_mutable_tensor();
  public:

  // optional .caffe2.QTensorProto qtensor = 5;
  bool has_qtensor() const;
  private:
  bool _internal_has_qtensor() const;
  public:
  void clear_qtensor();
  const ::caffe2::QTensorProto& qtensor() const;
  ::caffe2::QTensorProto* release_qtensor();
  ::caffe2::QTensorProto* mutable_qtensor();
  void set_allocated_qtensor(::caffe2::QTensorProto* qtensor);
  private:
  const ::caffe2::QTensorProto& _internal_qtensor() const;
  ::caffe2::QTensorProto* _internal_mutable_qtensor();
  public:

  // optional int32 content_num_chunks = 6;
  bool has_content_num_chunks() const;
  private:
  bool _internal_has_content_num_chunks() const;
  public:
  void clear_content_num_chunks();
  ::PROTOBUF_NAMESPACE_ID::int32 content_num_chunks() const;
  void set_content_num_chunks(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_content_num_chunks() const;
  void _internal_set_content_num_chunks(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 content_chunk_id = 7;
  bool has_content_chunk_id() const;
  private:
  bool _internal_has_content_chunk_id() const;
  public:
  void clear_content_chunk_id();
  ::PROTOBUF_NAMESPACE_ID::int32 content_chunk_id() const;
  void set_content_chunk_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_content_chunk_id() const;
  void _internal_set_content_chunk_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:caffe2.BlobProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
  ::caffe2::TensorProto* tensor_;
  ::caffe2::QTensorProto* qtensor_;
  ::PROTOBUF_NAMESPACE_ID::int32 content_num_chunks_;
  ::PROTOBUF_NAMESPACE_ID::int32 content_chunk_id_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API DBReaderProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:caffe2.DBReaderProto) */ {
 public:
  DBReaderProto();
  virtual ~DBReaderProto();

  DBReaderProto(const DBReaderProto& from);
  DBReaderProto(DBReaderProto&& from) noexcept
    : DBReaderProto() {
    *this = ::std::move(from);
  }

  inline DBReaderProto& operator=(const DBReaderProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DBReaderProto& operator=(DBReaderProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DBReaderProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DBReaderProto* internal_default_instance() {
    return reinterpret_cast<const DBReaderProto*>(
               &_DBReaderProto_default_instance_);
  }
  static int const kIndexInFileMessages =
    19;

  friend void swap(DBReaderProto& a, DBReaderProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DBReaderProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DBReaderProto* New() const final {
    return CreateMaybeMessage<DBReaderProto>(nullptr);
  }

  DBReaderProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DBReaderProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DBReaderProto& from);
  void MergeFrom(const DBReaderProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DBReaderProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "caffe2.DBReaderProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto);
    return ::descriptor_table_caffe2_2fproto_2fcaffe2_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSourceFieldNumber = 2,
    kDbTypeFieldNumber = 3,
    kKeyFieldNumber = 4,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string source = 2;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const std::string& source() const;
  void set_source(const std::string& value);
  void set_source(std::string&& value);
  void set_source(const char* value);
  void set_source(const char* value, size_t size);
  std::string* mutable_source();
  std::string* release_source();
  void set_allocated_source(std::string* source);
  private:
  const std::string& _internal_source() const;
  void _internal_set_source(const std::string& value);
  std::string* _internal_mutable_source();
  public:

  // optional string db_type = 3;
  bool has_db_type() const;
  private:
  bool _internal_has_db_type() const;
  public:
  void clear_db_type();
  const std::string& db_type() const;
  void set_db_type(const std::string& value);
  void set_db_type(std::string&& value);
  void set_db_type(const char* value);
  void set_db_type(const char* value, size_t size);
  std::string* mutable_db_type();
  std::string* release_db_type();
  void set_allocated_db_type(std::string* db_type);
  private:
  const std::string& _internal_db_type() const;
  void _internal_set_db_type(const std::string& value);
  std::string* _internal_mutable_db_type();
  public:

  // optional string key = 4;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:caffe2.DBReaderProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr db_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_caffe2_2fproto_2fcaffe2_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ExternalDataProto

// optional .caffe2.ExternalDataProto.SourceType source_type = 1 [default = INLINE_CONTAINER];
inline bool ExternalDataProto::_internal_has_source_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExternalDataProto::has_source_type() const {
  return _internal_has_source_type();
}
inline void ExternalDataProto::clear_source_type() {
  source_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::caffe2::ExternalDataProto_SourceType ExternalDataProto::_internal_source_type() const {
  return static_cast< ::caffe2::ExternalDataProto_SourceType >(source_type_);
}
inline ::caffe2::ExternalDataProto_SourceType ExternalDataProto::source_type() const {
  // @@protoc_insertion_point(field_get:caffe2.ExternalDataProto.source_type)
  return _internal_source_type();
}
inline void ExternalDataProto::_internal_set_source_type(::caffe2::ExternalDataProto_SourceType value) {
  assert(::caffe2::ExternalDataProto_SourceType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  source_type_ = value;
}
inline void ExternalDataProto::set_source_type(::caffe2::ExternalDataProto_SourceType value) {
  _internal_set_source_type(value);
  // @@protoc_insertion_point(field_set:caffe2.ExternalDataProto.source_type)
}

// optional string record_id = 2;
inline bool ExternalDataProto::_internal_has_record_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExternalDataProto::has_record_id() const {
  return _internal_has_record_id();
}
inline void ExternalDataProto::clear_record_id() {
  record_id_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExternalDataProto::record_id() const {
  // @@protoc_insertion_point(field_get:caffe2.ExternalDataProto.record_id)
  return _internal_record_id();
}
inline void ExternalDataProto::set_record_id(const std::string& value) {
  _internal_set_record_id(value);
  // @@protoc_insertion_point(field_set:caffe2.ExternalDataProto.record_id)
}
inline std::string* ExternalDataProto::mutable_record_id() {
  // @@protoc_insertion_point(field_mutable:caffe2.ExternalDataProto.record_id)
  return _internal_mutable_record_id();
}
inline const std::string& ExternalDataProto::_internal_record_id() const {
  return record_id_.GetNoArena();
}
inline void ExternalDataProto::_internal_set_record_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  record_id_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ExternalDataProto::set_record_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  record_id_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ExternalDataProto.record_id)
}
inline void ExternalDataProto::set_record_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  record_id_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ExternalDataProto.record_id)
}
inline void ExternalDataProto::set_record_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  record_id_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExternalDataProto.record_id)
}
inline std::string* ExternalDataProto::_internal_mutable_record_id() {
  _has_bits_[0] |= 0x00000001u;
  return record_id_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ExternalDataProto::release_record_id() {
  // @@protoc_insertion_point(field_release:caffe2.ExternalDataProto.record_id)
  if (!_internal_has_record_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return record_id_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ExternalDataProto::set_allocated_record_id(std::string* record_id) {
  if (record_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  record_id_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), record_id);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ExternalDataProto.record_id)
}

// optional uint64 record_size = 5;
inline bool ExternalDataProto::_internal_has_record_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExternalDataProto::has_record_size() const {
  return _internal_has_record_size();
}
inline void ExternalDataProto::clear_record_size() {
  record_size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExternalDataProto::_internal_record_size() const {
  return record_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExternalDataProto::record_size() const {
  // @@protoc_insertion_point(field_get:caffe2.ExternalDataProto.record_size)
  return _internal_record_size();
}
inline void ExternalDataProto::_internal_set_record_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  record_size_ = value;
}
inline void ExternalDataProto::set_record_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_record_size(value);
  // @@protoc_insertion_point(field_set:caffe2.ExternalDataProto.record_size)
}

// optional int64 offset = 3 [default = 0];
inline bool ExternalDataProto::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExternalDataProto::has_offset() const {
  return _internal_has_offset();
}
inline void ExternalDataProto::clear_offset() {
  offset_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExternalDataProto::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExternalDataProto::offset() const {
  // @@protoc_insertion_point(field_get:caffe2.ExternalDataProto.offset)
  return _internal_offset();
}
inline void ExternalDataProto::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  offset_ = value;
}
inline void ExternalDataProto::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:caffe2.ExternalDataProto.offset)
}

// repeated int64 strides = 4;
inline int ExternalDataProto::_internal_strides_size() const {
  return strides_.size();
}
inline int ExternalDataProto::strides_size() const {
  return _internal_strides_size();
}
inline void ExternalDataProto::clear_strides() {
  strides_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExternalDataProto::_internal_strides(int index) const {
  return strides_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExternalDataProto::strides(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.ExternalDataProto.strides)
  return _internal_strides(index);
}
inline void ExternalDataProto::set_strides(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  strides_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.ExternalDataProto.strides)
}
inline void ExternalDataProto::_internal_add_strides(::PROTOBUF_NAMESPACE_ID::int64 value) {
  strides_.Add(value);
}
inline void ExternalDataProto::add_strides(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_strides(value);
  // @@protoc_insertion_point(field_add:caffe2.ExternalDataProto.strides)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ExternalDataProto::_internal_strides() const {
  return strides_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
ExternalDataProto::strides() const {
  // @@protoc_insertion_point(field_list:caffe2.ExternalDataProto.strides)
  return _internal_strides();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ExternalDataProto::_internal_mutable_strides() {
  return &strides_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
ExternalDataProto::mutable_strides() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.ExternalDataProto.strides)
  return _internal_mutable_strides();
}

// -------------------------------------------------------------------

// TensorProto_Segment

// required int64 begin = 1;
inline bool TensorProto_Segment::_internal_has_begin() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TensorProto_Segment::has_begin() const {
  return _internal_has_begin();
}
inline void TensorProto_Segment::clear_begin() {
  begin_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorProto_Segment::_internal_begin() const {
  return begin_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorProto_Segment::begin() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.Segment.begin)
  return _internal_begin();
}
inline void TensorProto_Segment::_internal_set_begin(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  begin_ = value;
}
inline void TensorProto_Segment::set_begin(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_begin(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.Segment.begin)
}

// required int64 end = 2;
inline bool TensorProto_Segment::_internal_has_end() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TensorProto_Segment::has_end() const {
  return _internal_has_end();
}
inline void TensorProto_Segment::clear_end() {
  end_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorProto_Segment::_internal_end() const {
  return end_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorProto_Segment::end() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.Segment.end)
  return _internal_end();
}
inline void TensorProto_Segment::_internal_set_end(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  end_ = value;
}
inline void TensorProto_Segment::set_end(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.Segment.end)
}

// -------------------------------------------------------------------

// TensorProto

// repeated int64 dims = 1;
inline int TensorProto::_internal_dims_size() const {
  return dims_.size();
}
inline int TensorProto::dims_size() const {
  return _internal_dims_size();
}
inline void TensorProto::clear_dims() {
  dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorProto::_internal_dims(int index) const {
  return dims_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorProto::dims(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.dims)
  return _internal_dims(index);
}
inline void TensorProto::set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.dims)
}
inline void TensorProto::_internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Add(value);
}
inline void TensorProto::add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TensorProto::_internal_dims() const {
  return dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TensorProto::dims() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TensorProto::_internal_mutable_dims() {
  return &dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TensorProto::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.dims)
  return _internal_mutable_dims();
}

// optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
inline bool TensorProto::_internal_has_data_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TensorProto::has_data_type() const {
  return _internal_has_data_type();
}
inline void TensorProto::clear_data_type() {
  data_type_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::caffe2::TensorProto_DataType TensorProto::_internal_data_type() const {
  return static_cast< ::caffe2::TensorProto_DataType >(data_type_);
}
inline ::caffe2::TensorProto_DataType TensorProto::data_type() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.data_type)
  return _internal_data_type();
}
inline void TensorProto::_internal_set_data_type(::caffe2::TensorProto_DataType value) {
  assert(::caffe2::TensorProto_DataType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  data_type_ = value;
}
inline void TensorProto::set_data_type(::caffe2::TensorProto_DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.data_type)
}

// optional .caffe2.TensorProto.StorageType storage_type = 12 [default = TYPED];
inline bool TensorProto::_internal_has_storage_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TensorProto::has_storage_type() const {
  return _internal_has_storage_type();
}
inline void TensorProto::clear_storage_type() {
  storage_type_ = 1;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::caffe2::TensorProto_StorageType TensorProto::_internal_storage_type() const {
  return static_cast< ::caffe2::TensorProto_StorageType >(storage_type_);
}
inline ::caffe2::TensorProto_StorageType TensorProto::storage_type() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.storage_type)
  return _internal_storage_type();
}
inline void TensorProto::_internal_set_storage_type(::caffe2::TensorProto_StorageType value) {
  assert(::caffe2::TensorProto_StorageType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  storage_type_ = value;
}
inline void TensorProto::set_storage_type(::caffe2::TensorProto_StorageType value) {
  _internal_set_storage_type(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.storage_type)
}

// repeated float float_data = 3 [packed = true];
inline int TensorProto::_internal_float_data_size() const {
  return float_data_.size();
}
inline int TensorProto::float_data_size() const {
  return _internal_float_data_size();
}
inline void TensorProto::clear_float_data() {
  float_data_.Clear();
}
inline float TensorProto::_internal_float_data(int index) const {
  return float_data_.Get(index);
}
inline float TensorProto::float_data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.float_data)
  return _internal_float_data(index);
}
inline void TensorProto::set_float_data(int index, float value) {
  float_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.float_data)
}
inline void TensorProto::_internal_add_float_data(float value) {
  float_data_.Add(value);
}
inline void TensorProto::add_float_data(float value) {
  _internal_add_float_data(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.float_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TensorProto::_internal_float_data() const {
  return float_data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
TensorProto::float_data() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.float_data)
  return _internal_float_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TensorProto::_internal_mutable_float_data() {
  return &float_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
TensorProto::mutable_float_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.float_data)
  return _internal_mutable_float_data();
}

// repeated int32 int32_data = 4 [packed = true];
inline int TensorProto::_internal_int32_data_size() const {
  return int32_data_.size();
}
inline int TensorProto::int32_data_size() const {
  return _internal_int32_data_size();
}
inline void TensorProto::clear_int32_data() {
  int32_data_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TensorProto::_internal_int32_data(int index) const {
  return int32_data_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TensorProto::int32_data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.int32_data)
  return _internal_int32_data(index);
}
inline void TensorProto::set_int32_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  int32_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.int32_data)
}
inline void TensorProto::_internal_add_int32_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  int32_data_.Add(value);
}
inline void TensorProto::add_int32_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_int32_data(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.int32_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TensorProto::_internal_int32_data() const {
  return int32_data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TensorProto::int32_data() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.int32_data)
  return _internal_int32_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TensorProto::_internal_mutable_int32_data() {
  return &int32_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TensorProto::mutable_int32_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.int32_data)
  return _internal_mutable_int32_data();
}

// optional bytes byte_data = 5;
inline bool TensorProto::_internal_has_byte_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TensorProto::has_byte_data() const {
  return _internal_has_byte_data();
}
inline void TensorProto::clear_byte_data() {
  byte_data_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TensorProto::byte_data() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.byte_data)
  return _internal_byte_data();
}
inline void TensorProto::set_byte_data(const std::string& value) {
  _internal_set_byte_data(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.byte_data)
}
inline std::string* TensorProto::mutable_byte_data() {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.byte_data)
  return _internal_mutable_byte_data();
}
inline const std::string& TensorProto::_internal_byte_data() const {
  return byte_data_.GetNoArena();
}
inline void TensorProto::_internal_set_byte_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  byte_data_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void TensorProto::set_byte_data(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  byte_data_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.TensorProto.byte_data)
}
inline void TensorProto::set_byte_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  byte_data_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.TensorProto.byte_data)
}
inline void TensorProto::set_byte_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  byte_data_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.TensorProto.byte_data)
}
inline std::string* TensorProto::_internal_mutable_byte_data() {
  _has_bits_[0] |= 0x00000001u;
  return byte_data_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* TensorProto::release_byte_data() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.byte_data)
  if (!_internal_has_byte_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return byte_data_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void TensorProto::set_allocated_byte_data(std::string* byte_data) {
  if (byte_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  byte_data_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), byte_data);
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.byte_data)
}

// repeated bytes string_data = 6;
inline int TensorProto::_internal_string_data_size() const {
  return string_data_.size();
}
inline int TensorProto::string_data_size() const {
  return _internal_string_data_size();
}
inline void TensorProto::clear_string_data() {
  string_data_.Clear();
}
inline std::string* TensorProto::add_string_data() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.TensorProto.string_data)
  return _internal_add_string_data();
}
inline const std::string& TensorProto::_internal_string_data(int index) const {
  return string_data_.Get(index);
}
inline const std::string& TensorProto::string_data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.string_data)
  return _internal_string_data(index);
}
inline std::string* TensorProto::mutable_string_data(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.string_data)
  return string_data_.Mutable(index);
}
inline void TensorProto::set_string_data(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.string_data)
  string_data_.Mutable(index)->assign(value);
}
inline void TensorProto::set_string_data(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.string_data)
  string_data_.Mutable(index)->assign(std::move(value));
}
inline void TensorProto::set_string_data(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  string_data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.TensorProto.string_data)
}
inline void TensorProto::set_string_data(int index, const void* value, size_t size) {
  string_data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.TensorProto.string_data)
}
inline std::string* TensorProto::_internal_add_string_data() {
  return string_data_.Add();
}
inline void TensorProto::add_string_data(const std::string& value) {
  string_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.string_data)
}
inline void TensorProto::add_string_data(std::string&& value) {
  string_data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.string_data)
}
inline void TensorProto::add_string_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  string_data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.TensorProto.string_data)
}
inline void TensorProto::add_string_data(const void* value, size_t size) {
  string_data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.TensorProto.string_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TensorProto::string_data() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.string_data)
  return string_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TensorProto::mutable_string_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.string_data)
  return &string_data_;
}

// repeated double double_data = 9 [packed = true];
inline int TensorProto::_internal_double_data_size() const {
  return double_data_.size();
}
inline int TensorProto::double_data_size() const {
  return _internal_double_data_size();
}
inline void TensorProto::clear_double_data() {
  double_data_.Clear();
}
inline double TensorProto::_internal_double_data(int index) const {
  return double_data_.Get(index);
}
inline double TensorProto::double_data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.double_data)
  return _internal_double_data(index);
}
inline void TensorProto::set_double_data(int index, double value) {
  double_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.double_data)
}
inline void TensorProto::_internal_add_double_data(double value) {
  double_data_.Add(value);
}
inline void TensorProto::add_double_data(double value) {
  _internal_add_double_data(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.double_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TensorProto::_internal_double_data() const {
  return double_data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
TensorProto::double_data() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.double_data)
  return _internal_double_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TensorProto::_internal_mutable_double_data() {
  return &double_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
TensorProto::mutable_double_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.double_data)
  return _internal_mutable_double_data();
}

// repeated int64 int64_data = 10 [packed = true];
inline int TensorProto::_internal_int64_data_size() const {
  return int64_data_.size();
}
inline int TensorProto::int64_data_size() const {
  return _internal_int64_data_size();
}
inline void TensorProto::clear_int64_data() {
  int64_data_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorProto::_internal_int64_data(int index) const {
  return int64_data_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorProto::int64_data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.int64_data)
  return _internal_int64_data(index);
}
inline void TensorProto::set_int64_data(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  int64_data_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.int64_data)
}
inline void TensorProto::_internal_add_int64_data(::PROTOBUF_NAMESPACE_ID::int64 value) {
  int64_data_.Add(value);
}
inline void TensorProto::add_int64_data(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_int64_data(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorProto.int64_data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TensorProto::_internal_int64_data() const {
  return int64_data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TensorProto::int64_data() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProto.int64_data)
  return _internal_int64_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TensorProto::_internal_mutable_int64_data() {
  return &int64_data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TensorProto::mutable_int64_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProto.int64_data)
  return _internal_mutable_int64_data();
}

// optional bytes raw_data = 13;
inline bool TensorProto::_internal_has_raw_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TensorProto::has_raw_data() const {
  return _internal_has_raw_data();
}
inline void TensorProto::clear_raw_data() {
  raw_data_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TensorProto::raw_data() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.raw_data)
  return _internal_raw_data();
}
inline void TensorProto::set_raw_data(const std::string& value) {
  _internal_set_raw_data(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.raw_data)
}
inline std::string* TensorProto::mutable_raw_data() {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.raw_data)
  return _internal_mutable_raw_data();
}
inline const std::string& TensorProto::_internal_raw_data() const {
  return raw_data_.GetNoArena();
}
inline void TensorProto::_internal_set_raw_data(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  raw_data_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void TensorProto::set_raw_data(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  raw_data_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.TensorProto.raw_data)
}
inline void TensorProto::set_raw_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  raw_data_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.TensorProto.raw_data)
}
inline void TensorProto::set_raw_data(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  raw_data_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.TensorProto.raw_data)
}
inline std::string* TensorProto::_internal_mutable_raw_data() {
  _has_bits_[0] |= 0x00000004u;
  return raw_data_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* TensorProto::release_raw_data() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.raw_data)
  if (!_internal_has_raw_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return raw_data_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void TensorProto::set_allocated_raw_data(std::string* raw_data) {
  if (raw_data != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  raw_data_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), raw_data);
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.raw_data)
}

// optional .caffe2.ExternalDataProto external_data = 14;
inline bool TensorProto::_internal_has_external_data() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || external_data_ != nullptr);
  return value;
}
inline bool TensorProto::has_external_data() const {
  return _internal_has_external_data();
}
inline void TensorProto::clear_external_data() {
  if (external_data_ != nullptr) external_data_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::caffe2::ExternalDataProto& TensorProto::_internal_external_data() const {
  const ::caffe2::ExternalDataProto* p = external_data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::ExternalDataProto*>(
      &::caffe2::_ExternalDataProto_default_instance_);
}
inline const ::caffe2::ExternalDataProto& TensorProto::external_data() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.external_data)
  return _internal_external_data();
}
inline ::caffe2::ExternalDataProto* TensorProto::release_external_data() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.external_data)
  _has_bits_[0] &= ~0x00000020u;
  ::caffe2::ExternalDataProto* temp = external_data_;
  external_data_ = nullptr;
  return temp;
}
inline ::caffe2::ExternalDataProto* TensorProto::_internal_mutable_external_data() {
  _has_bits_[0] |= 0x00000020u;
  if (external_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::ExternalDataProto>(GetArenaNoVirtual());
    external_data_ = p;
  }
  return external_data_;
}
inline ::caffe2::ExternalDataProto* TensorProto::mutable_external_data() {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.external_data)
  return _internal_mutable_external_data();
}
inline void TensorProto::set_allocated_external_data(::caffe2::ExternalDataProto* external_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete external_data_;
  }
  if (external_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      external_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, external_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  external_data_ = external_data;
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.external_data)
}

// optional string name = 7;
inline bool TensorProto::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TensorProto::has_name() const {
  return _internal_has_name();
}
inline void TensorProto::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TensorProto::name() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.name)
  return _internal_name();
}
inline void TensorProto::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorProto.name)
}
inline std::string* TensorProto::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.name)
  return _internal_mutable_name();
}
inline const std::string& TensorProto::_internal_name() const {
  return name_.GetNoArena();
}
inline void TensorProto::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void TensorProto::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.TensorProto.name)
}
inline void TensorProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.TensorProto.name)
}
inline void TensorProto::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.TensorProto.name)
}
inline std::string* TensorProto::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* TensorProto::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void TensorProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.name)
}

// optional .caffe2.DeviceOption device_detail = 8;
inline bool TensorProto::_internal_has_device_detail() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || device_detail_ != nullptr);
  return value;
}
inline bool TensorProto::has_device_detail() const {
  return _internal_has_device_detail();
}
inline void TensorProto::clear_device_detail() {
  if (device_detail_ != nullptr) device_detail_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::caffe2::DeviceOption& TensorProto::_internal_device_detail() const {
  const ::caffe2::DeviceOption* p = device_detail_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::DeviceOption*>(
      &::caffe2::_DeviceOption_default_instance_);
}
inline const ::caffe2::DeviceOption& TensorProto::device_detail() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.device_detail)
  return _internal_device_detail();
}
inline ::caffe2::DeviceOption* TensorProto::release_device_detail() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.device_detail)
  _has_bits_[0] &= ~0x00000008u;
  ::caffe2::DeviceOption* temp = device_detail_;
  device_detail_ = nullptr;
  return temp;
}
inline ::caffe2::DeviceOption* TensorProto::_internal_mutable_device_detail() {
  _has_bits_[0] |= 0x00000008u;
  if (device_detail_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::DeviceOption>(GetArenaNoVirtual());
    device_detail_ = p;
  }
  return device_detail_;
}
inline ::caffe2::DeviceOption* TensorProto::mutable_device_detail() {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.device_detail)
  return _internal_mutable_device_detail();
}
inline void TensorProto::set_allocated_device_detail(::caffe2::DeviceOption* device_detail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_detail_;
  }
  if (device_detail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_detail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_detail, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  device_detail_ = device_detail;
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.device_detail)
}

// optional .caffe2.TensorProto.Segment segment = 11;
inline bool TensorProto::_internal_has_segment() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || segment_ != nullptr);
  return value;
}
inline bool TensorProto::has_segment() const {
  return _internal_has_segment();
}
inline void TensorProto::clear_segment() {
  if (segment_ != nullptr) segment_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::caffe2::TensorProto_Segment& TensorProto::_internal_segment() const {
  const ::caffe2::TensorProto_Segment* p = segment_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::TensorProto_Segment*>(
      &::caffe2::_TensorProto_Segment_default_instance_);
}
inline const ::caffe2::TensorProto_Segment& TensorProto::segment() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProto.segment)
  return _internal_segment();
}
inline ::caffe2::TensorProto_Segment* TensorProto::release_segment() {
  // @@protoc_insertion_point(field_release:caffe2.TensorProto.segment)
  _has_bits_[0] &= ~0x00000010u;
  ::caffe2::TensorProto_Segment* temp = segment_;
  segment_ = nullptr;
  return temp;
}
inline ::caffe2::TensorProto_Segment* TensorProto::_internal_mutable_segment() {
  _has_bits_[0] |= 0x00000010u;
  if (segment_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::TensorProto_Segment>(GetArenaNoVirtual());
    segment_ = p;
  }
  return segment_;
}
inline ::caffe2::TensorProto_Segment* TensorProto::mutable_segment() {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProto.segment)
  return _internal_mutable_segment();
}
inline void TensorProto::set_allocated_segment(::caffe2::TensorProto_Segment* segment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete segment_;
  }
  if (segment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      segment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, segment, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  segment_ = segment;
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorProto.segment)
}

// -------------------------------------------------------------------

// QTensorProto

// repeated int64 dims = 1;
inline int QTensorProto::_internal_dims_size() const {
  return dims_.size();
}
inline int QTensorProto::dims_size() const {
  return _internal_dims_size();
}
inline void QTensorProto::clear_dims() {
  dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QTensorProto::_internal_dims(int index) const {
  return dims_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 QTensorProto::dims(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.dims)
  return _internal_dims(index);
}
inline void QTensorProto::set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.dims)
}
inline void QTensorProto::_internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Add(value);
}
inline void QTensorProto::add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:caffe2.QTensorProto.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
QTensorProto::_internal_dims() const {
  return dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
QTensorProto::dims() const {
  // @@protoc_insertion_point(field_list:caffe2.QTensorProto.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
QTensorProto::_internal_mutable_dims() {
  return &dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
QTensorProto::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.QTensorProto.dims)
  return _internal_mutable_dims();
}

// required int32 precision = 2;
inline bool QTensorProto::_internal_has_precision() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool QTensorProto::has_precision() const {
  return _internal_has_precision();
}
inline void QTensorProto::clear_precision() {
  precision_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 QTensorProto::_internal_precision() const {
  return precision_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 QTensorProto::precision() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.precision)
  return _internal_precision();
}
inline void QTensorProto::_internal_set_precision(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  precision_ = value;
}
inline void QTensorProto::set_precision(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.precision)
}

// required double scale = 3;
inline bool QTensorProto::_internal_has_scale() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool QTensorProto::has_scale() const {
  return _internal_has_scale();
}
inline void QTensorProto::clear_scale() {
  scale_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double QTensorProto::_internal_scale() const {
  return scale_;
}
inline double QTensorProto::scale() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.scale)
  return _internal_scale();
}
inline void QTensorProto::_internal_set_scale(double value) {
  _has_bits_[0] |= 0x00000002u;
  scale_ = value;
}
inline void QTensorProto::set_scale(double value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.scale)
}

// required double bias = 4;
inline bool QTensorProto::_internal_has_bias() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool QTensorProto::has_bias() const {
  return _internal_has_bias();
}
inline void QTensorProto::clear_bias() {
  bias_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double QTensorProto::_internal_bias() const {
  return bias_;
}
inline double QTensorProto::bias() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.bias)
  return _internal_bias();
}
inline void QTensorProto::_internal_set_bias(double value) {
  _has_bits_[0] |= 0x00000004u;
  bias_ = value;
}
inline void QTensorProto::set_bias(double value) {
  _internal_set_bias(value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.bias)
}

// required bool is_signed = 5;
inline bool QTensorProto::_internal_has_is_signed() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool QTensorProto::has_is_signed() const {
  return _internal_has_is_signed();
}
inline void QTensorProto::clear_is_signed() {
  is_signed_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool QTensorProto::_internal_is_signed() const {
  return is_signed_;
}
inline bool QTensorProto::is_signed() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.is_signed)
  return _internal_is_signed();
}
inline void QTensorProto::_internal_set_is_signed(bool value) {
  _has_bits_[0] |= 0x00000010u;
  is_signed_ = value;
}
inline void QTensorProto::set_is_signed(bool value) {
  _internal_set_is_signed(value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.is_signed)
}

// repeated int32 data = 6 [packed = true];
inline int QTensorProto::_internal_data_size() const {
  return data_.size();
}
inline int QTensorProto::data_size() const {
  return _internal_data_size();
}
inline void QTensorProto::clear_data() {
  data_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 QTensorProto::_internal_data(int index) const {
  return data_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 QTensorProto::data(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.data)
  return _internal_data(index);
}
inline void QTensorProto::set_data(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.data)
}
inline void QTensorProto::_internal_add_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  data_.Add(value);
}
inline void QTensorProto::add_data(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_data(value);
  // @@protoc_insertion_point(field_add:caffe2.QTensorProto.data)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
QTensorProto::_internal_data() const {
  return data_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
QTensorProto::data() const {
  // @@protoc_insertion_point(field_list:caffe2.QTensorProto.data)
  return _internal_data();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
QTensorProto::_internal_mutable_data() {
  return &data_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
QTensorProto::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.QTensorProto.data)
  return _internal_mutable_data();
}

// optional string name = 7;
inline bool QTensorProto::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool QTensorProto::has_name() const {
  return _internal_has_name();
}
inline void QTensorProto::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& QTensorProto::name() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.name)
  return _internal_name();
}
inline void QTensorProto::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.name)
}
inline std::string* QTensorProto::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.QTensorProto.name)
  return _internal_mutable_name();
}
inline const std::string& QTensorProto::_internal_name() const {
  return name_.GetNoArena();
}
inline void QTensorProto::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void QTensorProto::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.QTensorProto.name)
}
inline void QTensorProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.QTensorProto.name)
}
inline void QTensorProto::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.QTensorProto.name)
}
inline std::string* QTensorProto::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* QTensorProto::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.QTensorProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void QTensorProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.QTensorProto.name)
}

// optional .caffe2.TensorProto.DataType data_type = 8 [default = INT32];
inline bool QTensorProto::_internal_has_data_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool QTensorProto::has_data_type() const {
  return _internal_has_data_type();
}
inline void QTensorProto::clear_data_type() {
  data_type_ = 2;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::caffe2::TensorProto_DataType QTensorProto::_internal_data_type() const {
  return static_cast< ::caffe2::TensorProto_DataType >(data_type_);
}
inline ::caffe2::TensorProto_DataType QTensorProto::data_type() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.data_type)
  return _internal_data_type();
}
inline void QTensorProto::_internal_set_data_type(::caffe2::TensorProto_DataType value) {
  assert(::caffe2::TensorProto_DataType_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  data_type_ = value;
}
inline void QTensorProto::set_data_type(::caffe2::TensorProto_DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.data_type)
}

// repeated double scales = 9;
inline int QTensorProto::_internal_scales_size() const {
  return scales_.size();
}
inline int QTensorProto::scales_size() const {
  return _internal_scales_size();
}
inline void QTensorProto::clear_scales() {
  scales_.Clear();
}
inline double QTensorProto::_internal_scales(int index) const {
  return scales_.Get(index);
}
inline double QTensorProto::scales(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.scales)
  return _internal_scales(index);
}
inline void QTensorProto::set_scales(int index, double value) {
  scales_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.scales)
}
inline void QTensorProto::_internal_add_scales(double value) {
  scales_.Add(value);
}
inline void QTensorProto::add_scales(double value) {
  _internal_add_scales(value);
  // @@protoc_insertion_point(field_add:caffe2.QTensorProto.scales)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
QTensorProto::_internal_scales() const {
  return scales_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
QTensorProto::scales() const {
  // @@protoc_insertion_point(field_list:caffe2.QTensorProto.scales)
  return _internal_scales();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
QTensorProto::_internal_mutable_scales() {
  return &scales_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
QTensorProto::mutable_scales() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.QTensorProto.scales)
  return _internal_mutable_scales();
}

// repeated double biases = 10;
inline int QTensorProto::_internal_biases_size() const {
  return biases_.size();
}
inline int QTensorProto::biases_size() const {
  return _internal_biases_size();
}
inline void QTensorProto::clear_biases() {
  biases_.Clear();
}
inline double QTensorProto::_internal_biases(int index) const {
  return biases_.Get(index);
}
inline double QTensorProto::biases(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.biases)
  return _internal_biases(index);
}
inline void QTensorProto::set_biases(int index, double value) {
  biases_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.biases)
}
inline void QTensorProto::_internal_add_biases(double value) {
  biases_.Add(value);
}
inline void QTensorProto::add_biases(double value) {
  _internal_add_biases(value);
  // @@protoc_insertion_point(field_add:caffe2.QTensorProto.biases)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
QTensorProto::_internal_biases() const {
  return biases_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
QTensorProto::biases() const {
  // @@protoc_insertion_point(field_list:caffe2.QTensorProto.biases)
  return _internal_biases();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
QTensorProto::_internal_mutable_biases() {
  return &biases_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
QTensorProto::mutable_biases() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.QTensorProto.biases)
  return _internal_mutable_biases();
}

// optional int32 axis = 11;
inline bool QTensorProto::_internal_has_axis() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool QTensorProto::has_axis() const {
  return _internal_has_axis();
}
inline void QTensorProto::clear_axis() {
  axis_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 QTensorProto::_internal_axis() const {
  return axis_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 QTensorProto::axis() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.axis)
  return _internal_axis();
}
inline void QTensorProto::_internal_set_axis(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  axis_ = value;
}
inline void QTensorProto::set_axis(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_axis(value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.axis)
}

// optional bool is_multiparam = 12 [default = false];
inline bool QTensorProto::_internal_has_is_multiparam() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool QTensorProto::has_is_multiparam() const {
  return _internal_has_is_multiparam();
}
inline void QTensorProto::clear_is_multiparam() {
  is_multiparam_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool QTensorProto::_internal_is_multiparam() const {
  return is_multiparam_;
}
inline bool QTensorProto::is_multiparam() const {
  // @@protoc_insertion_point(field_get:caffe2.QTensorProto.is_multiparam)
  return _internal_is_multiparam();
}
inline void QTensorProto::_internal_set_is_multiparam(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_multiparam_ = value;
}
inline void QTensorProto::set_is_multiparam(bool value) {
  _internal_set_is_multiparam(value);
  // @@protoc_insertion_point(field_set:caffe2.QTensorProto.is_multiparam)
}

// -------------------------------------------------------------------

// TensorProtos

// repeated .caffe2.TensorProto protos = 1;
inline int TensorProtos::_internal_protos_size() const {
  return protos_.size();
}
inline int TensorProtos::protos_size() const {
  return _internal_protos_size();
}
inline void TensorProtos::clear_protos() {
  protos_.Clear();
}
inline ::caffe2::TensorProto* TensorProtos::mutable_protos(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorProtos.protos)
  return protos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorProto >*
TensorProtos::mutable_protos() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorProtos.protos)
  return &protos_;
}
inline const ::caffe2::TensorProto& TensorProtos::_internal_protos(int index) const {
  return protos_.Get(index);
}
inline const ::caffe2::TensorProto& TensorProtos::protos(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorProtos.protos)
  return _internal_protos(index);
}
inline ::caffe2::TensorProto* TensorProtos::_internal_add_protos() {
  return protos_.Add();
}
inline ::caffe2::TensorProto* TensorProtos::add_protos() {
  // @@protoc_insertion_point(field_add:caffe2.TensorProtos.protos)
  return _internal_add_protos();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorProto >&
TensorProtos::protos() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorProtos.protos)
  return protos_;
}

// -------------------------------------------------------------------

// TensorShape

// repeated int64 dims = 1;
inline int TensorShape::_internal_dims_size() const {
  return dims_.size();
}
inline int TensorShape::dims_size() const {
  return _internal_dims_size();
}
inline void TensorShape::clear_dims() {
  dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorShape::_internal_dims(int index) const {
  return dims_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorShape::dims(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShape.dims)
  return _internal_dims(index);
}
inline void TensorShape::set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorShape.dims)
}
inline void TensorShape::_internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Add(value);
}
inline void TensorShape::add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorShape.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TensorShape::_internal_dims() const {
  return dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TensorShape::dims() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorShape.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TensorShape::_internal_mutable_dims() {
  return &dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TensorShape::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorShape.dims)
  return _internal_mutable_dims();
}

// optional .caffe2.TensorProto.DataType data_type = 2 [default = FLOAT];
inline bool TensorShape::_internal_has_data_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TensorShape::has_data_type() const {
  return _internal_has_data_type();
}
inline void TensorShape::clear_data_type() {
  data_type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::caffe2::TensorProto_DataType TensorShape::_internal_data_type() const {
  return static_cast< ::caffe2::TensorProto_DataType >(data_type_);
}
inline ::caffe2::TensorProto_DataType TensorShape::data_type() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShape.data_type)
  return _internal_data_type();
}
inline void TensorShape::_internal_set_data_type(::caffe2::TensorProto_DataType value) {
  assert(::caffe2::TensorProto_DataType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  data_type_ = value;
}
inline void TensorShape::set_data_type(::caffe2::TensorProto_DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorShape.data_type)
}

// repeated int32 unknown_dims = 3;
inline int TensorShape::_internal_unknown_dims_size() const {
  return unknown_dims_.size();
}
inline int TensorShape::unknown_dims_size() const {
  return _internal_unknown_dims_size();
}
inline void TensorShape::clear_unknown_dims() {
  unknown_dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TensorShape::_internal_unknown_dims(int index) const {
  return unknown_dims_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TensorShape::unknown_dims(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShape.unknown_dims)
  return _internal_unknown_dims(index);
}
inline void TensorShape::set_unknown_dims(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  unknown_dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorShape.unknown_dims)
}
inline void TensorShape::_internal_add_unknown_dims(::PROTOBUF_NAMESPACE_ID::int32 value) {
  unknown_dims_.Add(value);
}
inline void TensorShape::add_unknown_dims(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_unknown_dims(value);
  // @@protoc_insertion_point(field_add:caffe2.TensorShape.unknown_dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TensorShape::_internal_unknown_dims() const {
  return unknown_dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
TensorShape::unknown_dims() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorShape.unknown_dims)
  return _internal_unknown_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TensorShape::_internal_mutable_unknown_dims() {
  return &unknown_dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
TensorShape::mutable_unknown_dims() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorShape.unknown_dims)
  return _internal_mutable_unknown_dims();
}

// optional bool unknown_shape = 4 [default = false];
inline bool TensorShape::_internal_has_unknown_shape() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TensorShape::has_unknown_shape() const {
  return _internal_has_unknown_shape();
}
inline void TensorShape::clear_unknown_shape() {
  unknown_shape_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool TensorShape::_internal_unknown_shape() const {
  return unknown_shape_;
}
inline bool TensorShape::unknown_shape() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShape.unknown_shape)
  return _internal_unknown_shape();
}
inline void TensorShape::_internal_set_unknown_shape(bool value) {
  _has_bits_[0] |= 0x00000002u;
  unknown_shape_ = value;
}
inline void TensorShape::set_unknown_shape(bool value) {
  _internal_set_unknown_shape(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorShape.unknown_shape)
}

// optional string name = 5;
inline bool TensorShape::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TensorShape::has_name() const {
  return _internal_has_name();
}
inline void TensorShape::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TensorShape::name() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShape.name)
  return _internal_name();
}
inline void TensorShape::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorShape.name)
}
inline std::string* TensorShape::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorShape.name)
  return _internal_mutable_name();
}
inline const std::string& TensorShape::_internal_name() const {
  return name_.GetNoArena();
}
inline void TensorShape::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void TensorShape::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.TensorShape.name)
}
inline void TensorShape::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.TensorShape.name)
}
inline void TensorShape::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.TensorShape.name)
}
inline std::string* TensorShape::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* TensorShape::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.TensorShape.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void TensorShape::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorShape.name)
}

// -------------------------------------------------------------------

// TensorShapes

// repeated .caffe2.TensorShape shapes = 1;
inline int TensorShapes::_internal_shapes_size() const {
  return shapes_.size();
}
inline int TensorShapes::shapes_size() const {
  return _internal_shapes_size();
}
inline void TensorShapes::clear_shapes() {
  shapes_.Clear();
}
inline ::caffe2::TensorShape* TensorShapes::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorShapes.shapes)
  return shapes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorShape >*
TensorShapes::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorShapes.shapes)
  return &shapes_;
}
inline const ::caffe2::TensorShape& TensorShapes::_internal_shapes(int index) const {
  return shapes_.Get(index);
}
inline const ::caffe2::TensorShape& TensorShapes::shapes(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorShapes.shapes)
  return _internal_shapes(index);
}
inline ::caffe2::TensorShape* TensorShapes::_internal_add_shapes() {
  return shapes_.Add();
}
inline ::caffe2::TensorShape* TensorShapes::add_shapes() {
  // @@protoc_insertion_point(field_add:caffe2.TensorShapes.shapes)
  return _internal_add_shapes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorShape >&
TensorShapes::shapes() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorShapes.shapes)
  return shapes_;
}

// -------------------------------------------------------------------

// TensorBoundShape

// optional .caffe2.TensorShape shape = 1;
inline bool TensorBoundShape::_internal_has_shape() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || shape_ != nullptr);
  return value;
}
inline bool TensorBoundShape::has_shape() const {
  return _internal_has_shape();
}
inline void TensorBoundShape::clear_shape() {
  if (shape_ != nullptr) shape_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::caffe2::TensorShape& TensorBoundShape::_internal_shape() const {
  const ::caffe2::TensorShape* p = shape_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::TensorShape*>(
      &::caffe2::_TensorShape_default_instance_);
}
inline const ::caffe2::TensorShape& TensorBoundShape::shape() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorBoundShape.shape)
  return _internal_shape();
}
inline ::caffe2::TensorShape* TensorBoundShape::release_shape() {
  // @@protoc_insertion_point(field_release:caffe2.TensorBoundShape.shape)
  _has_bits_[0] &= ~0x00000002u;
  ::caffe2::TensorShape* temp = shape_;
  shape_ = nullptr;
  return temp;
}
inline ::caffe2::TensorShape* TensorBoundShape::_internal_mutable_shape() {
  _has_bits_[0] |= 0x00000002u;
  if (shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::TensorShape>(GetArenaNoVirtual());
    shape_ = p;
  }
  return shape_;
}
inline ::caffe2::TensorShape* TensorBoundShape::mutable_shape() {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorBoundShape.shape)
  return _internal_mutable_shape();
}
inline void TensorBoundShape::set_allocated_shape(::caffe2::TensorShape* shape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete shape_;
  }
  if (shape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      shape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, shape, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  shape_ = shape;
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorBoundShape.shape)
}

// repeated .caffe2.TensorBoundShape.DimType dim_type = 2;
inline int TensorBoundShape::_internal_dim_type_size() const {
  return dim_type_.size();
}
inline int TensorBoundShape::dim_type_size() const {
  return _internal_dim_type_size();
}
inline void TensorBoundShape::clear_dim_type() {
  dim_type_.Clear();
}
inline ::caffe2::TensorBoundShape_DimType TensorBoundShape::_internal_dim_type(int index) const {
  return static_cast< ::caffe2::TensorBoundShape_DimType >(dim_type_.Get(index));
}
inline ::caffe2::TensorBoundShape_DimType TensorBoundShape::dim_type(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorBoundShape.dim_type)
  return _internal_dim_type(index);
}
inline void TensorBoundShape::set_dim_type(int index, ::caffe2::TensorBoundShape_DimType value) {
  assert(::caffe2::TensorBoundShape_DimType_IsValid(value));
  dim_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.TensorBoundShape.dim_type)
}
inline void TensorBoundShape::_internal_add_dim_type(::caffe2::TensorBoundShape_DimType value) {
  assert(::caffe2::TensorBoundShape_DimType_IsValid(value));
  dim_type_.Add(value);
}
inline void TensorBoundShape::add_dim_type(::caffe2::TensorBoundShape_DimType value) {
  // @@protoc_insertion_point(field_add:caffe2.TensorBoundShape.dim_type)
  _internal_add_dim_type(value);
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TensorBoundShape::dim_type() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorBoundShape.dim_type)
  return dim_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TensorBoundShape::_internal_mutable_dim_type() {
  return &dim_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TensorBoundShape::mutable_dim_type() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorBoundShape.dim_type)
  return _internal_mutable_dim_type();
}

// optional string name = 3;
inline bool TensorBoundShape::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TensorBoundShape::has_name() const {
  return _internal_has_name();
}
inline void TensorBoundShape::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TensorBoundShape::name() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorBoundShape.name)
  return _internal_name();
}
inline void TensorBoundShape::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorBoundShape.name)
}
inline std::string* TensorBoundShape::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorBoundShape.name)
  return _internal_mutable_name();
}
inline const std::string& TensorBoundShape::_internal_name() const {
  return name_.GetNoArena();
}
inline void TensorBoundShape::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void TensorBoundShape::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.TensorBoundShape.name)
}
inline void TensorBoundShape::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.TensorBoundShape.name)
}
inline void TensorBoundShape::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.TensorBoundShape.name)
}
inline std::string* TensorBoundShape::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* TensorBoundShape::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.TensorBoundShape.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void TensorBoundShape::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.TensorBoundShape.name)
}

// -------------------------------------------------------------------

// TensorBoundShapes

// repeated .caffe2.TensorBoundShape shapes = 1;
inline int TensorBoundShapes::_internal_shapes_size() const {
  return shapes_.size();
}
inline int TensorBoundShapes::shapes_size() const {
  return _internal_shapes_size();
}
inline void TensorBoundShapes::clear_shapes() {
  shapes_.Clear();
}
inline ::caffe2::TensorBoundShape* TensorBoundShapes::mutable_shapes(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.TensorBoundShapes.shapes)
  return shapes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorBoundShape >*
TensorBoundShapes::mutable_shapes() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.TensorBoundShapes.shapes)
  return &shapes_;
}
inline const ::caffe2::TensorBoundShape& TensorBoundShapes::_internal_shapes(int index) const {
  return shapes_.Get(index);
}
inline const ::caffe2::TensorBoundShape& TensorBoundShapes::shapes(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.TensorBoundShapes.shapes)
  return _internal_shapes(index);
}
inline ::caffe2::TensorBoundShape* TensorBoundShapes::_internal_add_shapes() {
  return shapes_.Add();
}
inline ::caffe2::TensorBoundShape* TensorBoundShapes::add_shapes() {
  // @@protoc_insertion_point(field_add:caffe2.TensorBoundShapes.shapes)
  return _internal_add_shapes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorBoundShape >&
TensorBoundShapes::shapes() const {
  // @@protoc_insertion_point(field_list:caffe2.TensorBoundShapes.shapes)
  return shapes_;
}

// optional int64 max_batch_size = 2;
inline bool TensorBoundShapes::_internal_has_max_batch_size() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TensorBoundShapes::has_max_batch_size() const {
  return _internal_has_max_batch_size();
}
inline void TensorBoundShapes::clear_max_batch_size() {
  max_batch_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorBoundShapes::_internal_max_batch_size() const {
  return max_batch_size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorBoundShapes::max_batch_size() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorBoundShapes.max_batch_size)
  return _internal_max_batch_size();
}
inline void TensorBoundShapes::_internal_set_max_batch_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  max_batch_size_ = value;
}
inline void TensorBoundShapes::set_max_batch_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_batch_size(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorBoundShapes.max_batch_size)
}

// optional int64 max_feature_len = 3;
inline bool TensorBoundShapes::_internal_has_max_feature_len() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TensorBoundShapes::has_max_feature_len() const {
  return _internal_has_max_feature_len();
}
inline void TensorBoundShapes::clear_max_feature_len() {
  max_feature_len_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorBoundShapes::_internal_max_feature_len() const {
  return max_feature_len_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorBoundShapes::max_feature_len() const {
  // @@protoc_insertion_point(field_get:caffe2.TensorBoundShapes.max_feature_len)
  return _internal_max_feature_len();
}
inline void TensorBoundShapes::_internal_set_max_feature_len(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  max_feature_len_ = value;
}
inline void TensorBoundShapes::set_max_feature_len(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_feature_len(value);
  // @@protoc_insertion_point(field_set:caffe2.TensorBoundShapes.max_feature_len)
}

// -------------------------------------------------------------------

// Argument

// optional string name = 1;
inline bool Argument::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Argument::has_name() const {
  return _internal_has_name();
}
inline void Argument::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Argument::name() const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.name)
  return _internal_name();
}
inline void Argument::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.Argument.name)
}
inline std::string* Argument::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.name)
  return _internal_mutable_name();
}
inline const std::string& Argument::_internal_name() const {
  return name_.GetNoArena();
}
inline void Argument::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void Argument::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.Argument.name)
}
inline void Argument::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.Argument.name)
}
inline void Argument::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.Argument.name)
}
inline std::string* Argument::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* Argument::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.Argument.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.Argument.name)
}

// optional float f = 2;
inline bool Argument::_internal_has_f() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Argument::has_f() const {
  return _internal_has_f();
}
inline void Argument::clear_f() {
  f_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float Argument::_internal_f() const {
  return f_;
}
inline float Argument::f() const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.f)
  return _internal_f();
}
inline void Argument::_internal_set_f(float value) {
  _has_bits_[0] |= 0x00000020u;
  f_ = value;
}
inline void Argument::set_f(float value) {
  _internal_set_f(value);
  // @@protoc_insertion_point(field_set:caffe2.Argument.f)
}

// optional int64 i = 3;
inline bool Argument::_internal_has_i() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Argument::has_i() const {
  return _internal_has_i();
}
inline void Argument::clear_i() {
  i_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Argument::_internal_i() const {
  return i_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Argument::i() const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.i)
  return _internal_i();
}
inline void Argument::_internal_set_i(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  i_ = value;
}
inline void Argument::set_i(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:caffe2.Argument.i)
}

// optional bytes s = 4;
inline bool Argument::_internal_has_s() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Argument::has_s() const {
  return _internal_has_s();
}
inline void Argument::clear_s() {
  s_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Argument::s() const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.s)
  return _internal_s();
}
inline void Argument::set_s(const std::string& value) {
  _internal_set_s(value);
  // @@protoc_insertion_point(field_set:caffe2.Argument.s)
}
inline std::string* Argument::mutable_s() {
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.s)
  return _internal_mutable_s();
}
inline const std::string& Argument::_internal_s() const {
  return s_.GetNoArena();
}
inline void Argument::_internal_set_s(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  s_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void Argument::set_s(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  s_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.Argument.s)
}
inline void Argument::set_s(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  s_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.Argument.s)
}
inline void Argument::set_s(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  s_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.Argument.s)
}
inline std::string* Argument::_internal_mutable_s() {
  _has_bits_[0] |= 0x00000002u;
  return s_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* Argument::release_s() {
  // @@protoc_insertion_point(field_release:caffe2.Argument.s)
  if (!_internal_has_s()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return s_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void Argument::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  s_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), s);
  // @@protoc_insertion_point(field_set_allocated:caffe2.Argument.s)
}

// optional .caffe2.TensorProto t = 10;
inline bool Argument::_internal_has_t() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || t_ != nullptr);
  return value;
}
inline bool Argument::has_t() const {
  return _internal_has_t();
}
inline void Argument::clear_t() {
  if (t_ != nullptr) t_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::caffe2::TensorProto& Argument::_internal_t() const {
  const ::caffe2::TensorProto* p = t_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::TensorProto*>(
      &::caffe2::_TensorProto_default_instance_);
}
inline const ::caffe2::TensorProto& Argument::t() const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.t)
  return _internal_t();
}
inline ::caffe2::TensorProto* Argument::release_t() {
  // @@protoc_insertion_point(field_release:caffe2.Argument.t)
  _has_bits_[0] &= ~0x00000008u;
  ::caffe2::TensorProto* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::caffe2::TensorProto* Argument::_internal_mutable_t() {
  _has_bits_[0] |= 0x00000008u;
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::TensorProto>(GetArenaNoVirtual());
    t_ = p;
  }
  return t_;
}
inline ::caffe2::TensorProto* Argument::mutable_t() {
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.t)
  return _internal_mutable_t();
}
inline void Argument::set_allocated_t(::caffe2::TensorProto* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete t_;
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:caffe2.Argument.t)
}

// optional .caffe2.NetDef n = 8;
inline bool Argument::_internal_has_n() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || n_ != nullptr);
  return value;
}
inline bool Argument::has_n() const {
  return _internal_has_n();
}
inline void Argument::clear_n() {
  if (n_ != nullptr) n_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::caffe2::NetDef& Argument::_internal_n() const {
  const ::caffe2::NetDef* p = n_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::NetDef*>(
      &::caffe2::_NetDef_default_instance_);
}
inline const ::caffe2::NetDef& Argument::n() const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.n)
  return _internal_n();
}
inline ::caffe2::NetDef* Argument::release_n() {
  // @@protoc_insertion_point(field_release:caffe2.Argument.n)
  _has_bits_[0] &= ~0x00000004u;
  ::caffe2::NetDef* temp = n_;
  n_ = nullptr;
  return temp;
}
inline ::caffe2::NetDef* Argument::_internal_mutable_n() {
  _has_bits_[0] |= 0x00000004u;
  if (n_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::NetDef>(GetArenaNoVirtual());
    n_ = p;
  }
  return n_;
}
inline ::caffe2::NetDef* Argument::mutable_n() {
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.n)
  return _internal_mutable_n();
}
inline void Argument::set_allocated_n(::caffe2::NetDef* n) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete n_;
  }
  if (n) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      n = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, n, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  n_ = n;
  // @@protoc_insertion_point(field_set_allocated:caffe2.Argument.n)
}

// repeated float floats = 5;
inline int Argument::_internal_floats_size() const {
  return floats_.size();
}
inline int Argument::floats_size() const {
  return _internal_floats_size();
}
inline void Argument::clear_floats() {
  floats_.Clear();
}
inline float Argument::_internal_floats(int index) const {
  return floats_.Get(index);
}
inline float Argument::floats(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.floats)
  return _internal_floats(index);
}
inline void Argument::set_floats(int index, float value) {
  floats_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.Argument.floats)
}
inline void Argument::_internal_add_floats(float value) {
  floats_.Add(value);
}
inline void Argument::add_floats(float value) {
  _internal_add_floats(value);
  // @@protoc_insertion_point(field_add:caffe2.Argument.floats)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Argument::_internal_floats() const {
  return floats_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Argument::floats() const {
  // @@protoc_insertion_point(field_list:caffe2.Argument.floats)
  return _internal_floats();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Argument::_internal_mutable_floats() {
  return &floats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Argument::mutable_floats() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.Argument.floats)
  return _internal_mutable_floats();
}

// repeated int64 ints = 6;
inline int Argument::_internal_ints_size() const {
  return ints_.size();
}
inline int Argument::ints_size() const {
  return _internal_ints_size();
}
inline void Argument::clear_ints() {
  ints_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Argument::_internal_ints(int index) const {
  return ints_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Argument::ints(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.ints)
  return _internal_ints(index);
}
inline void Argument::set_ints(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.Argument.ints)
}
inline void Argument::_internal_add_ints(::PROTOBUF_NAMESPACE_ID::int64 value) {
  ints_.Add(value);
}
inline void Argument::add_ints(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_ints(value);
  // @@protoc_insertion_point(field_add:caffe2.Argument.ints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
Argument::_internal_ints() const {
  return ints_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
Argument::ints() const {
  // @@protoc_insertion_point(field_list:caffe2.Argument.ints)
  return _internal_ints();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
Argument::_internal_mutable_ints() {
  return &ints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
Argument::mutable_ints() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.Argument.ints)
  return _internal_mutable_ints();
}

// repeated bytes strings = 7;
inline int Argument::_internal_strings_size() const {
  return strings_.size();
}
inline int Argument::strings_size() const {
  return _internal_strings_size();
}
inline void Argument::clear_strings() {
  strings_.Clear();
}
inline std::string* Argument::add_strings() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.Argument.strings)
  return _internal_add_strings();
}
inline const std::string& Argument::_internal_strings(int index) const {
  return strings_.Get(index);
}
inline const std::string& Argument::strings(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.strings)
  return _internal_strings(index);
}
inline std::string* Argument::mutable_strings(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.strings)
  return strings_.Mutable(index);
}
inline void Argument::set_strings(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.Argument.strings)
  strings_.Mutable(index)->assign(value);
}
inline void Argument::set_strings(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.Argument.strings)
  strings_.Mutable(index)->assign(std::move(value));
}
inline void Argument::set_strings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.Argument.strings)
}
inline void Argument::set_strings(int index, const void* value, size_t size) {
  strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.Argument.strings)
}
inline std::string* Argument::_internal_add_strings() {
  return strings_.Add();
}
inline void Argument::add_strings(const std::string& value) {
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.Argument.strings)
}
inline void Argument::add_strings(std::string&& value) {
  strings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.Argument.strings)
}
inline void Argument::add_strings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.Argument.strings)
}
inline void Argument::add_strings(const void* value, size_t size) {
  strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.Argument.strings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Argument::strings() const {
  // @@protoc_insertion_point(field_list:caffe2.Argument.strings)
  return strings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Argument::mutable_strings() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.Argument.strings)
  return &strings_;
}

// repeated .caffe2.TensorProto tensors = 11;
inline int Argument::_internal_tensors_size() const {
  return tensors_.size();
}
inline int Argument::tensors_size() const {
  return _internal_tensors_size();
}
inline void Argument::clear_tensors() {
  tensors_.Clear();
}
inline ::caffe2::TensorProto* Argument::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.tensors)
  return tensors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorProto >*
Argument::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.Argument.tensors)
  return &tensors_;
}
inline const ::caffe2::TensorProto& Argument::_internal_tensors(int index) const {
  return tensors_.Get(index);
}
inline const ::caffe2::TensorProto& Argument::tensors(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.tensors)
  return _internal_tensors(index);
}
inline ::caffe2::TensorProto* Argument::_internal_add_tensors() {
  return tensors_.Add();
}
inline ::caffe2::TensorProto* Argument::add_tensors() {
  // @@protoc_insertion_point(field_add:caffe2.Argument.tensors)
  return _internal_add_tensors();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::TensorProto >&
Argument::tensors() const {
  // @@protoc_insertion_point(field_list:caffe2.Argument.tensors)
  return tensors_;
}

// repeated .caffe2.NetDef nets = 9;
inline int Argument::_internal_nets_size() const {
  return nets_.size();
}
inline int Argument::nets_size() const {
  return _internal_nets_size();
}
inline void Argument::clear_nets() {
  nets_.Clear();
}
inline ::caffe2::NetDef* Argument::mutable_nets(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.nets)
  return nets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >*
Argument::mutable_nets() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.Argument.nets)
  return &nets_;
}
inline const ::caffe2::NetDef& Argument::_internal_nets(int index) const {
  return nets_.Get(index);
}
inline const ::caffe2::NetDef& Argument::nets(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.nets)
  return _internal_nets(index);
}
inline ::caffe2::NetDef* Argument::_internal_add_nets() {
  return nets_.Add();
}
inline ::caffe2::NetDef* Argument::add_nets() {
  // @@protoc_insertion_point(field_add:caffe2.Argument.nets)
  return _internal_add_nets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >&
Argument::nets() const {
  // @@protoc_insertion_point(field_list:caffe2.Argument.nets)
  return nets_;
}

// repeated .caffe2.QTensorProto qtensors = 12;
inline int Argument::_internal_qtensors_size() const {
  return qtensors_.size();
}
inline int Argument::qtensors_size() const {
  return _internal_qtensors_size();
}
inline void Argument::clear_qtensors() {
  qtensors_.Clear();
}
inline ::caffe2::QTensorProto* Argument::mutable_qtensors(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.Argument.qtensors)
  return qtensors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::QTensorProto >*
Argument::mutable_qtensors() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.Argument.qtensors)
  return &qtensors_;
}
inline const ::caffe2::QTensorProto& Argument::_internal_qtensors(int index) const {
  return qtensors_.Get(index);
}
inline const ::caffe2::QTensorProto& Argument::qtensors(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.Argument.qtensors)
  return _internal_qtensors(index);
}
inline ::caffe2::QTensorProto* Argument::_internal_add_qtensors() {
  return qtensors_.Add();
}
inline ::caffe2::QTensorProto* Argument::add_qtensors() {
  // @@protoc_insertion_point(field_add:caffe2.Argument.qtensors)
  return _internal_add_qtensors();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::QTensorProto >&
Argument::qtensors() const {
  // @@protoc_insertion_point(field_list:caffe2.Argument.qtensors)
  return qtensors_;
}

// -------------------------------------------------------------------

// DeviceOption

// optional int32 device_type = 1 [default = 0];
inline bool DeviceOption::_internal_has_device_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DeviceOption::has_device_type() const {
  return _internal_has_device_type();
}
inline void DeviceOption::clear_device_type() {
  device_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceOption::_internal_device_type() const {
  return device_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceOption::device_type() const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.device_type)
  return _internal_device_type();
}
inline void DeviceOption::_internal_set_device_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  device_type_ = value;
}
inline void DeviceOption::set_device_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_device_type(value);
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.device_type)
}

// optional int32 device_id = 2;
inline bool DeviceOption::_internal_has_device_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DeviceOption::has_device_id() const {
  return _internal_has_device_id();
}
inline void DeviceOption::clear_device_id() {
  device_id_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceOption::_internal_device_id() const {
  return device_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceOption::device_id() const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.device_id)
  return _internal_device_id();
}
inline void DeviceOption::_internal_set_device_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  device_id_ = value;
}
inline void DeviceOption::set_device_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.device_id)
}

// optional uint32 random_seed = 3;
inline bool DeviceOption::_internal_has_random_seed() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DeviceOption::has_random_seed() const {
  return _internal_has_random_seed();
}
inline void DeviceOption::clear_random_seed() {
  random_seed_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceOption::_internal_random_seed() const {
  return random_seed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 DeviceOption::random_seed() const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.random_seed)
  return _internal_random_seed();
}
inline void DeviceOption::_internal_set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  random_seed_ = value;
}
inline void DeviceOption::set_random_seed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_random_seed(value);
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.random_seed)
}

// optional string node_name = 4;
inline bool DeviceOption::_internal_has_node_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DeviceOption::has_node_name() const {
  return _internal_has_node_name();
}
inline void DeviceOption::clear_node_name() {
  node_name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DeviceOption::node_name() const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.node_name)
  return _internal_node_name();
}
inline void DeviceOption::set_node_name(const std::string& value) {
  _internal_set_node_name(value);
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.node_name)
}
inline std::string* DeviceOption::mutable_node_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.DeviceOption.node_name)
  return _internal_mutable_node_name();
}
inline const std::string& DeviceOption::_internal_node_name() const {
  return node_name_.GetNoArena();
}
inline void DeviceOption::_internal_set_node_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void DeviceOption::set_node_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.DeviceOption.node_name)
}
inline void DeviceOption::set_node_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  node_name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.DeviceOption.node_name)
}
inline void DeviceOption::set_node_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  node_name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.DeviceOption.node_name)
}
inline std::string* DeviceOption::_internal_mutable_node_name() {
  _has_bits_[0] |= 0x00000001u;
  return node_name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* DeviceOption::release_node_name() {
  // @@protoc_insertion_point(field_release:caffe2.DeviceOption.node_name)
  if (!_internal_has_node_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return node_name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void DeviceOption::set_allocated_node_name(std::string* node_name) {
  if (node_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), node_name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.DeviceOption.node_name)
}

// optional int32 numa_node_id = 5;
inline bool DeviceOption::_internal_has_numa_node_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DeviceOption::has_numa_node_id() const {
  return _internal_has_numa_node_id();
}
inline void DeviceOption::clear_numa_node_id() {
  numa_node_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceOption::_internal_numa_node_id() const {
  return numa_node_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DeviceOption::numa_node_id() const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.numa_node_id)
  return _internal_numa_node_id();
}
inline void DeviceOption::_internal_set_numa_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  numa_node_id_ = value;
}
inline void DeviceOption::set_numa_node_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_numa_node_id(value);
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.numa_node_id)
}

// repeated string extra_info = 6;
inline int DeviceOption::_internal_extra_info_size() const {
  return extra_info_.size();
}
inline int DeviceOption::extra_info_size() const {
  return _internal_extra_info_size();
}
inline void DeviceOption::clear_extra_info() {
  extra_info_.Clear();
}
inline std::string* DeviceOption::add_extra_info() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.DeviceOption.extra_info)
  return _internal_add_extra_info();
}
inline const std::string& DeviceOption::_internal_extra_info(int index) const {
  return extra_info_.Get(index);
}
inline const std::string& DeviceOption::extra_info(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.DeviceOption.extra_info)
  return _internal_extra_info(index);
}
inline std::string* DeviceOption::mutable_extra_info(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.DeviceOption.extra_info)
  return extra_info_.Mutable(index);
}
inline void DeviceOption::set_extra_info(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.extra_info)
  extra_info_.Mutable(index)->assign(value);
}
inline void DeviceOption::set_extra_info(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.DeviceOption.extra_info)
  extra_info_.Mutable(index)->assign(std::move(value));
}
inline void DeviceOption::set_extra_info(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  extra_info_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.DeviceOption.extra_info)
}
inline void DeviceOption::set_extra_info(int index, const char* value, size_t size) {
  extra_info_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.DeviceOption.extra_info)
}
inline std::string* DeviceOption::_internal_add_extra_info() {
  return extra_info_.Add();
}
inline void DeviceOption::add_extra_info(const std::string& value) {
  extra_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.DeviceOption.extra_info)
}
inline void DeviceOption::add_extra_info(std::string&& value) {
  extra_info_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.DeviceOption.extra_info)
}
inline void DeviceOption::add_extra_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  extra_info_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.DeviceOption.extra_info)
}
inline void DeviceOption::add_extra_info(const char* value, size_t size) {
  extra_info_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.DeviceOption.extra_info)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DeviceOption::extra_info() const {
  // @@protoc_insertion_point(field_list:caffe2.DeviceOption.extra_info)
  return extra_info_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DeviceOption::mutable_extra_info() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.DeviceOption.extra_info)
  return &extra_info_;
}

// -------------------------------------------------------------------

// OperatorDef

// repeated string input = 1;
inline int OperatorDef::_internal_input_size() const {
  return input_.size();
}
inline int OperatorDef::input_size() const {
  return _internal_input_size();
}
inline void OperatorDef::clear_input() {
  input_.Clear();
}
inline std::string* OperatorDef::add_input() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.OperatorDef.input)
  return _internal_add_input();
}
inline const std::string& OperatorDef::_internal_input(int index) const {
  return input_.Get(index);
}
inline const std::string& OperatorDef::input(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.input)
  return _internal_input(index);
}
inline std::string* OperatorDef::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.input)
  return input_.Mutable(index);
}
inline void OperatorDef::set_input(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.input)
  input_.Mutable(index)->assign(value);
}
inline void OperatorDef::set_input(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.input)
  input_.Mutable(index)->assign(std::move(value));
}
inline void OperatorDef::set_input(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.input)
}
inline void OperatorDef::set_input(int index, const char* value, size_t size) {
  input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.input)
}
inline std::string* OperatorDef::_internal_add_input() {
  return input_.Add();
}
inline void OperatorDef::add_input(const std::string& value) {
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.input)
}
inline void OperatorDef::add_input(std::string&& value) {
  input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.input)
}
inline void OperatorDef::add_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.OperatorDef.input)
}
inline void OperatorDef::add_input(const char* value, size_t size) {
  input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.OperatorDef.input)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OperatorDef::input() const {
  // @@protoc_insertion_point(field_list:caffe2.OperatorDef.input)
  return input_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OperatorDef::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.OperatorDef.input)
  return &input_;
}

// repeated string output = 2;
inline int OperatorDef::_internal_output_size() const {
  return output_.size();
}
inline int OperatorDef::output_size() const {
  return _internal_output_size();
}
inline void OperatorDef::clear_output() {
  output_.Clear();
}
inline std::string* OperatorDef::add_output() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.OperatorDef.output)
  return _internal_add_output();
}
inline const std::string& OperatorDef::_internal_output(int index) const {
  return output_.Get(index);
}
inline const std::string& OperatorDef::output(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.output)
  return _internal_output(index);
}
inline std::string* OperatorDef::mutable_output(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.output)
  return output_.Mutable(index);
}
inline void OperatorDef::set_output(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.output)
  output_.Mutable(index)->assign(value);
}
inline void OperatorDef::set_output(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.output)
  output_.Mutable(index)->assign(std::move(value));
}
inline void OperatorDef::set_output(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.output)
}
inline void OperatorDef::set_output(int index, const char* value, size_t size) {
  output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.output)
}
inline std::string* OperatorDef::_internal_add_output() {
  return output_.Add();
}
inline void OperatorDef::add_output(const std::string& value) {
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.output)
}
inline void OperatorDef::add_output(std::string&& value) {
  output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.output)
}
inline void OperatorDef::add_output(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.OperatorDef.output)
}
inline void OperatorDef::add_output(const char* value, size_t size) {
  output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.OperatorDef.output)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OperatorDef::output() const {
  // @@protoc_insertion_point(field_list:caffe2.OperatorDef.output)
  return output_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OperatorDef::mutable_output() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.OperatorDef.output)
  return &output_;
}

// optional string name = 3;
inline bool OperatorDef::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OperatorDef::has_name() const {
  return _internal_has_name();
}
inline void OperatorDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& OperatorDef::name() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.name)
  return _internal_name();
}
inline void OperatorDef::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.name)
}
inline std::string* OperatorDef::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.name)
  return _internal_mutable_name();
}
inline const std::string& OperatorDef::_internal_name() const {
  return name_.GetNoArena();
}
inline void OperatorDef::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void OperatorDef::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.OperatorDef.name)
}
inline void OperatorDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.name)
}
inline void OperatorDef::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.name)
}
inline std::string* OperatorDef::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* OperatorDef::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.name)
}

// optional string type = 4;
inline bool OperatorDef::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OperatorDef::has_type() const {
  return _internal_has_type();
}
inline void OperatorDef::clear_type() {
  type_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& OperatorDef::type() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.type)
  return _internal_type();
}
inline void OperatorDef::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.type)
}
inline std::string* OperatorDef::mutable_type() {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.type)
  return _internal_mutable_type();
}
inline const std::string& OperatorDef::_internal_type() const {
  return type_.GetNoArena();
}
inline void OperatorDef::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void OperatorDef::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.OperatorDef.type)
}
inline void OperatorDef::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.type)
}
inline void OperatorDef::set_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.type)
}
inline std::string* OperatorDef::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  return type_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* OperatorDef::release_type() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return type_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.type)
}

// repeated .caffe2.Argument arg = 5;
inline int OperatorDef::_internal_arg_size() const {
  return arg_.size();
}
inline int OperatorDef::arg_size() const {
  return _internal_arg_size();
}
inline void OperatorDef::clear_arg() {
  arg_.Clear();
}
inline ::caffe2::Argument* OperatorDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.arg)
  return arg_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::Argument >*
OperatorDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.OperatorDef.arg)
  return &arg_;
}
inline const ::caffe2::Argument& OperatorDef::_internal_arg(int index) const {
  return arg_.Get(index);
}
inline const ::caffe2::Argument& OperatorDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.arg)
  return _internal_arg(index);
}
inline ::caffe2::Argument* OperatorDef::_internal_add_arg() {
  return arg_.Add();
}
inline ::caffe2::Argument* OperatorDef::add_arg() {
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.arg)
  return _internal_add_arg();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::Argument >&
OperatorDef::arg() const {
  // @@protoc_insertion_point(field_list:caffe2.OperatorDef.arg)
  return arg_;
}

// optional .caffe2.DeviceOption device_option = 6;
inline bool OperatorDef::_internal_has_device_option() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || device_option_ != nullptr);
  return value;
}
inline bool OperatorDef::has_device_option() const {
  return _internal_has_device_option();
}
inline void OperatorDef::clear_device_option() {
  if (device_option_ != nullptr) device_option_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::caffe2::DeviceOption& OperatorDef::_internal_device_option() const {
  const ::caffe2::DeviceOption* p = device_option_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::DeviceOption*>(
      &::caffe2::_DeviceOption_default_instance_);
}
inline const ::caffe2::DeviceOption& OperatorDef::device_option() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.device_option)
  return _internal_device_option();
}
inline ::caffe2::DeviceOption* OperatorDef::release_device_option() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.device_option)
  _has_bits_[0] &= ~0x00000020u;
  ::caffe2::DeviceOption* temp = device_option_;
  device_option_ = nullptr;
  return temp;
}
inline ::caffe2::DeviceOption* OperatorDef::_internal_mutable_device_option() {
  _has_bits_[0] |= 0x00000020u;
  if (device_option_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::DeviceOption>(GetArenaNoVirtual());
    device_option_ = p;
  }
  return device_option_;
}
inline ::caffe2::DeviceOption* OperatorDef::mutable_device_option() {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.device_option)
  return _internal_mutable_device_option();
}
inline void OperatorDef::set_allocated_device_option(::caffe2::DeviceOption* device_option) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_option_;
  }
  if (device_option) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_option = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_option, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  device_option_ = device_option;
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.device_option)
}

// optional string engine = 7;
inline bool OperatorDef::_internal_has_engine() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OperatorDef::has_engine() const {
  return _internal_has_engine();
}
inline void OperatorDef::clear_engine() {
  engine_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& OperatorDef::engine() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.engine)
  return _internal_engine();
}
inline void OperatorDef::set_engine(const std::string& value) {
  _internal_set_engine(value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.engine)
}
inline std::string* OperatorDef::mutable_engine() {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.engine)
  return _internal_mutable_engine();
}
inline const std::string& OperatorDef::_internal_engine() const {
  return engine_.GetNoArena();
}
inline void OperatorDef::_internal_set_engine(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  engine_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void OperatorDef::set_engine(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  engine_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.OperatorDef.engine)
}
inline void OperatorDef::set_engine(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  engine_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.engine)
}
inline void OperatorDef::set_engine(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  engine_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.engine)
}
inline std::string* OperatorDef::_internal_mutable_engine() {
  _has_bits_[0] |= 0x00000004u;
  return engine_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* OperatorDef::release_engine() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.engine)
  if (!_internal_has_engine()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return engine_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  engine_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), engine);
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.engine)
}

// repeated string control_input = 8;
inline int OperatorDef::_internal_control_input_size() const {
  return control_input_.size();
}
inline int OperatorDef::control_input_size() const {
  return _internal_control_input_size();
}
inline void OperatorDef::clear_control_input() {
  control_input_.Clear();
}
inline std::string* OperatorDef::add_control_input() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.OperatorDef.control_input)
  return _internal_add_control_input();
}
inline const std::string& OperatorDef::_internal_control_input(int index) const {
  return control_input_.Get(index);
}
inline const std::string& OperatorDef::control_input(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.control_input)
  return _internal_control_input(index);
}
inline std::string* OperatorDef::mutable_control_input(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.control_input)
  return control_input_.Mutable(index);
}
inline void OperatorDef::set_control_input(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.control_input)
  control_input_.Mutable(index)->assign(value);
}
inline void OperatorDef::set_control_input(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.control_input)
  control_input_.Mutable(index)->assign(std::move(value));
}
inline void OperatorDef::set_control_input(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  control_input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.control_input)
}
inline void OperatorDef::set_control_input(int index, const char* value, size_t size) {
  control_input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.control_input)
}
inline std::string* OperatorDef::_internal_add_control_input() {
  return control_input_.Add();
}
inline void OperatorDef::add_control_input(const std::string& value) {
  control_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.control_input)
}
inline void OperatorDef::add_control_input(std::string&& value) {
  control_input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.OperatorDef.control_input)
}
inline void OperatorDef::add_control_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  control_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.OperatorDef.control_input)
}
inline void OperatorDef::add_control_input(const char* value, size_t size) {
  control_input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.OperatorDef.control_input)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OperatorDef::control_input() const {
  // @@protoc_insertion_point(field_list:caffe2.OperatorDef.control_input)
  return control_input_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OperatorDef::mutable_control_input() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.OperatorDef.control_input)
  return &control_input_;
}

// optional bool is_gradient_op = 9 [default = false];
inline bool OperatorDef::_internal_has_is_gradient_op() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool OperatorDef::has_is_gradient_op() const {
  return _internal_has_is_gradient_op();
}
inline void OperatorDef::clear_is_gradient_op() {
  is_gradient_op_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool OperatorDef::_internal_is_gradient_op() const {
  return is_gradient_op_;
}
inline bool OperatorDef::is_gradient_op() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.is_gradient_op)
  return _internal_is_gradient_op();
}
inline void OperatorDef::_internal_set_is_gradient_op(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_gradient_op_ = value;
}
inline void OperatorDef::set_is_gradient_op(bool value) {
  _internal_set_is_gradient_op(value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.is_gradient_op)
}

// optional string debug_info = 10;
inline bool OperatorDef::_internal_has_debug_info() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OperatorDef::has_debug_info() const {
  return _internal_has_debug_info();
}
inline void OperatorDef::clear_debug_info() {
  debug_info_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& OperatorDef::debug_info() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.debug_info)
  return _internal_debug_info();
}
inline void OperatorDef::set_debug_info(const std::string& value) {
  _internal_set_debug_info(value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.debug_info)
}
inline std::string* OperatorDef::mutable_debug_info() {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.debug_info)
  return _internal_mutable_debug_info();
}
inline const std::string& OperatorDef::_internal_debug_info() const {
  return debug_info_.GetNoArena();
}
inline void OperatorDef::_internal_set_debug_info(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  debug_info_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void OperatorDef::set_debug_info(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  debug_info_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.OperatorDef.debug_info)
}
inline void OperatorDef::set_debug_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  debug_info_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.debug_info)
}
inline void OperatorDef::set_debug_info(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  debug_info_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.debug_info)
}
inline std::string* OperatorDef::_internal_mutable_debug_info() {
  _has_bits_[0] |= 0x00000008u;
  return debug_info_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* OperatorDef::release_debug_info() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.debug_info)
  if (!_internal_has_debug_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return debug_info_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_debug_info(std::string* debug_info) {
  if (debug_info != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  debug_info_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), debug_info);
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.debug_info)
}

// optional string domain = 11;
inline bool OperatorDef::_internal_has_domain() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OperatorDef::has_domain() const {
  return _internal_has_domain();
}
inline void OperatorDef::clear_domain() {
  domain_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& OperatorDef::domain() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.domain)
  return _internal_domain();
}
inline void OperatorDef::set_domain(const std::string& value) {
  _internal_set_domain(value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.domain)
}
inline std::string* OperatorDef::mutable_domain() {
  // @@protoc_insertion_point(field_mutable:caffe2.OperatorDef.domain)
  return _internal_mutable_domain();
}
inline const std::string& OperatorDef::_internal_domain() const {
  return domain_.GetNoArena();
}
inline void OperatorDef::_internal_set_domain(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  domain_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void OperatorDef::set_domain(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  domain_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.OperatorDef.domain)
}
inline void OperatorDef::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  domain_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.OperatorDef.domain)
}
inline void OperatorDef::set_domain(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  domain_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.OperatorDef.domain)
}
inline std::string* OperatorDef::_internal_mutable_domain() {
  _has_bits_[0] |= 0x00000010u;
  return domain_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* OperatorDef::release_domain() {
  // @@protoc_insertion_point(field_release:caffe2.OperatorDef.domain)
  if (!_internal_has_domain()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return domain_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void OperatorDef::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  domain_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:caffe2.OperatorDef.domain)
}

// optional int64 op_version = 12;
inline bool OperatorDef::_internal_has_op_version() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OperatorDef::has_op_version() const {
  return _internal_has_op_version();
}
inline void OperatorDef::clear_op_version() {
  op_version_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OperatorDef::_internal_op_version() const {
  return op_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 OperatorDef::op_version() const {
  // @@protoc_insertion_point(field_get:caffe2.OperatorDef.op_version)
  return _internal_op_version();
}
inline void OperatorDef::_internal_set_op_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  op_version_ = value;
}
inline void OperatorDef::set_op_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_op_version(value);
  // @@protoc_insertion_point(field_set:caffe2.OperatorDef.op_version)
}

// -------------------------------------------------------------------

// MapFieldEntry

// required string key = 1;
inline bool MapFieldEntry::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MapFieldEntry::has_key() const {
  return _internal_has_key();
}
inline void MapFieldEntry::clear_key() {
  key_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MapFieldEntry::key() const {
  // @@protoc_insertion_point(field_get:caffe2.MapFieldEntry.key)
  return _internal_key();
}
inline void MapFieldEntry::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:caffe2.MapFieldEntry.key)
}
inline std::string* MapFieldEntry::mutable_key() {
  // @@protoc_insertion_point(field_mutable:caffe2.MapFieldEntry.key)
  return _internal_mutable_key();
}
inline const std::string& MapFieldEntry::_internal_key() const {
  return key_.GetNoArena();
}
inline void MapFieldEntry::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void MapFieldEntry::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.MapFieldEntry.key)
}
inline void MapFieldEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.MapFieldEntry.key)
}
inline void MapFieldEntry::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.MapFieldEntry.key)
}
inline std::string* MapFieldEntry::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* MapFieldEntry::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.MapFieldEntry.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void MapFieldEntry::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.MapFieldEntry.key)
}

// required string val = 2;
inline bool MapFieldEntry::_internal_has_val() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MapFieldEntry::has_val() const {
  return _internal_has_val();
}
inline void MapFieldEntry::clear_val() {
  val_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MapFieldEntry::val() const {
  // @@protoc_insertion_point(field_get:caffe2.MapFieldEntry.val)
  return _internal_val();
}
inline void MapFieldEntry::set_val(const std::string& value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:caffe2.MapFieldEntry.val)
}
inline std::string* MapFieldEntry::mutable_val() {
  // @@protoc_insertion_point(field_mutable:caffe2.MapFieldEntry.val)
  return _internal_mutable_val();
}
inline const std::string& MapFieldEntry::_internal_val() const {
  return val_.GetNoArena();
}
inline void MapFieldEntry::_internal_set_val(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  val_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void MapFieldEntry::set_val(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  val_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.MapFieldEntry.val)
}
inline void MapFieldEntry::set_val(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  val_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.MapFieldEntry.val)
}
inline void MapFieldEntry::set_val(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  val_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.MapFieldEntry.val)
}
inline std::string* MapFieldEntry::_internal_mutable_val() {
  _has_bits_[0] |= 0x00000002u;
  return val_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* MapFieldEntry::release_val() {
  // @@protoc_insertion_point(field_release:caffe2.MapFieldEntry.val)
  if (!_internal_has_val()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return val_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void MapFieldEntry::set_allocated_val(std::string* val) {
  if (val != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  val_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), val);
  // @@protoc_insertion_point(field_set_allocated:caffe2.MapFieldEntry.val)
}

// -------------------------------------------------------------------

// BackendOptions

// required string backend_name = 1;
inline bool BackendOptions::_internal_has_backend_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BackendOptions::has_backend_name() const {
  return _internal_has_backend_name();
}
inline void BackendOptions::clear_backend_name() {
  backend_name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BackendOptions::backend_name() const {
  // @@protoc_insertion_point(field_get:caffe2.BackendOptions.backend_name)
  return _internal_backend_name();
}
inline void BackendOptions::set_backend_name(const std::string& value) {
  _internal_set_backend_name(value);
  // @@protoc_insertion_point(field_set:caffe2.BackendOptions.backend_name)
}
inline std::string* BackendOptions::mutable_backend_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.BackendOptions.backend_name)
  return _internal_mutable_backend_name();
}
inline const std::string& BackendOptions::_internal_backend_name() const {
  return backend_name_.GetNoArena();
}
inline void BackendOptions::_internal_set_backend_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  backend_name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void BackendOptions::set_backend_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  backend_name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.BackendOptions.backend_name)
}
inline void BackendOptions::set_backend_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  backend_name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.BackendOptions.backend_name)
}
inline void BackendOptions::set_backend_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  backend_name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.BackendOptions.backend_name)
}
inline std::string* BackendOptions::_internal_mutable_backend_name() {
  _has_bits_[0] |= 0x00000001u;
  return backend_name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* BackendOptions::release_backend_name() {
  // @@protoc_insertion_point(field_release:caffe2.BackendOptions.backend_name)
  if (!_internal_has_backend_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return backend_name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void BackendOptions::set_allocated_backend_name(std::string* backend_name) {
  if (backend_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  backend_name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), backend_name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.BackendOptions.backend_name)
}

// repeated .caffe2.MapFieldEntry option = 2;
inline int BackendOptions::_internal_option_size() const {
  return option_.size();
}
inline int BackendOptions::option_size() const {
  return _internal_option_size();
}
inline void BackendOptions::clear_option() {
  option_.Clear();
}
inline ::caffe2::MapFieldEntry* BackendOptions::mutable_option(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.BackendOptions.option)
  return option_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::MapFieldEntry >*
BackendOptions::mutable_option() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.BackendOptions.option)
  return &option_;
}
inline const ::caffe2::MapFieldEntry& BackendOptions::_internal_option(int index) const {
  return option_.Get(index);
}
inline const ::caffe2::MapFieldEntry& BackendOptions::option(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.BackendOptions.option)
  return _internal_option(index);
}
inline ::caffe2::MapFieldEntry* BackendOptions::_internal_add_option() {
  return option_.Add();
}
inline ::caffe2::MapFieldEntry* BackendOptions::add_option() {
  // @@protoc_insertion_point(field_add:caffe2.BackendOptions.option)
  return _internal_add_option();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::MapFieldEntry >&
BackendOptions::option() const {
  // @@protoc_insertion_point(field_list:caffe2.BackendOptions.option)
  return option_;
}

// -------------------------------------------------------------------

// PartitionInfo

// required string name = 1;
inline bool PartitionInfo::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PartitionInfo::has_name() const {
  return _internal_has_name();
}
inline void PartitionInfo::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PartitionInfo::name() const {
  // @@protoc_insertion_point(field_get:caffe2.PartitionInfo.name)
  return _internal_name();
}
inline void PartitionInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.PartitionInfo.name)
}
inline std::string* PartitionInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.PartitionInfo.name)
  return _internal_mutable_name();
}
inline const std::string& PartitionInfo::_internal_name() const {
  return name_.GetNoArena();
}
inline void PartitionInfo::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void PartitionInfo::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.PartitionInfo.name)
}
inline void PartitionInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.PartitionInfo.name)
}
inline void PartitionInfo::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.PartitionInfo.name)
}
inline std::string* PartitionInfo::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* PartitionInfo::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.PartitionInfo.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void PartitionInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.PartitionInfo.name)
}

// repeated int32 device_id = 2;
inline int PartitionInfo::_internal_device_id_size() const {
  return device_id_.size();
}
inline int PartitionInfo::device_id_size() const {
  return _internal_device_id_size();
}
inline void PartitionInfo::clear_device_id() {
  device_id_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitionInfo::_internal_device_id(int index) const {
  return device_id_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PartitionInfo::device_id(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.PartitionInfo.device_id)
  return _internal_device_id(index);
}
inline void PartitionInfo::set_device_id(int index, ::PROTOBUF_NAMESPACE_ID::int32 value) {
  device_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:caffe2.PartitionInfo.device_id)
}
inline void PartitionInfo::_internal_add_device_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  device_id_.Add(value);
}
inline void PartitionInfo::add_device_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_add_device_id(value);
  // @@protoc_insertion_point(field_add:caffe2.PartitionInfo.device_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
PartitionInfo::_internal_device_id() const {
  return device_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >&
PartitionInfo::device_id() const {
  // @@protoc_insertion_point(field_list:caffe2.PartitionInfo.device_id)
  return _internal_device_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
PartitionInfo::_internal_mutable_device_id() {
  return &device_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int32 >*
PartitionInfo::mutable_device_id() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.PartitionInfo.device_id)
  return _internal_mutable_device_id();
}

// optional string extra_info = 3;
inline bool PartitionInfo::_internal_has_extra_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PartitionInfo::has_extra_info() const {
  return _internal_has_extra_info();
}
inline void PartitionInfo::clear_extra_info() {
  extra_info_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PartitionInfo::extra_info() const {
  // @@protoc_insertion_point(field_get:caffe2.PartitionInfo.extra_info)
  return _internal_extra_info();
}
inline void PartitionInfo::set_extra_info(const std::string& value) {
  _internal_set_extra_info(value);
  // @@protoc_insertion_point(field_set:caffe2.PartitionInfo.extra_info)
}
inline std::string* PartitionInfo::mutable_extra_info() {
  // @@protoc_insertion_point(field_mutable:caffe2.PartitionInfo.extra_info)
  return _internal_mutable_extra_info();
}
inline const std::string& PartitionInfo::_internal_extra_info() const {
  return extra_info_.GetNoArena();
}
inline void PartitionInfo::_internal_set_extra_info(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  extra_info_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void PartitionInfo::set_extra_info(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  extra_info_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.PartitionInfo.extra_info)
}
inline void PartitionInfo::set_extra_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  extra_info_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.PartitionInfo.extra_info)
}
inline void PartitionInfo::set_extra_info(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  extra_info_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.PartitionInfo.extra_info)
}
inline std::string* PartitionInfo::_internal_mutable_extra_info() {
  _has_bits_[0] |= 0x00000002u;
  return extra_info_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* PartitionInfo::release_extra_info() {
  // @@protoc_insertion_point(field_release:caffe2.PartitionInfo.extra_info)
  if (!_internal_has_extra_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return extra_info_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void PartitionInfo::set_allocated_extra_info(std::string* extra_info) {
  if (extra_info != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  extra_info_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), extra_info);
  // @@protoc_insertion_point(field_set_allocated:caffe2.PartitionInfo.extra_info)
}

// repeated .caffe2.BackendOptions backend_options = 4;
inline int PartitionInfo::_internal_backend_options_size() const {
  return backend_options_.size();
}
inline int PartitionInfo::backend_options_size() const {
  return _internal_backend_options_size();
}
inline void PartitionInfo::clear_backend_options() {
  backend_options_.Clear();
}
inline ::caffe2::BackendOptions* PartitionInfo::mutable_backend_options(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.PartitionInfo.backend_options)
  return backend_options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::BackendOptions >*
PartitionInfo::mutable_backend_options() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.PartitionInfo.backend_options)
  return &backend_options_;
}
inline const ::caffe2::BackendOptions& PartitionInfo::_internal_backend_options(int index) const {
  return backend_options_.Get(index);
}
inline const ::caffe2::BackendOptions& PartitionInfo::backend_options(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.PartitionInfo.backend_options)
  return _internal_backend_options(index);
}
inline ::caffe2::BackendOptions* PartitionInfo::_internal_add_backend_options() {
  return backend_options_.Add();
}
inline ::caffe2::BackendOptions* PartitionInfo::add_backend_options() {
  // @@protoc_insertion_point(field_add:caffe2.PartitionInfo.backend_options)
  return _internal_add_backend_options();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::BackendOptions >&
PartitionInfo::backend_options() const {
  // @@protoc_insertion_point(field_list:caffe2.PartitionInfo.backend_options)
  return backend_options_;
}

// -------------------------------------------------------------------

// NetDef

// optional string name = 1;
inline bool NetDef::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NetDef::has_name() const {
  return _internal_has_name();
}
inline void NetDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NetDef::name() const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.name)
  return _internal_name();
}
inline void NetDef::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.NetDef.name)
}
inline std::string* NetDef::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.name)
  return _internal_mutable_name();
}
inline const std::string& NetDef::_internal_name() const {
  return name_.GetNoArena();
}
inline void NetDef::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void NetDef::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.NetDef.name)
}
inline void NetDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.NetDef.name)
}
inline void NetDef::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetDef.name)
}
inline std::string* NetDef::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* NetDef::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.NetDef.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void NetDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetDef.name)
}

// repeated .caffe2.OperatorDef op = 2;
inline int NetDef::_internal_op_size() const {
  return op_.size();
}
inline int NetDef::op_size() const {
  return _internal_op_size();
}
inline void NetDef::clear_op() {
  op_.Clear();
}
inline ::caffe2::OperatorDef* NetDef::mutable_op(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.op)
  return op_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::OperatorDef >*
NetDef::mutable_op() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.NetDef.op)
  return &op_;
}
inline const ::caffe2::OperatorDef& NetDef::_internal_op(int index) const {
  return op_.Get(index);
}
inline const ::caffe2::OperatorDef& NetDef::op(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.op)
  return _internal_op(index);
}
inline ::caffe2::OperatorDef* NetDef::_internal_add_op() {
  return op_.Add();
}
inline ::caffe2::OperatorDef* NetDef::add_op() {
  // @@protoc_insertion_point(field_add:caffe2.NetDef.op)
  return _internal_add_op();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::OperatorDef >&
NetDef::op() const {
  // @@protoc_insertion_point(field_list:caffe2.NetDef.op)
  return op_;
}

// optional string type = 3;
inline bool NetDef::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NetDef::has_type() const {
  return _internal_has_type();
}
inline void NetDef::clear_type() {
  type_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NetDef::type() const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.type)
  return _internal_type();
}
inline void NetDef::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:caffe2.NetDef.type)
}
inline std::string* NetDef::mutable_type() {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.type)
  return _internal_mutable_type();
}
inline const std::string& NetDef::_internal_type() const {
  return type_.GetNoArena();
}
inline void NetDef::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void NetDef::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.NetDef.type)
}
inline void NetDef::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.NetDef.type)
}
inline void NetDef::set_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetDef.type)
}
inline std::string* NetDef::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  return type_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* NetDef::release_type() {
  // @@protoc_insertion_point(field_release:caffe2.NetDef.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return type_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void NetDef::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetDef.type)
}

// optional int32 num_workers = 4 [deprecated = true];
inline bool NetDef::_internal_has_num_workers() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool NetDef::has_num_workers() const {
  return _internal_has_num_workers();
}
inline void NetDef::clear_num_workers() {
  num_workers_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NetDef::_internal_num_workers() const {
  return num_workers_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 NetDef::num_workers() const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.num_workers)
  return _internal_num_workers();
}
inline void NetDef::_internal_set_num_workers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  num_workers_ = value;
}
inline void NetDef::set_num_workers(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_workers(value);
  // @@protoc_insertion_point(field_set:caffe2.NetDef.num_workers)
}

// optional .caffe2.DeviceOption device_option = 5;
inline bool NetDef::_internal_has_device_option() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || device_option_ != nullptr);
  return value;
}
inline bool NetDef::has_device_option() const {
  return _internal_has_device_option();
}
inline void NetDef::clear_device_option() {
  if (device_option_ != nullptr) device_option_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::caffe2::DeviceOption& NetDef::_internal_device_option() const {
  const ::caffe2::DeviceOption* p = device_option_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::DeviceOption*>(
      &::caffe2::_DeviceOption_default_instance_);
}
inline const ::caffe2::DeviceOption& NetDef::device_option() const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.device_option)
  return _internal_device_option();
}
inline ::caffe2::DeviceOption* NetDef::release_device_option() {
  // @@protoc_insertion_point(field_release:caffe2.NetDef.device_option)
  _has_bits_[0] &= ~0x00000004u;
  ::caffe2::DeviceOption* temp = device_option_;
  device_option_ = nullptr;
  return temp;
}
inline ::caffe2::DeviceOption* NetDef::_internal_mutable_device_option() {
  _has_bits_[0] |= 0x00000004u;
  if (device_option_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::DeviceOption>(GetArenaNoVirtual());
    device_option_ = p;
  }
  return device_option_;
}
inline ::caffe2::DeviceOption* NetDef::mutable_device_option() {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.device_option)
  return _internal_mutable_device_option();
}
inline void NetDef::set_allocated_device_option(::caffe2::DeviceOption* device_option) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete device_option_;
  }
  if (device_option) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      device_option = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_option, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  device_option_ = device_option;
  // @@protoc_insertion_point(field_set_allocated:caffe2.NetDef.device_option)
}

// repeated .caffe2.Argument arg = 6;
inline int NetDef::_internal_arg_size() const {
  return arg_.size();
}
inline int NetDef::arg_size() const {
  return _internal_arg_size();
}
inline void NetDef::clear_arg() {
  arg_.Clear();
}
inline ::caffe2::Argument* NetDef::mutable_arg(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.arg)
  return arg_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::Argument >*
NetDef::mutable_arg() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.NetDef.arg)
  return &arg_;
}
inline const ::caffe2::Argument& NetDef::_internal_arg(int index) const {
  return arg_.Get(index);
}
inline const ::caffe2::Argument& NetDef::arg(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.arg)
  return _internal_arg(index);
}
inline ::caffe2::Argument* NetDef::_internal_add_arg() {
  return arg_.Add();
}
inline ::caffe2::Argument* NetDef::add_arg() {
  // @@protoc_insertion_point(field_add:caffe2.NetDef.arg)
  return _internal_add_arg();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::Argument >&
NetDef::arg() const {
  // @@protoc_insertion_point(field_list:caffe2.NetDef.arg)
  return arg_;
}

// repeated string external_input = 7;
inline int NetDef::_internal_external_input_size() const {
  return external_input_.size();
}
inline int NetDef::external_input_size() const {
  return _internal_external_input_size();
}
inline void NetDef::clear_external_input() {
  external_input_.Clear();
}
inline std::string* NetDef::add_external_input() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.NetDef.external_input)
  return _internal_add_external_input();
}
inline const std::string& NetDef::_internal_external_input(int index) const {
  return external_input_.Get(index);
}
inline const std::string& NetDef::external_input(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.external_input)
  return _internal_external_input(index);
}
inline std::string* NetDef::mutable_external_input(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.external_input)
  return external_input_.Mutable(index);
}
inline void NetDef::set_external_input(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.NetDef.external_input)
  external_input_.Mutable(index)->assign(value);
}
inline void NetDef::set_external_input(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.NetDef.external_input)
  external_input_.Mutable(index)->assign(std::move(value));
}
inline void NetDef::set_external_input(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.NetDef.external_input)
}
inline void NetDef::set_external_input(int index, const char* value, size_t size) {
  external_input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetDef.external_input)
}
inline std::string* NetDef::_internal_add_external_input() {
  return external_input_.Add();
}
inline void NetDef::add_external_input(const std::string& value) {
  external_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.NetDef.external_input)
}
inline void NetDef::add_external_input(std::string&& value) {
  external_input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.NetDef.external_input)
}
inline void NetDef::add_external_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.NetDef.external_input)
}
inline void NetDef::add_external_input(const char* value, size_t size) {
  external_input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.NetDef.external_input)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetDef::external_input() const {
  // @@protoc_insertion_point(field_list:caffe2.NetDef.external_input)
  return external_input_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetDef::mutable_external_input() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.NetDef.external_input)
  return &external_input_;
}

// repeated string external_output = 8;
inline int NetDef::_internal_external_output_size() const {
  return external_output_.size();
}
inline int NetDef::external_output_size() const {
  return _internal_external_output_size();
}
inline void NetDef::clear_external_output() {
  external_output_.Clear();
}
inline std::string* NetDef::add_external_output() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.NetDef.external_output)
  return _internal_add_external_output();
}
inline const std::string& NetDef::_internal_external_output(int index) const {
  return external_output_.Get(index);
}
inline const std::string& NetDef::external_output(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.external_output)
  return _internal_external_output(index);
}
inline std::string* NetDef::mutable_external_output(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.external_output)
  return external_output_.Mutable(index);
}
inline void NetDef::set_external_output(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.NetDef.external_output)
  external_output_.Mutable(index)->assign(value);
}
inline void NetDef::set_external_output(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.NetDef.external_output)
  external_output_.Mutable(index)->assign(std::move(value));
}
inline void NetDef::set_external_output(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.NetDef.external_output)
}
inline void NetDef::set_external_output(int index, const char* value, size_t size) {
  external_output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.NetDef.external_output)
}
inline std::string* NetDef::_internal_add_external_output() {
  return external_output_.Add();
}
inline void NetDef::add_external_output(const std::string& value) {
  external_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.NetDef.external_output)
}
inline void NetDef::add_external_output(std::string&& value) {
  external_output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.NetDef.external_output)
}
inline void NetDef::add_external_output(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  external_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.NetDef.external_output)
}
inline void NetDef::add_external_output(const char* value, size_t size) {
  external_output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.NetDef.external_output)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NetDef::external_output() const {
  // @@protoc_insertion_point(field_list:caffe2.NetDef.external_output)
  return external_output_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NetDef::mutable_external_output() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.NetDef.external_output)
  return &external_output_;
}

// repeated .caffe2.PartitionInfo partition_info = 9;
inline int NetDef::_internal_partition_info_size() const {
  return partition_info_.size();
}
inline int NetDef::partition_info_size() const {
  return _internal_partition_info_size();
}
inline void NetDef::clear_partition_info() {
  partition_info_.Clear();
}
inline ::caffe2::PartitionInfo* NetDef::mutable_partition_info(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.NetDef.partition_info)
  return partition_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::PartitionInfo >*
NetDef::mutable_partition_info() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.NetDef.partition_info)
  return &partition_info_;
}
inline const ::caffe2::PartitionInfo& NetDef::_internal_partition_info(int index) const {
  return partition_info_.Get(index);
}
inline const ::caffe2::PartitionInfo& NetDef::partition_info(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.NetDef.partition_info)
  return _internal_partition_info(index);
}
inline ::caffe2::PartitionInfo* NetDef::_internal_add_partition_info() {
  return partition_info_.Add();
}
inline ::caffe2::PartitionInfo* NetDef::add_partition_info() {
  // @@protoc_insertion_point(field_add:caffe2.NetDef.partition_info)
  return _internal_add_partition_info();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::PartitionInfo >&
NetDef::partition_info() const {
  // @@protoc_insertion_point(field_list:caffe2.NetDef.partition_info)
  return partition_info_;
}

// -------------------------------------------------------------------

// ExecutionStep

// optional string name = 1;
inline bool ExecutionStep::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ExecutionStep::has_name() const {
  return _internal_has_name();
}
inline void ExecutionStep::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ExecutionStep::name() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.name)
  return _internal_name();
}
inline void ExecutionStep::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.name)
}
inline std::string* ExecutionStep::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.name)
  return _internal_mutable_name();
}
inline const std::string& ExecutionStep::_internal_name() const {
  return name_.GetNoArena();
}
inline void ExecutionStep::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ExecutionStep::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ExecutionStep.name)
}
inline void ExecutionStep::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ExecutionStep.name)
}
inline void ExecutionStep::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExecutionStep.name)
}
inline std::string* ExecutionStep::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ExecutionStep::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.ExecutionStep.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ExecutionStep::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ExecutionStep.name)
}

// repeated .caffe2.ExecutionStep substep = 2;
inline int ExecutionStep::_internal_substep_size() const {
  return substep_.size();
}
inline int ExecutionStep::substep_size() const {
  return _internal_substep_size();
}
inline void ExecutionStep::clear_substep() {
  substep_.Clear();
}
inline ::caffe2::ExecutionStep* ExecutionStep::mutable_substep(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.substep)
  return substep_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::ExecutionStep >*
ExecutionStep::mutable_substep() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.ExecutionStep.substep)
  return &substep_;
}
inline const ::caffe2::ExecutionStep& ExecutionStep::_internal_substep(int index) const {
  return substep_.Get(index);
}
inline const ::caffe2::ExecutionStep& ExecutionStep::substep(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.substep)
  return _internal_substep(index);
}
inline ::caffe2::ExecutionStep* ExecutionStep::_internal_add_substep() {
  return substep_.Add();
}
inline ::caffe2::ExecutionStep* ExecutionStep::add_substep() {
  // @@protoc_insertion_point(field_add:caffe2.ExecutionStep.substep)
  return _internal_add_substep();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::ExecutionStep >&
ExecutionStep::substep() const {
  // @@protoc_insertion_point(field_list:caffe2.ExecutionStep.substep)
  return substep_;
}

// repeated string network = 3;
inline int ExecutionStep::_internal_network_size() const {
  return network_.size();
}
inline int ExecutionStep::network_size() const {
  return _internal_network_size();
}
inline void ExecutionStep::clear_network() {
  network_.Clear();
}
inline std::string* ExecutionStep::add_network() {
  // @@protoc_insertion_point(field_add_mutable:caffe2.ExecutionStep.network)
  return _internal_add_network();
}
inline const std::string& ExecutionStep::_internal_network(int index) const {
  return network_.Get(index);
}
inline const std::string& ExecutionStep::network(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.network)
  return _internal_network(index);
}
inline std::string* ExecutionStep::mutable_network(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.network)
  return network_.Mutable(index);
}
inline void ExecutionStep::set_network(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.network)
  network_.Mutable(index)->assign(value);
}
inline void ExecutionStep::set_network(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.network)
  network_.Mutable(index)->assign(std::move(value));
}
inline void ExecutionStep::set_network(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  network_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:caffe2.ExecutionStep.network)
}
inline void ExecutionStep::set_network(int index, const char* value, size_t size) {
  network_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExecutionStep.network)
}
inline std::string* ExecutionStep::_internal_add_network() {
  return network_.Add();
}
inline void ExecutionStep::add_network(const std::string& value) {
  network_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:caffe2.ExecutionStep.network)
}
inline void ExecutionStep::add_network(std::string&& value) {
  network_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:caffe2.ExecutionStep.network)
}
inline void ExecutionStep::add_network(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  network_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:caffe2.ExecutionStep.network)
}
inline void ExecutionStep::add_network(const char* value, size_t size) {
  network_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:caffe2.ExecutionStep.network)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExecutionStep::network() const {
  // @@protoc_insertion_point(field_list:caffe2.ExecutionStep.network)
  return network_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExecutionStep::mutable_network() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.ExecutionStep.network)
  return &network_;
}

// optional int64 num_iter = 4;
inline bool ExecutionStep::_internal_has_num_iter() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ExecutionStep::has_num_iter() const {
  return _internal_has_num_iter();
}
inline void ExecutionStep::clear_num_iter() {
  num_iter_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExecutionStep::_internal_num_iter() const {
  return num_iter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExecutionStep::num_iter() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.num_iter)
  return _internal_num_iter();
}
inline void ExecutionStep::_internal_set_num_iter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  num_iter_ = value;
}
inline void ExecutionStep::set_num_iter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_iter(value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.num_iter)
}

// optional string criteria_network = 5 [deprecated = true];
inline bool ExecutionStep::_internal_has_criteria_network() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ExecutionStep::has_criteria_network() const {
  return _internal_has_criteria_network();
}
inline void ExecutionStep::clear_criteria_network() {
  criteria_network_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ExecutionStep::criteria_network() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.criteria_network)
  return _internal_criteria_network();
}
inline void ExecutionStep::set_criteria_network(const std::string& value) {
  _internal_set_criteria_network(value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.criteria_network)
}
inline std::string* ExecutionStep::mutable_criteria_network() {
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.criteria_network)
  return _internal_mutable_criteria_network();
}
inline const std::string& ExecutionStep::_internal_criteria_network() const {
  return criteria_network_.GetNoArena();
}
inline void ExecutionStep::_internal_set_criteria_network(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  criteria_network_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ExecutionStep::set_criteria_network(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  criteria_network_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ExecutionStep.criteria_network)
}
inline void ExecutionStep::set_criteria_network(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  criteria_network_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ExecutionStep.criteria_network)
}
inline void ExecutionStep::set_criteria_network(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  criteria_network_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExecutionStep.criteria_network)
}
inline std::string* ExecutionStep::_internal_mutable_criteria_network() {
  _has_bits_[0] |= 0x00000002u;
  return criteria_network_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ExecutionStep::release_criteria_network() {
  // @@protoc_insertion_point(field_release:caffe2.ExecutionStep.criteria_network)
  if (!_internal_has_criteria_network()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return criteria_network_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ExecutionStep::set_allocated_criteria_network(std::string* criteria_network) {
  if (criteria_network != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  criteria_network_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), criteria_network);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ExecutionStep.criteria_network)
}

// optional string report_net = 7;
inline bool ExecutionStep::_internal_has_report_net() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ExecutionStep::has_report_net() const {
  return _internal_has_report_net();
}
inline void ExecutionStep::clear_report_net() {
  report_net_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ExecutionStep::report_net() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.report_net)
  return _internal_report_net();
}
inline void ExecutionStep::set_report_net(const std::string& value) {
  _internal_set_report_net(value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.report_net)
}
inline std::string* ExecutionStep::mutable_report_net() {
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.report_net)
  return _internal_mutable_report_net();
}
inline const std::string& ExecutionStep::_internal_report_net() const {
  return report_net_.GetNoArena();
}
inline void ExecutionStep::_internal_set_report_net(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  report_net_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ExecutionStep::set_report_net(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  report_net_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ExecutionStep.report_net)
}
inline void ExecutionStep::set_report_net(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  report_net_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ExecutionStep.report_net)
}
inline void ExecutionStep::set_report_net(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  report_net_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExecutionStep.report_net)
}
inline std::string* ExecutionStep::_internal_mutable_report_net() {
  _has_bits_[0] |= 0x00000004u;
  return report_net_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ExecutionStep::release_report_net() {
  // @@protoc_insertion_point(field_release:caffe2.ExecutionStep.report_net)
  if (!_internal_has_report_net()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return report_net_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ExecutionStep::set_allocated_report_net(std::string* report_net) {
  if (report_net != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  report_net_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), report_net);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ExecutionStep.report_net)
}

// optional int32 report_interval = 8;
inline bool ExecutionStep::_internal_has_report_interval() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ExecutionStep::has_report_interval() const {
  return _internal_has_report_interval();
}
inline void ExecutionStep::clear_report_interval() {
  report_interval_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExecutionStep::_internal_report_interval() const {
  return report_interval_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExecutionStep::report_interval() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.report_interval)
  return _internal_report_interval();
}
inline void ExecutionStep::_internal_set_report_interval(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  report_interval_ = value;
}
inline void ExecutionStep::set_report_interval(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_report_interval(value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.report_interval)
}

// optional int64 run_every_ms = 11;
inline bool ExecutionStep::_internal_has_run_every_ms() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool ExecutionStep::has_run_every_ms() const {
  return _internal_has_run_every_ms();
}
inline void ExecutionStep::clear_run_every_ms() {
  run_every_ms_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExecutionStep::_internal_run_every_ms() const {
  return run_every_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExecutionStep::run_every_ms() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.run_every_ms)
  return _internal_run_every_ms();
}
inline void ExecutionStep::_internal_set_run_every_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000200u;
  run_every_ms_ = value;
}
inline void ExecutionStep::set_run_every_ms(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_run_every_ms(value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.run_every_ms)
}

// optional bool concurrent_substeps = 6;
inline bool ExecutionStep::_internal_has_concurrent_substeps() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ExecutionStep::has_concurrent_substeps() const {
  return _internal_has_concurrent_substeps();
}
inline void ExecutionStep::clear_concurrent_substeps() {
  concurrent_substeps_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ExecutionStep::_internal_concurrent_substeps() const {
  return concurrent_substeps_;
}
inline bool ExecutionStep::concurrent_substeps() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.concurrent_substeps)
  return _internal_concurrent_substeps();
}
inline void ExecutionStep::_internal_set_concurrent_substeps(bool value) {
  _has_bits_[0] |= 0x00000040u;
  concurrent_substeps_ = value;
}
inline void ExecutionStep::set_concurrent_substeps(bool value) {
  _internal_set_concurrent_substeps(value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.concurrent_substeps)
}

// optional string should_stop_blob = 9;
inline bool ExecutionStep::_internal_has_should_stop_blob() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ExecutionStep::has_should_stop_blob() const {
  return _internal_has_should_stop_blob();
}
inline void ExecutionStep::clear_should_stop_blob() {
  should_stop_blob_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ExecutionStep::should_stop_blob() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.should_stop_blob)
  return _internal_should_stop_blob();
}
inline void ExecutionStep::set_should_stop_blob(const std::string& value) {
  _internal_set_should_stop_blob(value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.should_stop_blob)
}
inline std::string* ExecutionStep::mutable_should_stop_blob() {
  // @@protoc_insertion_point(field_mutable:caffe2.ExecutionStep.should_stop_blob)
  return _internal_mutable_should_stop_blob();
}
inline const std::string& ExecutionStep::_internal_should_stop_blob() const {
  return should_stop_blob_.GetNoArena();
}
inline void ExecutionStep::_internal_set_should_stop_blob(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  should_stop_blob_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ExecutionStep::set_should_stop_blob(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  should_stop_blob_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.ExecutionStep.should_stop_blob)
}
inline void ExecutionStep::set_should_stop_blob(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  should_stop_blob_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.ExecutionStep.should_stop_blob)
}
inline void ExecutionStep::set_should_stop_blob(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  should_stop_blob_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.ExecutionStep.should_stop_blob)
}
inline std::string* ExecutionStep::_internal_mutable_should_stop_blob() {
  _has_bits_[0] |= 0x00000008u;
  return should_stop_blob_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ExecutionStep::release_should_stop_blob() {
  // @@protoc_insertion_point(field_release:caffe2.ExecutionStep.should_stop_blob)
  if (!_internal_has_should_stop_blob()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return should_stop_blob_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ExecutionStep::set_allocated_should_stop_blob(std::string* should_stop_blob) {
  if (should_stop_blob != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  should_stop_blob_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), should_stop_blob);
  // @@protoc_insertion_point(field_set_allocated:caffe2.ExecutionStep.should_stop_blob)
}

// optional bool only_once = 10;
inline bool ExecutionStep::_internal_has_only_once() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool ExecutionStep::has_only_once() const {
  return _internal_has_only_once();
}
inline void ExecutionStep::clear_only_once() {
  only_once_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ExecutionStep::_internal_only_once() const {
  return only_once_;
}
inline bool ExecutionStep::only_once() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.only_once)
  return _internal_only_once();
}
inline void ExecutionStep::_internal_set_only_once(bool value) {
  _has_bits_[0] |= 0x00000080u;
  only_once_ = value;
}
inline void ExecutionStep::set_only_once(bool value) {
  _internal_set_only_once(value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.only_once)
}

// optional bool create_workspace = 12;
inline bool ExecutionStep::_internal_has_create_workspace() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ExecutionStep::has_create_workspace() const {
  return _internal_has_create_workspace();
}
inline void ExecutionStep::clear_create_workspace() {
  create_workspace_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ExecutionStep::_internal_create_workspace() const {
  return create_workspace_;
}
inline bool ExecutionStep::create_workspace() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.create_workspace)
  return _internal_create_workspace();
}
inline void ExecutionStep::_internal_set_create_workspace(bool value) {
  _has_bits_[0] |= 0x00000100u;
  create_workspace_ = value;
}
inline void ExecutionStep::set_create_workspace(bool value) {
  _internal_set_create_workspace(value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.create_workspace)
}

// optional int32 num_concurrent_instances = 13;
inline bool ExecutionStep::_internal_has_num_concurrent_instances() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ExecutionStep::has_num_concurrent_instances() const {
  return _internal_has_num_concurrent_instances();
}
inline void ExecutionStep::clear_num_concurrent_instances() {
  num_concurrent_instances_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExecutionStep::_internal_num_concurrent_instances() const {
  return num_concurrent_instances_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ExecutionStep::num_concurrent_instances() const {
  // @@protoc_insertion_point(field_get:caffe2.ExecutionStep.num_concurrent_instances)
  return _internal_num_concurrent_instances();
}
inline void ExecutionStep::_internal_set_num_concurrent_instances(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000400u;
  num_concurrent_instances_ = value;
}
inline void ExecutionStep::set_num_concurrent_instances(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_num_concurrent_instances(value);
  // @@protoc_insertion_point(field_set:caffe2.ExecutionStep.num_concurrent_instances)
}

// -------------------------------------------------------------------

// PlanDef

// optional string name = 1;
inline bool PlanDef::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PlanDef::has_name() const {
  return _internal_has_name();
}
inline void PlanDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PlanDef::name() const {
  // @@protoc_insertion_point(field_get:caffe2.PlanDef.name)
  return _internal_name();
}
inline void PlanDef::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.PlanDef.name)
}
inline std::string* PlanDef::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.PlanDef.name)
  return _internal_mutable_name();
}
inline const std::string& PlanDef::_internal_name() const {
  return name_.GetNoArena();
}
inline void PlanDef::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void PlanDef::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.PlanDef.name)
}
inline void PlanDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.PlanDef.name)
}
inline void PlanDef::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.PlanDef.name)
}
inline std::string* PlanDef::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* PlanDef::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.PlanDef.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void PlanDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.PlanDef.name)
}

// repeated .caffe2.NetDef network = 2;
inline int PlanDef::_internal_network_size() const {
  return network_.size();
}
inline int PlanDef::network_size() const {
  return _internal_network_size();
}
inline void PlanDef::clear_network() {
  network_.Clear();
}
inline ::caffe2::NetDef* PlanDef::mutable_network(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.PlanDef.network)
  return network_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >*
PlanDef::mutable_network() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.PlanDef.network)
  return &network_;
}
inline const ::caffe2::NetDef& PlanDef::_internal_network(int index) const {
  return network_.Get(index);
}
inline const ::caffe2::NetDef& PlanDef::network(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.PlanDef.network)
  return _internal_network(index);
}
inline ::caffe2::NetDef* PlanDef::_internal_add_network() {
  return network_.Add();
}
inline ::caffe2::NetDef* PlanDef::add_network() {
  // @@protoc_insertion_point(field_add:caffe2.PlanDef.network)
  return _internal_add_network();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >&
PlanDef::network() const {
  // @@protoc_insertion_point(field_list:caffe2.PlanDef.network)
  return network_;
}

// repeated .caffe2.ExecutionStep execution_step = 3;
inline int PlanDef::_internal_execution_step_size() const {
  return execution_step_.size();
}
inline int PlanDef::execution_step_size() const {
  return _internal_execution_step_size();
}
inline void PlanDef::clear_execution_step() {
  execution_step_.Clear();
}
inline ::caffe2::ExecutionStep* PlanDef::mutable_execution_step(int index) {
  // @@protoc_insertion_point(field_mutable:caffe2.PlanDef.execution_step)
  return execution_step_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::ExecutionStep >*
PlanDef::mutable_execution_step() {
  // @@protoc_insertion_point(field_mutable_list:caffe2.PlanDef.execution_step)
  return &execution_step_;
}
inline const ::caffe2::ExecutionStep& PlanDef::_internal_execution_step(int index) const {
  return execution_step_.Get(index);
}
inline const ::caffe2::ExecutionStep& PlanDef::execution_step(int index) const {
  // @@protoc_insertion_point(field_get:caffe2.PlanDef.execution_step)
  return _internal_execution_step(index);
}
inline ::caffe2::ExecutionStep* PlanDef::_internal_add_execution_step() {
  return execution_step_.Add();
}
inline ::caffe2::ExecutionStep* PlanDef::add_execution_step() {
  // @@protoc_insertion_point(field_add:caffe2.PlanDef.execution_step)
  return _internal_add_execution_step();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::ExecutionStep >&
PlanDef::execution_step() const {
  // @@protoc_insertion_point(field_list:caffe2.PlanDef.execution_step)
  return execution_step_;
}

// -------------------------------------------------------------------

// BlobProto

// optional string name = 1;
inline bool BlobProto::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BlobProto::has_name() const {
  return _internal_has_name();
}
inline void BlobProto::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BlobProto::name() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.name)
  return _internal_name();
}
inline void BlobProto::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.BlobProto.name)
}
inline std::string* BlobProto::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.BlobProto.name)
  return _internal_mutable_name();
}
inline const std::string& BlobProto::_internal_name() const {
  return name_.GetNoArena();
}
inline void BlobProto::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void BlobProto::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.BlobProto.name)
}
inline void BlobProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.BlobProto.name)
}
inline void BlobProto::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobProto.name)
}
inline std::string* BlobProto::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* BlobProto::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.BlobProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void BlobProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobProto.name)
}

// optional string type = 2;
inline bool BlobProto::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BlobProto::has_type() const {
  return _internal_has_type();
}
inline void BlobProto::clear_type() {
  type_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BlobProto::type() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.type)
  return _internal_type();
}
inline void BlobProto::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:caffe2.BlobProto.type)
}
inline std::string* BlobProto::mutable_type() {
  // @@protoc_insertion_point(field_mutable:caffe2.BlobProto.type)
  return _internal_mutable_type();
}
inline const std::string& BlobProto::_internal_type() const {
  return type_.GetNoArena();
}
inline void BlobProto::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void BlobProto::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.BlobProto.type)
}
inline void BlobProto::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.BlobProto.type)
}
inline void BlobProto::set_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobProto.type)
}
inline std::string* BlobProto::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  return type_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* BlobProto::release_type() {
  // @@protoc_insertion_point(field_release:caffe2.BlobProto.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return type_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void BlobProto::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobProto.type)
}

// optional .caffe2.TensorProto tensor = 3;
inline bool BlobProto::_internal_has_tensor() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || tensor_ != nullptr);
  return value;
}
inline bool BlobProto::has_tensor() const {
  return _internal_has_tensor();
}
inline void BlobProto::clear_tensor() {
  if (tensor_ != nullptr) tensor_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::caffe2::TensorProto& BlobProto::_internal_tensor() const {
  const ::caffe2::TensorProto* p = tensor_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::TensorProto*>(
      &::caffe2::_TensorProto_default_instance_);
}
inline const ::caffe2::TensorProto& BlobProto::tensor() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.tensor)
  return _internal_tensor();
}
inline ::caffe2::TensorProto* BlobProto::release_tensor() {
  // @@protoc_insertion_point(field_release:caffe2.BlobProto.tensor)
  _has_bits_[0] &= ~0x00000008u;
  ::caffe2::TensorProto* temp = tensor_;
  tensor_ = nullptr;
  return temp;
}
inline ::caffe2::TensorProto* BlobProto::_internal_mutable_tensor() {
  _has_bits_[0] |= 0x00000008u;
  if (tensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::TensorProto>(GetArenaNoVirtual());
    tensor_ = p;
  }
  return tensor_;
}
inline ::caffe2::TensorProto* BlobProto::mutable_tensor() {
  // @@protoc_insertion_point(field_mutable:caffe2.BlobProto.tensor)
  return _internal_mutable_tensor();
}
inline void BlobProto::set_allocated_tensor(::caffe2::TensorProto* tensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tensor_;
  }
  if (tensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tensor, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  tensor_ = tensor;
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobProto.tensor)
}

// optional bytes content = 4;
inline bool BlobProto::_internal_has_content() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BlobProto::has_content() const {
  return _internal_has_content();
}
inline void BlobProto::clear_content() {
  content_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& BlobProto::content() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.content)
  return _internal_content();
}
inline void BlobProto::set_content(const std::string& value) {
  _internal_set_content(value);
  // @@protoc_insertion_point(field_set:caffe2.BlobProto.content)
}
inline std::string* BlobProto::mutable_content() {
  // @@protoc_insertion_point(field_mutable:caffe2.BlobProto.content)
  return _internal_mutable_content();
}
inline const std::string& BlobProto::_internal_content() const {
  return content_.GetNoArena();
}
inline void BlobProto::_internal_set_content(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  content_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void BlobProto::set_content(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  content_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.BlobProto.content)
}
inline void BlobProto::set_content(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  content_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.BlobProto.content)
}
inline void BlobProto::set_content(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  content_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.BlobProto.content)
}
inline std::string* BlobProto::_internal_mutable_content() {
  _has_bits_[0] |= 0x00000004u;
  return content_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* BlobProto::release_content() {
  // @@protoc_insertion_point(field_release:caffe2.BlobProto.content)
  if (!_internal_has_content()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return content_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void BlobProto::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  content_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobProto.content)
}

// optional .caffe2.QTensorProto qtensor = 5;
inline bool BlobProto::_internal_has_qtensor() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || qtensor_ != nullptr);
  return value;
}
inline bool BlobProto::has_qtensor() const {
  return _internal_has_qtensor();
}
inline void BlobProto::clear_qtensor() {
  if (qtensor_ != nullptr) qtensor_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::caffe2::QTensorProto& BlobProto::_internal_qtensor() const {
  const ::caffe2::QTensorProto* p = qtensor_;
  return p != nullptr ? *p : *reinterpret_cast<const ::caffe2::QTensorProto*>(
      &::caffe2::_QTensorProto_default_instance_);
}
inline const ::caffe2::QTensorProto& BlobProto::qtensor() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.qtensor)
  return _internal_qtensor();
}
inline ::caffe2::QTensorProto* BlobProto::release_qtensor() {
  // @@protoc_insertion_point(field_release:caffe2.BlobProto.qtensor)
  _has_bits_[0] &= ~0x00000010u;
  ::caffe2::QTensorProto* temp = qtensor_;
  qtensor_ = nullptr;
  return temp;
}
inline ::caffe2::QTensorProto* BlobProto::_internal_mutable_qtensor() {
  _has_bits_[0] |= 0x00000010u;
  if (qtensor_ == nullptr) {
    auto* p = CreateMaybeMessage<::caffe2::QTensorProto>(GetArenaNoVirtual());
    qtensor_ = p;
  }
  return qtensor_;
}
inline ::caffe2::QTensorProto* BlobProto::mutable_qtensor() {
  // @@protoc_insertion_point(field_mutable:caffe2.BlobProto.qtensor)
  return _internal_mutable_qtensor();
}
inline void BlobProto::set_allocated_qtensor(::caffe2::QTensorProto* qtensor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete qtensor_;
  }
  if (qtensor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      qtensor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, qtensor, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  qtensor_ = qtensor;
  // @@protoc_insertion_point(field_set_allocated:caffe2.BlobProto.qtensor)
}

// optional int32 content_num_chunks = 6;
inline bool BlobProto::_internal_has_content_num_chunks() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BlobProto::has_content_num_chunks() const {
  return _internal_has_content_num_chunks();
}
inline void BlobProto::clear_content_num_chunks() {
  content_num_chunks_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlobProto::_internal_content_num_chunks() const {
  return content_num_chunks_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlobProto::content_num_chunks() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.content_num_chunks)
  return _internal_content_num_chunks();
}
inline void BlobProto::_internal_set_content_num_chunks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  content_num_chunks_ = value;
}
inline void BlobProto::set_content_num_chunks(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_content_num_chunks(value);
  // @@protoc_insertion_point(field_set:caffe2.BlobProto.content_num_chunks)
}

// optional int32 content_chunk_id = 7;
inline bool BlobProto::_internal_has_content_chunk_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool BlobProto::has_content_chunk_id() const {
  return _internal_has_content_chunk_id();
}
inline void BlobProto::clear_content_chunk_id() {
  content_chunk_id_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlobProto::_internal_content_chunk_id() const {
  return content_chunk_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 BlobProto::content_chunk_id() const {
  // @@protoc_insertion_point(field_get:caffe2.BlobProto.content_chunk_id)
  return _internal_content_chunk_id();
}
inline void BlobProto::_internal_set_content_chunk_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  content_chunk_id_ = value;
}
inline void BlobProto::set_content_chunk_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_content_chunk_id(value);
  // @@protoc_insertion_point(field_set:caffe2.BlobProto.content_chunk_id)
}

// -------------------------------------------------------------------

// DBReaderProto

// optional string name = 1;
inline bool DBReaderProto::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DBReaderProto::has_name() const {
  return _internal_has_name();
}
inline void DBReaderProto::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DBReaderProto::name() const {
  // @@protoc_insertion_point(field_get:caffe2.DBReaderProto.name)
  return _internal_name();
}
inline void DBReaderProto::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:caffe2.DBReaderProto.name)
}
inline std::string* DBReaderProto::mutable_name() {
  // @@protoc_insertion_point(field_mutable:caffe2.DBReaderProto.name)
  return _internal_mutable_name();
}
inline const std::string& DBReaderProto::_internal_name() const {
  return name_.GetNoArena();
}
inline void DBReaderProto::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void DBReaderProto::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.DBReaderProto.name)
}
inline void DBReaderProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.DBReaderProto.name)
}
inline void DBReaderProto::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.DBReaderProto.name)
}
inline std::string* DBReaderProto::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* DBReaderProto::release_name() {
  // @@protoc_insertion_point(field_release:caffe2.DBReaderProto.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void DBReaderProto::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:caffe2.DBReaderProto.name)
}

// optional string source = 2;
inline bool DBReaderProto::_internal_has_source() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DBReaderProto::has_source() const {
  return _internal_has_source();
}
inline void DBReaderProto::clear_source() {
  source_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DBReaderProto::source() const {
  // @@protoc_insertion_point(field_get:caffe2.DBReaderProto.source)
  return _internal_source();
}
inline void DBReaderProto::set_source(const std::string& value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:caffe2.DBReaderProto.source)
}
inline std::string* DBReaderProto::mutable_source() {
  // @@protoc_insertion_point(field_mutable:caffe2.DBReaderProto.source)
  return _internal_mutable_source();
}
inline const std::string& DBReaderProto::_internal_source() const {
  return source_.GetNoArena();
}
inline void DBReaderProto::_internal_set_source(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void DBReaderProto::set_source(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.DBReaderProto.source)
}
inline void DBReaderProto::set_source(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.DBReaderProto.source)
}
inline void DBReaderProto::set_source(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  source_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.DBReaderProto.source)
}
inline std::string* DBReaderProto::_internal_mutable_source() {
  _has_bits_[0] |= 0x00000002u;
  return source_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* DBReaderProto::release_source() {
  // @@protoc_insertion_point(field_release:caffe2.DBReaderProto.source)
  if (!_internal_has_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return source_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void DBReaderProto::set_allocated_source(std::string* source) {
  if (source != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  source_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:caffe2.DBReaderProto.source)
}

// optional string db_type = 3;
inline bool DBReaderProto::_internal_has_db_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DBReaderProto::has_db_type() const {
  return _internal_has_db_type();
}
inline void DBReaderProto::clear_db_type() {
  db_type_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DBReaderProto::db_type() const {
  // @@protoc_insertion_point(field_get:caffe2.DBReaderProto.db_type)
  return _internal_db_type();
}
inline void DBReaderProto::set_db_type(const std::string& value) {
  _internal_set_db_type(value);
  // @@protoc_insertion_point(field_set:caffe2.DBReaderProto.db_type)
}
inline std::string* DBReaderProto::mutable_db_type() {
  // @@protoc_insertion_point(field_mutable:caffe2.DBReaderProto.db_type)
  return _internal_mutable_db_type();
}
inline const std::string& DBReaderProto::_internal_db_type() const {
  return db_type_.GetNoArena();
}
inline void DBReaderProto::_internal_set_db_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  db_type_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void DBReaderProto::set_db_type(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  db_type_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.DBReaderProto.db_type)
}
inline void DBReaderProto::set_db_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  db_type_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.DBReaderProto.db_type)
}
inline void DBReaderProto::set_db_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  db_type_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.DBReaderProto.db_type)
}
inline std::string* DBReaderProto::_internal_mutable_db_type() {
  _has_bits_[0] |= 0x00000004u;
  return db_type_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* DBReaderProto::release_db_type() {
  // @@protoc_insertion_point(field_release:caffe2.DBReaderProto.db_type)
  if (!_internal_has_db_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return db_type_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void DBReaderProto::set_allocated_db_type(std::string* db_type) {
  if (db_type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  db_type_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), db_type);
  // @@protoc_insertion_point(field_set_allocated:caffe2.DBReaderProto.db_type)
}

// optional string key = 4;
inline bool DBReaderProto::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DBReaderProto::has_key() const {
  return _internal_has_key();
}
inline void DBReaderProto::clear_key() {
  key_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DBReaderProto::key() const {
  // @@protoc_insertion_point(field_get:caffe2.DBReaderProto.key)
  return _internal_key();
}
inline void DBReaderProto::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:caffe2.DBReaderProto.key)
}
inline std::string* DBReaderProto::mutable_key() {
  // @@protoc_insertion_point(field_mutable:caffe2.DBReaderProto.key)
  return _internal_mutable_key();
}
inline const std::string& DBReaderProto::_internal_key() const {
  return key_.GetNoArena();
}
inline void DBReaderProto::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void DBReaderProto::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  key_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:caffe2.DBReaderProto.key)
}
inline void DBReaderProto::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:caffe2.DBReaderProto.key)
}
inline void DBReaderProto::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:caffe2.DBReaderProto.key)
}
inline std::string* DBReaderProto::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000008u;
  return key_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* DBReaderProto::release_key() {
  // @@protoc_insertion_point(field_release:caffe2.DBReaderProto.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return key_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void DBReaderProto::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  key_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:caffe2.DBReaderProto.key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace caffe2

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::caffe2::ExternalDataProto_SourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffe2::ExternalDataProto_SourceType>() {
  return ::caffe2::ExternalDataProto_SourceType_descriptor();
}
template <> struct is_proto_enum< ::caffe2::TensorProto_DataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffe2::TensorProto_DataType>() {
  return ::caffe2::TensorProto_DataType_descriptor();
}
template <> struct is_proto_enum< ::caffe2::TensorProto_StorageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffe2::TensorProto_StorageType>() {
  return ::caffe2::TensorProto_StorageType_descriptor();
}
template <> struct is_proto_enum< ::caffe2::TensorBoundShape_DimType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffe2::TensorBoundShape_DimType>() {
  return ::caffe2::TensorBoundShape_DimType_descriptor();
}
template <> struct is_proto_enum< ::caffe2::DeviceTypeProto> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::caffe2::DeviceTypeProto>() {
  return ::caffe2::DeviceTypeProto_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_caffe2_2fproto_2fcaffe2_2eproto
