// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: caffe2/proto/torch.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_caffe2_2fproto_2ftorch_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_caffe2_2fproto_2ftorch_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "caffe2/proto/caffe2.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_caffe2_2fproto_2ftorch_2eproto CAFFE2_API
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct CAFFE2_API TableStruct_caffe2_2fproto_2ftorch_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern CAFFE2_API const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_caffe2_2fproto_2ftorch_2eproto;
namespace torch { const ::std::string& GetEmptyStringAlreadyInited(); 
class AttributeDef;
class AttributeDefDefaultTypeInternal;
CAFFE2_API extern AttributeDefDefaultTypeInternal _AttributeDef_default_instance_;
class LibDef;
class LibDefDefaultTypeInternal;
CAFFE2_API extern LibDefDefaultTypeInternal _LibDef_default_instance_;
class ModelDef;
class ModelDefDefaultTypeInternal;
CAFFE2_API extern ModelDefDefaultTypeInternal _ModelDef_default_instance_;
class ModuleDef;
class ModuleDefDefaultTypeInternal;
CAFFE2_API extern ModuleDefDefaultTypeInternal _ModuleDef_default_instance_;
class ParameterDef;
class ParameterDefDefaultTypeInternal;
CAFFE2_API extern ParameterDefDefaultTypeInternal _ParameterDef_default_instance_;
class RecordRef;
class RecordRefDefaultTypeInternal;
CAFFE2_API extern RecordRefDefaultTypeInternal _RecordRef_default_instance_;
class TensorDef;
class TensorDefDefaultTypeInternal;
CAFFE2_API extern TensorDefDefaultTypeInternal _TensorDef_default_instance_;
}  // namespace torch
PROTOBUF_NAMESPACE_OPEN
template<> CAFFE2_API ::torch::AttributeDef* Arena::CreateMaybeMessage<::torch::AttributeDef>(Arena*);
template<> CAFFE2_API ::torch::LibDef* Arena::CreateMaybeMessage<::torch::LibDef>(Arena*);
template<> CAFFE2_API ::torch::ModelDef* Arena::CreateMaybeMessage<::torch::ModelDef>(Arena*);
template<> CAFFE2_API ::torch::ModuleDef* Arena::CreateMaybeMessage<::torch::ModuleDef>(Arena*);
template<> CAFFE2_API ::torch::ParameterDef* Arena::CreateMaybeMessage<::torch::ParameterDef>(Arena*);
template<> CAFFE2_API ::torch::RecordRef* Arena::CreateMaybeMessage<::torch::RecordRef>(Arena*);
template<> CAFFE2_API ::torch::TensorDef* Arena::CreateMaybeMessage<::torch::TensorDef>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace torch {

enum ProtoVersion : int {
  PROTO_VERSION_NEWEST = 6
};
CAFFE2_API bool ProtoVersion_IsValid(int value);
constexpr ProtoVersion ProtoVersion_MIN = PROTO_VERSION_NEWEST;
constexpr ProtoVersion ProtoVersion_MAX = PROTO_VERSION_NEWEST;
constexpr int ProtoVersion_ARRAYSIZE = ProtoVersion_MAX + 1;

CAFFE2_API const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProtoVersion_descriptor();
template<typename T>
inline const std::string& ProtoVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProtoVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProtoVersion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProtoVersion_descriptor(), enum_t_value);
}
inline bool ProtoVersion_Parse(
    const std::string& name, ProtoVersion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProtoVersion>(
    ProtoVersion_descriptor(), name, value);
}
// ===================================================================

class CAFFE2_API RecordRef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:torch.RecordRef) */ {
 public:
  RecordRef();
  virtual ~RecordRef();

  RecordRef(const RecordRef& from);
  RecordRef(RecordRef&& from) noexcept
    : RecordRef() {
    *this = ::std::move(from);
  }

  inline RecordRef& operator=(const RecordRef& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecordRef& operator=(RecordRef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RecordRef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RecordRef* internal_default_instance() {
    return reinterpret_cast<const RecordRef*>(
               &_RecordRef_default_instance_);
  }
  static int const kIndexInFileMessages =
    0;

  friend void swap(RecordRef& a, RecordRef& b) {
    a.Swap(&b);
  }
  inline void Swap(RecordRef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RecordRef* New() const final {
    return CreateMaybeMessage<RecordRef>(nullptr);
  }

  RecordRef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RecordRef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RecordRef& from);
  void MergeFrom(const RecordRef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecordRef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "torch.RecordRef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2ftorch_2eproto);
    return ::descriptor_table_caffe2_2fproto_2ftorch_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:torch.RecordRef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  friend struct ::TableStruct_caffe2_2fproto_2ftorch_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API TensorDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:torch.TensorDef) */ {
 public:
  TensorDef();
  virtual ~TensorDef();

  TensorDef(const TensorDef& from);
  TensorDef(TensorDef&& from) noexcept
    : TensorDef() {
    *this = ::std::move(from);
  }

  inline TensorDef& operator=(const TensorDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline TensorDef& operator=(TensorDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TensorDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorDef* internal_default_instance() {
    return reinterpret_cast<const TensorDef*>(
               &_TensorDef_default_instance_);
  }
  static int const kIndexInFileMessages =
    1;

  friend void swap(TensorDef& a, TensorDef& b) {
    a.Swap(&b);
  }
  inline void Swap(TensorDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TensorDef* New() const final {
    return CreateMaybeMessage<TensorDef>(nullptr);
  }

  TensorDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TensorDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TensorDef& from);
  void MergeFrom(const TensorDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "torch.TensorDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2ftorch_2eproto);
    return ::descriptor_table_caffe2_2fproto_2ftorch_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 1,
    kStridesFieldNumber = 3,
    kDeviceFieldNumber = 7,
    kDataFieldNumber = 6,
    kOffsetFieldNumber = 2,
    kDataTypeFieldNumber = 5,
    kRequiresGradFieldNumber = 4,
    kIsQuantizedFieldNumber = 8,
    kScaleFieldNumber = 9,
    kZeroPointFieldNumber = 10,
  };
  // repeated int64 dims = 1;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_dims() const;
  void _internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_dims();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 dims(int index) const;
  void set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_dims(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_dims();

  // repeated int64 strides = 3;
  int strides_size() const;
  private:
  int _internal_strides_size() const;
  public:
  void clear_strides();
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_strides(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      _internal_strides() const;
  void _internal_add_strides(::PROTOBUF_NAMESPACE_ID::int64 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      _internal_mutable_strides();
  public:
  ::PROTOBUF_NAMESPACE_ID::int64 strides(int index) const;
  void set_strides(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_strides(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      strides() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_strides();

  // optional string device = 7;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const std::string& device() const;
  void set_device(const std::string& value);
  void set_device(std::string&& value);
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  std::string* mutable_device();
  std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // optional .torch.RecordRef data = 6;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::torch::RecordRef& data() const;
  ::torch::RecordRef* release_data();
  ::torch::RecordRef* mutable_data();
  void set_allocated_data(::torch::RecordRef* data);
  private:
  const ::torch::RecordRef& _internal_data() const;
  ::torch::RecordRef* _internal_mutable_data();
  public:

  // optional int64 offset = 2;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_offset() const;
  void _internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional .caffe2.TensorProto.DataType data_type = 5;
  bool has_data_type() const;
  private:
  bool _internal_has_data_type() const;
  public:
  void clear_data_type();
  ::caffe2::TensorProto_DataType data_type() const;
  void set_data_type(::caffe2::TensorProto_DataType value);
  private:
  ::caffe2::TensorProto_DataType _internal_data_type() const;
  void _internal_set_data_type(::caffe2::TensorProto_DataType value);
  public:

  // optional bool requires_grad = 4;
  bool has_requires_grad() const;
  private:
  bool _internal_has_requires_grad() const;
  public:
  void clear_requires_grad();
  bool requires_grad() const;
  void set_requires_grad(bool value);
  private:
  bool _internal_requires_grad() const;
  void _internal_set_requires_grad(bool value);
  public:

  // optional bool is_quantized = 8;
  bool has_is_quantized() const;
  private:
  bool _internal_has_is_quantized() const;
  public:
  void clear_is_quantized();
  bool is_quantized() const;
  void set_is_quantized(bool value);
  private:
  bool _internal_is_quantized() const;
  void _internal_set_is_quantized(bool value);
  public:

  // optional double scale = 9;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  double scale() const;
  void set_scale(double value);
  private:
  double _internal_scale() const;
  void _internal_set_scale(double value);
  public:

  // optional int64 zero_point = 10;
  bool has_zero_point() const;
  private:
  bool _internal_has_zero_point() const;
  public:
  void clear_zero_point();
  ::PROTOBUF_NAMESPACE_ID::int64 zero_point() const;
  void set_zero_point(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_zero_point() const;
  void _internal_set_zero_point(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:torch.TensorDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > dims_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > strides_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
  ::torch::RecordRef* data_;
  ::PROTOBUF_NAMESPACE_ID::int64 offset_;
  int data_type_;
  bool requires_grad_;
  bool is_quantized_;
  double scale_;
  ::PROTOBUF_NAMESPACE_ID::int64 zero_point_;
  friend struct ::TableStruct_caffe2_2fproto_2ftorch_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API AttributeDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:torch.AttributeDef) */ {
 public:
  AttributeDef();
  virtual ~AttributeDef();

  AttributeDef(const AttributeDef& from);
  AttributeDef(AttributeDef&& from) noexcept
    : AttributeDef() {
    *this = ::std::move(from);
  }

  inline AttributeDef& operator=(const AttributeDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline AttributeDef& operator=(AttributeDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AttributeDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AttributeDef* internal_default_instance() {
    return reinterpret_cast<const AttributeDef*>(
               &_AttributeDef_default_instance_);
  }
  static int const kIndexInFileMessages =
    2;

  friend void swap(AttributeDef& a, AttributeDef& b) {
    a.Swap(&b);
  }
  inline void Swap(AttributeDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AttributeDef* New() const final {
    return CreateMaybeMessage<AttributeDef>(nullptr);
  }

  AttributeDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AttributeDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AttributeDef& from);
  void MergeFrom(const AttributeDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AttributeDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "torch.AttributeDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2ftorch_2eproto);
    return ::descriptor_table_caffe2_2fproto_2ftorch_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kNameFieldNumber = 2,
    kIdFieldNumber = 3,
  };
  // required string type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // required string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required int64 id = 3;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:torch.AttributeDef)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  friend struct ::TableStruct_caffe2_2fproto_2ftorch_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API ParameterDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:torch.ParameterDef) */ {
 public:
  ParameterDef();
  virtual ~ParameterDef();

  ParameterDef(const ParameterDef& from);
  ParameterDef(ParameterDef&& from) noexcept
    : ParameterDef() {
    *this = ::std::move(from);
  }

  inline ParameterDef& operator=(const ParameterDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParameterDef& operator=(ParameterDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ParameterDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParameterDef* internal_default_instance() {
    return reinterpret_cast<const ParameterDef*>(
               &_ParameterDef_default_instance_);
  }
  static int const kIndexInFileMessages =
    3;

  friend void swap(ParameterDef& a, ParameterDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ParameterDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ParameterDef* New() const final {
    return CreateMaybeMessage<ParameterDef>(nullptr);
  }

  ParameterDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ParameterDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ParameterDef& from);
  void MergeFrom(const ParameterDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParameterDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "torch.ParameterDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2ftorch_2eproto);
    return ::descriptor_table_caffe2_2fproto_2ftorch_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kTensorIdFieldNumber = 2,
    kIsBufferFieldNumber = 1,
  };
  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int64 tensor_id = 2;
  bool has_tensor_id() const;
  private:
  bool _internal_has_tensor_id() const;
  public:
  void clear_tensor_id();
  ::PROTOBUF_NAMESPACE_ID::int64 tensor_id() const;
  void set_tensor_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_tensor_id() const;
  void _internal_set_tensor_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool is_buffer = 1;
  bool has_is_buffer() const;
  private:
  bool _internal_has_is_buffer() const;
  public:
  void clear_is_buffer();
  bool is_buffer() const;
  void set_is_buffer(bool value);
  private:
  bool _internal_is_buffer() const;
  void _internal_set_is_buffer(bool value);
  public:

  // @@protoc_insertion_point(class_scope:torch.ParameterDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 tensor_id_;
  bool is_buffer_;
  friend struct ::TableStruct_caffe2_2fproto_2ftorch_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API ModuleDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:torch.ModuleDef) */ {
 public:
  ModuleDef();
  virtual ~ModuleDef();

  ModuleDef(const ModuleDef& from);
  ModuleDef(ModuleDef&& from) noexcept
    : ModuleDef() {
    *this = ::std::move(from);
  }

  inline ModuleDef& operator=(const ModuleDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModuleDef& operator=(ModuleDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModuleDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModuleDef* internal_default_instance() {
    return reinterpret_cast<const ModuleDef*>(
               &_ModuleDef_default_instance_);
  }
  static int const kIndexInFileMessages =
    4;

  friend void swap(ModuleDef& a, ModuleDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ModuleDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModuleDef* New() const final {
    return CreateMaybeMessage<ModuleDef>(nullptr);
  }

  ModuleDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModuleDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModuleDef& from);
  void MergeFrom(const ModuleDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModuleDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "torch.ModuleDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2ftorch_2eproto);
    return ::descriptor_table_caffe2_2fproto_2ftorch_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubmodulesFieldNumber = 1,
    kCaffe2NetsFieldNumber = 3,
    kParametersFieldNumber = 6,
    kAttributesFieldNumber = 9,
    kNameFieldNumber = 7,
    kTorchscriptArenaFieldNumber = 2,
    kPickleArenaFieldNumber = 4,
    kCppArenaFieldNumber = 5,
    kTorchscriptDebugArenaFieldNumber = 11,
    kGetStateAttributeIdFieldNumber = 10,
    kOptimizeFieldNumber = 8,
  };
  // repeated .torch.ModuleDef submodules = 1;
  int submodules_size() const;
  private:
  int _internal_submodules_size() const;
  public:
  void clear_submodules();
  ::torch::ModuleDef* mutable_submodules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::ModuleDef >*
      mutable_submodules();
  private:
  const ::torch::ModuleDef& _internal_submodules(int index) const;
  ::torch::ModuleDef* _internal_add_submodules();
  public:
  const ::torch::ModuleDef& submodules(int index) const;
  ::torch::ModuleDef* add_submodules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::ModuleDef >&
      submodules() const;

  // repeated .caffe2.NetDef caffe2_nets = 3;
  int caffe2_nets_size() const;
  private:
  int _internal_caffe2_nets_size() const;
  public:
  void clear_caffe2_nets();
  ::caffe2::NetDef* mutable_caffe2_nets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >*
      mutable_caffe2_nets();
  private:
  const ::caffe2::NetDef& _internal_caffe2_nets(int index) const;
  ::caffe2::NetDef* _internal_add_caffe2_nets();
  public:
  const ::caffe2::NetDef& caffe2_nets(int index) const;
  ::caffe2::NetDef* add_caffe2_nets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >&
      caffe2_nets() const;

  // repeated .torch.ParameterDef parameters = 6;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::torch::ParameterDef* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::ParameterDef >*
      mutable_parameters();
  private:
  const ::torch::ParameterDef& _internal_parameters(int index) const;
  ::torch::ParameterDef* _internal_add_parameters();
  public:
  const ::torch::ParameterDef& parameters(int index) const;
  ::torch::ParameterDef* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::ParameterDef >&
      parameters() const;

  // repeated .torch.AttributeDef attributes = 9;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::torch::AttributeDef* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::AttributeDef >*
      mutable_attributes();
  private:
  const ::torch::AttributeDef& _internal_attributes(int index) const;
  ::torch::AttributeDef* _internal_add_attributes();
  public:
  const ::torch::AttributeDef& attributes(int index) const;
  ::torch::AttributeDef* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::AttributeDef >&
      attributes() const;

  // optional string name = 7;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .torch.RecordRef torchscript_arena = 2;
  bool has_torchscript_arena() const;
  private:
  bool _internal_has_torchscript_arena() const;
  public:
  void clear_torchscript_arena();
  const ::torch::RecordRef& torchscript_arena() const;
  ::torch::RecordRef* release_torchscript_arena();
  ::torch::RecordRef* mutable_torchscript_arena();
  void set_allocated_torchscript_arena(::torch::RecordRef* torchscript_arena);
  private:
  const ::torch::RecordRef& _internal_torchscript_arena() const;
  ::torch::RecordRef* _internal_mutable_torchscript_arena();
  public:

  // optional .torch.RecordRef pickle_arena = 4;
  bool has_pickle_arena() const;
  private:
  bool _internal_has_pickle_arena() const;
  public:
  void clear_pickle_arena();
  const ::torch::RecordRef& pickle_arena() const;
  ::torch::RecordRef* release_pickle_arena();
  ::torch::RecordRef* mutable_pickle_arena();
  void set_allocated_pickle_arena(::torch::RecordRef* pickle_arena);
  private:
  const ::torch::RecordRef& _internal_pickle_arena() const;
  ::torch::RecordRef* _internal_mutable_pickle_arena();
  public:

  // optional .torch.RecordRef cpp_arena = 5;
  bool has_cpp_arena() const;
  private:
  bool _internal_has_cpp_arena() const;
  public:
  void clear_cpp_arena();
  const ::torch::RecordRef& cpp_arena() const;
  ::torch::RecordRef* release_cpp_arena();
  ::torch::RecordRef* mutable_cpp_arena();
  void set_allocated_cpp_arena(::torch::RecordRef* cpp_arena);
  private:
  const ::torch::RecordRef& _internal_cpp_arena() const;
  ::torch::RecordRef* _internal_mutable_cpp_arena();
  public:

  // optional .torch.RecordRef torchscript_debug_arena = 11;
  bool has_torchscript_debug_arena() const;
  private:
  bool _internal_has_torchscript_debug_arena() const;
  public:
  void clear_torchscript_debug_arena();
  const ::torch::RecordRef& torchscript_debug_arena() const;
  ::torch::RecordRef* release_torchscript_debug_arena();
  ::torch::RecordRef* mutable_torchscript_debug_arena();
  void set_allocated_torchscript_debug_arena(::torch::RecordRef* torchscript_debug_arena);
  private:
  const ::torch::RecordRef& _internal_torchscript_debug_arena() const;
  ::torch::RecordRef* _internal_mutable_torchscript_debug_arena();
  public:

  // optional int64 get_state_attribute_id = 10;
  bool has_get_state_attribute_id() const;
  private:
  bool _internal_has_get_state_attribute_id() const;
  public:
  void clear_get_state_attribute_id();
  ::PROTOBUF_NAMESPACE_ID::int64 get_state_attribute_id() const;
  void set_get_state_attribute_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_get_state_attribute_id() const;
  void _internal_set_get_state_attribute_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional bool optimize = 8;
  bool has_optimize() const;
  private:
  bool _internal_has_optimize() const;
  public:
  void clear_optimize();
  bool optimize() const;
  void set_optimize(bool value);
  private:
  bool _internal_optimize() const;
  void _internal_set_optimize(bool value);
  public:

  // @@protoc_insertion_point(class_scope:torch.ModuleDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::ModuleDef > submodules_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef > caffe2_nets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::ParameterDef > parameters_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::AttributeDef > attributes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::torch::RecordRef* torchscript_arena_;
  ::torch::RecordRef* pickle_arena_;
  ::torch::RecordRef* cpp_arena_;
  ::torch::RecordRef* torchscript_debug_arena_;
  ::PROTOBUF_NAMESPACE_ID::int64 get_state_attribute_id_;
  bool optimize_;
  friend struct ::TableStruct_caffe2_2fproto_2ftorch_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API LibDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:torch.LibDef) */ {
 public:
  LibDef();
  virtual ~LibDef();

  LibDef(const LibDef& from);
  LibDef(LibDef&& from) noexcept
    : LibDef() {
    *this = ::std::move(from);
  }

  inline LibDef& operator=(const LibDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline LibDef& operator=(LibDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LibDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LibDef* internal_default_instance() {
    return reinterpret_cast<const LibDef*>(
               &_LibDef_default_instance_);
  }
  static int const kIndexInFileMessages =
    5;

  friend void swap(LibDef& a, LibDef& b) {
    a.Swap(&b);
  }
  inline void Swap(LibDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LibDef* New() const final {
    return CreateMaybeMessage<LibDef>(nullptr);
  }

  LibDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LibDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LibDef& from);
  void MergeFrom(const LibDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LibDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "torch.LibDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2ftorch_2eproto);
    return ::descriptor_table_caffe2_2fproto_2ftorch_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTorchscriptArenaFieldNumber = 1,
  };
  // optional .torch.RecordRef torchscript_arena = 1;
  bool has_torchscript_arena() const;
  private:
  bool _internal_has_torchscript_arena() const;
  public:
  void clear_torchscript_arena();
  const ::torch::RecordRef& torchscript_arena() const;
  ::torch::RecordRef* release_torchscript_arena();
  ::torch::RecordRef* mutable_torchscript_arena();
  void set_allocated_torchscript_arena(::torch::RecordRef* torchscript_arena);
  private:
  const ::torch::RecordRef& _internal_torchscript_arena() const;
  ::torch::RecordRef* _internal_mutable_torchscript_arena();
  public:

  // @@protoc_insertion_point(class_scope:torch.LibDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::torch::RecordRef* torchscript_arena_;
  friend struct ::TableStruct_caffe2_2fproto_2ftorch_2eproto;
};
// -------------------------------------------------------------------

class CAFFE2_API ModelDef :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:torch.ModelDef) */ {
 public:
  ModelDef();
  virtual ~ModelDef();

  ModelDef(const ModelDef& from);
  ModelDef(ModelDef&& from) noexcept
    : ModelDef() {
    *this = ::std::move(from);
  }

  inline ModelDef& operator=(const ModelDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelDef& operator=(ModelDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ModelDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelDef* internal_default_instance() {
    return reinterpret_cast<const ModelDef*>(
               &_ModelDef_default_instance_);
  }
  static int const kIndexInFileMessages =
    6;

  friend void swap(ModelDef& a, ModelDef& b) {
    a.Swap(&b);
  }
  inline void Swap(ModelDef* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ModelDef* New() const final {
    return CreateMaybeMessage<ModelDef>(nullptr);
  }

  ModelDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ModelDef>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ModelDef& from);
  void MergeFrom(const ModelDef& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelDef* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "torch.ModelDef";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_caffe2_2fproto_2ftorch_2eproto);
    return ::descriptor_table_caffe2_2fproto_2ftorch_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTensorsFieldNumber = 5,
    kProducerNameFieldNumber = 3,
    kProducerVersionFieldNumber = 4,
    kMainModuleFieldNumber = 2,
    kProtoVersionFieldNumber = 1,
  };
  // repeated .torch.TensorDef tensors = 5;
  int tensors_size() const;
  private:
  int _internal_tensors_size() const;
  public:
  void clear_tensors();
  ::torch::TensorDef* mutable_tensors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::TensorDef >*
      mutable_tensors();
  private:
  const ::torch::TensorDef& _internal_tensors(int index) const;
  ::torch::TensorDef* _internal_add_tensors();
  public:
  const ::torch::TensorDef& tensors(int index) const;
  ::torch::TensorDef* add_tensors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::TensorDef >&
      tensors() const;

  // optional string producer_name = 3;
  bool has_producer_name() const;
  private:
  bool _internal_has_producer_name() const;
  public:
  void clear_producer_name();
  const std::string& producer_name() const;
  void set_producer_name(const std::string& value);
  void set_producer_name(std::string&& value);
  void set_producer_name(const char* value);
  void set_producer_name(const char* value, size_t size);
  std::string* mutable_producer_name();
  std::string* release_producer_name();
  void set_allocated_producer_name(std::string* producer_name);
  private:
  const std::string& _internal_producer_name() const;
  void _internal_set_producer_name(const std::string& value);
  std::string* _internal_mutable_producer_name();
  public:

  // optional string producer_version = 4;
  bool has_producer_version() const;
  private:
  bool _internal_has_producer_version() const;
  public:
  void clear_producer_version();
  const std::string& producer_version() const;
  void set_producer_version(const std::string& value);
  void set_producer_version(std::string&& value);
  void set_producer_version(const char* value);
  void set_producer_version(const char* value, size_t size);
  std::string* mutable_producer_version();
  std::string* release_producer_version();
  void set_allocated_producer_version(std::string* producer_version);
  private:
  const std::string& _internal_producer_version() const;
  void _internal_set_producer_version(const std::string& value);
  std::string* _internal_mutable_producer_version();
  public:

  // optional .torch.ModuleDef main_module = 2;
  bool has_main_module() const;
  private:
  bool _internal_has_main_module() const;
  public:
  void clear_main_module();
  const ::torch::ModuleDef& main_module() const;
  ::torch::ModuleDef* release_main_module();
  ::torch::ModuleDef* mutable_main_module();
  void set_allocated_main_module(::torch::ModuleDef* main_module);
  private:
  const ::torch::ModuleDef& _internal_main_module() const;
  ::torch::ModuleDef* _internal_mutable_main_module();
  public:

  // optional int64 proto_version = 1;
  bool has_proto_version() const;
  private:
  bool _internal_has_proto_version() const;
  public:
  void clear_proto_version();
  ::PROTOBUF_NAMESPACE_ID::int64 proto_version() const;
  void set_proto_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_proto_version() const;
  void _internal_set_proto_version(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:torch.ModelDef)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::TensorDef > tensors_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr producer_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr producer_version_;
  ::torch::ModuleDef* main_module_;
  ::PROTOBUF_NAMESPACE_ID::int64 proto_version_;
  friend struct ::TableStruct_caffe2_2fproto_2ftorch_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RecordRef

// optional string key = 1;
inline bool RecordRef::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RecordRef::has_key() const {
  return _internal_has_key();
}
inline void RecordRef::clear_key() {
  key_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RecordRef::key() const {
  // @@protoc_insertion_point(field_get:torch.RecordRef.key)
  return _internal_key();
}
inline void RecordRef::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:torch.RecordRef.key)
}
inline std::string* RecordRef::mutable_key() {
  // @@protoc_insertion_point(field_mutable:torch.RecordRef.key)
  return _internal_mutable_key();
}
inline const std::string& RecordRef::_internal_key() const {
  return key_.GetNoArena();
}
inline void RecordRef::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void RecordRef::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.RecordRef.key)
}
inline void RecordRef::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.RecordRef.key)
}
inline void RecordRef::set_key(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.RecordRef.key)
}
inline std::string* RecordRef::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* RecordRef::release_key() {
  // @@protoc_insertion_point(field_release:torch.RecordRef.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void RecordRef::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:torch.RecordRef.key)
}

// -------------------------------------------------------------------

// TensorDef

// repeated int64 dims = 1;
inline int TensorDef::_internal_dims_size() const {
  return dims_.size();
}
inline int TensorDef::dims_size() const {
  return _internal_dims_size();
}
inline void TensorDef::clear_dims() {
  dims_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorDef::_internal_dims(int index) const {
  return dims_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorDef::dims(int index) const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.dims)
  return _internal_dims(index);
}
inline void TensorDef::set_dims(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.dims)
}
inline void TensorDef::_internal_add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  dims_.Add(value);
}
inline void TensorDef::add_dims(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:torch.TensorDef.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TensorDef::_internal_dims() const {
  return dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TensorDef::dims() const {
  // @@protoc_insertion_point(field_list:torch.TensorDef.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TensorDef::_internal_mutable_dims() {
  return &dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TensorDef::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:torch.TensorDef.dims)
  return _internal_mutable_dims();
}

// optional int64 offset = 2;
inline bool TensorDef::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TensorDef::has_offset() const {
  return _internal_has_offset();
}
inline void TensorDef::clear_offset() {
  offset_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorDef::_internal_offset() const {
  return offset_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorDef::offset() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.offset)
  return _internal_offset();
}
inline void TensorDef::_internal_set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  offset_ = value;
}
inline void TensorDef::set_offset(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.offset)
}

// repeated int64 strides = 3;
inline int TensorDef::_internal_strides_size() const {
  return strides_.size();
}
inline int TensorDef::strides_size() const {
  return _internal_strides_size();
}
inline void TensorDef::clear_strides() {
  strides_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorDef::_internal_strides(int index) const {
  return strides_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorDef::strides(int index) const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.strides)
  return _internal_strides(index);
}
inline void TensorDef::set_strides(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  strides_.Set(index, value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.strides)
}
inline void TensorDef::_internal_add_strides(::PROTOBUF_NAMESPACE_ID::int64 value) {
  strides_.Add(value);
}
inline void TensorDef::add_strides(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_add_strides(value);
  // @@protoc_insertion_point(field_add:torch.TensorDef.strides)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TensorDef::_internal_strides() const {
  return strides_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TensorDef::strides() const {
  // @@protoc_insertion_point(field_list:torch.TensorDef.strides)
  return _internal_strides();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TensorDef::_internal_mutable_strides() {
  return &strides_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TensorDef::mutable_strides() {
  // @@protoc_insertion_point(field_mutable_list:torch.TensorDef.strides)
  return _internal_mutable_strides();
}

// optional bool requires_grad = 4;
inline bool TensorDef::_internal_has_requires_grad() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TensorDef::has_requires_grad() const {
  return _internal_has_requires_grad();
}
inline void TensorDef::clear_requires_grad() {
  requires_grad_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool TensorDef::_internal_requires_grad() const {
  return requires_grad_;
}
inline bool TensorDef::requires_grad() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.requires_grad)
  return _internal_requires_grad();
}
inline void TensorDef::_internal_set_requires_grad(bool value) {
  _has_bits_[0] |= 0x00000010u;
  requires_grad_ = value;
}
inline void TensorDef::set_requires_grad(bool value) {
  _internal_set_requires_grad(value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.requires_grad)
}

// optional .caffe2.TensorProto.DataType data_type = 5;
inline bool TensorDef::_internal_has_data_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TensorDef::has_data_type() const {
  return _internal_has_data_type();
}
inline void TensorDef::clear_data_type() {
  data_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::caffe2::TensorProto_DataType TensorDef::_internal_data_type() const {
  return static_cast< ::caffe2::TensorProto_DataType >(data_type_);
}
inline ::caffe2::TensorProto_DataType TensorDef::data_type() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.data_type)
  return _internal_data_type();
}
inline void TensorDef::_internal_set_data_type(::caffe2::TensorProto_DataType value) {
  assert(::caffe2::TensorProto_DataType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  data_type_ = value;
}
inline void TensorDef::set_data_type(::caffe2::TensorProto_DataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.data_type)
}

// optional .torch.RecordRef data = 6;
inline bool TensorDef::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || data_ != nullptr);
  return value;
}
inline bool TensorDef::has_data() const {
  return _internal_has_data();
}
inline void TensorDef::clear_data() {
  if (data_ != nullptr) data_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::torch::RecordRef& TensorDef::_internal_data() const {
  const ::torch::RecordRef* p = data_;
  return p != nullptr ? *p : *reinterpret_cast<const ::torch::RecordRef*>(
      &::torch::_RecordRef_default_instance_);
}
inline const ::torch::RecordRef& TensorDef::data() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.data)
  return _internal_data();
}
inline ::torch::RecordRef* TensorDef::release_data() {
  // @@protoc_insertion_point(field_release:torch.TensorDef.data)
  _has_bits_[0] &= ~0x00000002u;
  ::torch::RecordRef* temp = data_;
  data_ = nullptr;
  return temp;
}
inline ::torch::RecordRef* TensorDef::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000002u;
  if (data_ == nullptr) {
    auto* p = CreateMaybeMessage<::torch::RecordRef>(GetArenaNoVirtual());
    data_ = p;
  }
  return data_;
}
inline ::torch::RecordRef* TensorDef::mutable_data() {
  // @@protoc_insertion_point(field_mutable:torch.TensorDef.data)
  return _internal_mutable_data();
}
inline void TensorDef::set_allocated_data(::torch::RecordRef* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:torch.TensorDef.data)
}

// optional string device = 7;
inline bool TensorDef::_internal_has_device() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TensorDef::has_device() const {
  return _internal_has_device();
}
inline void TensorDef::clear_device() {
  device_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TensorDef::device() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.device)
  return _internal_device();
}
inline void TensorDef::set_device(const std::string& value) {
  _internal_set_device(value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.device)
}
inline std::string* TensorDef::mutable_device() {
  // @@protoc_insertion_point(field_mutable:torch.TensorDef.device)
  return _internal_mutable_device();
}
inline const std::string& TensorDef::_internal_device() const {
  return device_.GetNoArena();
}
inline void TensorDef::_internal_set_device(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void TensorDef::set_device(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  device_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.TensorDef.device)
}
inline void TensorDef::set_device(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  device_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.TensorDef.device)
}
inline void TensorDef::set_device(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  device_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.TensorDef.device)
}
inline std::string* TensorDef::_internal_mutable_device() {
  _has_bits_[0] |= 0x00000001u;
  return device_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* TensorDef::release_device() {
  // @@protoc_insertion_point(field_release:torch.TensorDef.device)
  if (!_internal_has_device()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return device_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void TensorDef::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:torch.TensorDef.device)
}

// optional bool is_quantized = 8;
inline bool TensorDef::_internal_has_is_quantized() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TensorDef::has_is_quantized() const {
  return _internal_has_is_quantized();
}
inline void TensorDef::clear_is_quantized() {
  is_quantized_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool TensorDef::_internal_is_quantized() const {
  return is_quantized_;
}
inline bool TensorDef::is_quantized() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.is_quantized)
  return _internal_is_quantized();
}
inline void TensorDef::_internal_set_is_quantized(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_quantized_ = value;
}
inline void TensorDef::set_is_quantized(bool value) {
  _internal_set_is_quantized(value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.is_quantized)
}

// optional double scale = 9;
inline bool TensorDef::_internal_has_scale() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TensorDef::has_scale() const {
  return _internal_has_scale();
}
inline void TensorDef::clear_scale() {
  scale_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline double TensorDef::_internal_scale() const {
  return scale_;
}
inline double TensorDef::scale() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.scale)
  return _internal_scale();
}
inline void TensorDef::_internal_set_scale(double value) {
  _has_bits_[0] |= 0x00000040u;
  scale_ = value;
}
inline void TensorDef::set_scale(double value) {
  _internal_set_scale(value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.scale)
}

// optional int64 zero_point = 10;
inline bool TensorDef::_internal_has_zero_point() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TensorDef::has_zero_point() const {
  return _internal_has_zero_point();
}
inline void TensorDef::clear_zero_point() {
  zero_point_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorDef::_internal_zero_point() const {
  return zero_point_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TensorDef::zero_point() const {
  // @@protoc_insertion_point(field_get:torch.TensorDef.zero_point)
  return _internal_zero_point();
}
inline void TensorDef::_internal_set_zero_point(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000080u;
  zero_point_ = value;
}
inline void TensorDef::set_zero_point(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_zero_point(value);
  // @@protoc_insertion_point(field_set:torch.TensorDef.zero_point)
}

// -------------------------------------------------------------------

// AttributeDef

// required string type = 1;
inline bool AttributeDef::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AttributeDef::has_type() const {
  return _internal_has_type();
}
inline void AttributeDef::clear_type() {
  type_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AttributeDef::type() const {
  // @@protoc_insertion_point(field_get:torch.AttributeDef.type)
  return _internal_type();
}
inline void AttributeDef::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:torch.AttributeDef.type)
}
inline std::string* AttributeDef::mutable_type() {
  // @@protoc_insertion_point(field_mutable:torch.AttributeDef.type)
  return _internal_mutable_type();
}
inline const std::string& AttributeDef::_internal_type() const {
  return type_.GetNoArena();
}
inline void AttributeDef::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void AttributeDef::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.AttributeDef.type)
}
inline void AttributeDef::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.AttributeDef.type)
}
inline void AttributeDef::set_type(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  type_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.AttributeDef.type)
}
inline std::string* AttributeDef::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000001u;
  return type_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* AttributeDef::release_type() {
  // @@protoc_insertion_point(field_release:torch.AttributeDef.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return type_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void AttributeDef::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:torch.AttributeDef.type)
}

// required string name = 2;
inline bool AttributeDef::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AttributeDef::has_name() const {
  return _internal_has_name();
}
inline void AttributeDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AttributeDef::name() const {
  // @@protoc_insertion_point(field_get:torch.AttributeDef.name)
  return _internal_name();
}
inline void AttributeDef::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:torch.AttributeDef.name)
}
inline std::string* AttributeDef::mutable_name() {
  // @@protoc_insertion_point(field_mutable:torch.AttributeDef.name)
  return _internal_mutable_name();
}
inline const std::string& AttributeDef::_internal_name() const {
  return name_.GetNoArena();
}
inline void AttributeDef::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void AttributeDef::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.AttributeDef.name)
}
inline void AttributeDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.AttributeDef.name)
}
inline void AttributeDef::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.AttributeDef.name)
}
inline std::string* AttributeDef::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* AttributeDef::release_name() {
  // @@protoc_insertion_point(field_release:torch.AttributeDef.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void AttributeDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:torch.AttributeDef.name)
}

// required int64 id = 3;
inline bool AttributeDef::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AttributeDef::has_id() const {
  return _internal_has_id();
}
inline void AttributeDef::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AttributeDef::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AttributeDef::id() const {
  // @@protoc_insertion_point(field_get:torch.AttributeDef.id)
  return _internal_id();
}
inline void AttributeDef::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  id_ = value;
}
inline void AttributeDef::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:torch.AttributeDef.id)
}

// -------------------------------------------------------------------

// ParameterDef

// optional bool is_buffer = 1;
inline bool ParameterDef::_internal_has_is_buffer() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ParameterDef::has_is_buffer() const {
  return _internal_has_is_buffer();
}
inline void ParameterDef::clear_is_buffer() {
  is_buffer_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ParameterDef::_internal_is_buffer() const {
  return is_buffer_;
}
inline bool ParameterDef::is_buffer() const {
  // @@protoc_insertion_point(field_get:torch.ParameterDef.is_buffer)
  return _internal_is_buffer();
}
inline void ParameterDef::_internal_set_is_buffer(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_buffer_ = value;
}
inline void ParameterDef::set_is_buffer(bool value) {
  _internal_set_is_buffer(value);
  // @@protoc_insertion_point(field_set:torch.ParameterDef.is_buffer)
}

// optional int64 tensor_id = 2;
inline bool ParameterDef::_internal_has_tensor_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ParameterDef::has_tensor_id() const {
  return _internal_has_tensor_id();
}
inline void ParameterDef::clear_tensor_id() {
  tensor_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ParameterDef::_internal_tensor_id() const {
  return tensor_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ParameterDef::tensor_id() const {
  // @@protoc_insertion_point(field_get:torch.ParameterDef.tensor_id)
  return _internal_tensor_id();
}
inline void ParameterDef::_internal_set_tensor_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  tensor_id_ = value;
}
inline void ParameterDef::set_tensor_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_tensor_id(value);
  // @@protoc_insertion_point(field_set:torch.ParameterDef.tensor_id)
}

// optional string name = 3;
inline bool ParameterDef::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ParameterDef::has_name() const {
  return _internal_has_name();
}
inline void ParameterDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ParameterDef::name() const {
  // @@protoc_insertion_point(field_get:torch.ParameterDef.name)
  return _internal_name();
}
inline void ParameterDef::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:torch.ParameterDef.name)
}
inline std::string* ParameterDef::mutable_name() {
  // @@protoc_insertion_point(field_mutable:torch.ParameterDef.name)
  return _internal_mutable_name();
}
inline const std::string& ParameterDef::_internal_name() const {
  return name_.GetNoArena();
}
inline void ParameterDef::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ParameterDef::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ParameterDef.name)
}
inline void ParameterDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ParameterDef.name)
}
inline void ParameterDef::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ParameterDef.name)
}
inline std::string* ParameterDef::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ParameterDef::release_name() {
  // @@protoc_insertion_point(field_release:torch.ParameterDef.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ParameterDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:torch.ParameterDef.name)
}

// -------------------------------------------------------------------

// ModuleDef

// repeated .torch.ModuleDef submodules = 1;
inline int ModuleDef::_internal_submodules_size() const {
  return submodules_.size();
}
inline int ModuleDef::submodules_size() const {
  return _internal_submodules_size();
}
inline void ModuleDef::clear_submodules() {
  submodules_.Clear();
}
inline ::torch::ModuleDef* ModuleDef::mutable_submodules(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.submodules)
  return submodules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::ModuleDef >*
ModuleDef::mutable_submodules() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModuleDef.submodules)
  return &submodules_;
}
inline const ::torch::ModuleDef& ModuleDef::_internal_submodules(int index) const {
  return submodules_.Get(index);
}
inline const ::torch::ModuleDef& ModuleDef::submodules(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.submodules)
  return _internal_submodules(index);
}
inline ::torch::ModuleDef* ModuleDef::_internal_add_submodules() {
  return submodules_.Add();
}
inline ::torch::ModuleDef* ModuleDef::add_submodules() {
  // @@protoc_insertion_point(field_add:torch.ModuleDef.submodules)
  return _internal_add_submodules();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::ModuleDef >&
ModuleDef::submodules() const {
  // @@protoc_insertion_point(field_list:torch.ModuleDef.submodules)
  return submodules_;
}

// optional .torch.RecordRef torchscript_arena = 2;
inline bool ModuleDef::_internal_has_torchscript_arena() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || torchscript_arena_ != nullptr);
  return value;
}
inline bool ModuleDef::has_torchscript_arena() const {
  return _internal_has_torchscript_arena();
}
inline void ModuleDef::clear_torchscript_arena() {
  if (torchscript_arena_ != nullptr) torchscript_arena_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::torch::RecordRef& ModuleDef::_internal_torchscript_arena() const {
  const ::torch::RecordRef* p = torchscript_arena_;
  return p != nullptr ? *p : *reinterpret_cast<const ::torch::RecordRef*>(
      &::torch::_RecordRef_default_instance_);
}
inline const ::torch::RecordRef& ModuleDef::torchscript_arena() const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.torchscript_arena)
  return _internal_torchscript_arena();
}
inline ::torch::RecordRef* ModuleDef::release_torchscript_arena() {
  // @@protoc_insertion_point(field_release:torch.ModuleDef.torchscript_arena)
  _has_bits_[0] &= ~0x00000002u;
  ::torch::RecordRef* temp = torchscript_arena_;
  torchscript_arena_ = nullptr;
  return temp;
}
inline ::torch::RecordRef* ModuleDef::_internal_mutable_torchscript_arena() {
  _has_bits_[0] |= 0x00000002u;
  if (torchscript_arena_ == nullptr) {
    auto* p = CreateMaybeMessage<::torch::RecordRef>(GetArenaNoVirtual());
    torchscript_arena_ = p;
  }
  return torchscript_arena_;
}
inline ::torch::RecordRef* ModuleDef::mutable_torchscript_arena() {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.torchscript_arena)
  return _internal_mutable_torchscript_arena();
}
inline void ModuleDef::set_allocated_torchscript_arena(::torch::RecordRef* torchscript_arena) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete torchscript_arena_;
  }
  if (torchscript_arena) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      torchscript_arena = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torchscript_arena, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  torchscript_arena_ = torchscript_arena;
  // @@protoc_insertion_point(field_set_allocated:torch.ModuleDef.torchscript_arena)
}

// repeated .caffe2.NetDef caffe2_nets = 3;
inline int ModuleDef::_internal_caffe2_nets_size() const {
  return caffe2_nets_.size();
}
inline int ModuleDef::caffe2_nets_size() const {
  return _internal_caffe2_nets_size();
}
inline ::caffe2::NetDef* ModuleDef::mutable_caffe2_nets(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.caffe2_nets)
  return caffe2_nets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >*
ModuleDef::mutable_caffe2_nets() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModuleDef.caffe2_nets)
  return &caffe2_nets_;
}
inline const ::caffe2::NetDef& ModuleDef::_internal_caffe2_nets(int index) const {
  return caffe2_nets_.Get(index);
}
inline const ::caffe2::NetDef& ModuleDef::caffe2_nets(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.caffe2_nets)
  return _internal_caffe2_nets(index);
}
inline ::caffe2::NetDef* ModuleDef::_internal_add_caffe2_nets() {
  return caffe2_nets_.Add();
}
inline ::caffe2::NetDef* ModuleDef::add_caffe2_nets() {
  // @@protoc_insertion_point(field_add:torch.ModuleDef.caffe2_nets)
  return _internal_add_caffe2_nets();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::caffe2::NetDef >&
ModuleDef::caffe2_nets() const {
  // @@protoc_insertion_point(field_list:torch.ModuleDef.caffe2_nets)
  return caffe2_nets_;
}

// optional .torch.RecordRef pickle_arena = 4;
inline bool ModuleDef::_internal_has_pickle_arena() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || pickle_arena_ != nullptr);
  return value;
}
inline bool ModuleDef::has_pickle_arena() const {
  return _internal_has_pickle_arena();
}
inline void ModuleDef::clear_pickle_arena() {
  if (pickle_arena_ != nullptr) pickle_arena_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::torch::RecordRef& ModuleDef::_internal_pickle_arena() const {
  const ::torch::RecordRef* p = pickle_arena_;
  return p != nullptr ? *p : *reinterpret_cast<const ::torch::RecordRef*>(
      &::torch::_RecordRef_default_instance_);
}
inline const ::torch::RecordRef& ModuleDef::pickle_arena() const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.pickle_arena)
  return _internal_pickle_arena();
}
inline ::torch::RecordRef* ModuleDef::release_pickle_arena() {
  // @@protoc_insertion_point(field_release:torch.ModuleDef.pickle_arena)
  _has_bits_[0] &= ~0x00000004u;
  ::torch::RecordRef* temp = pickle_arena_;
  pickle_arena_ = nullptr;
  return temp;
}
inline ::torch::RecordRef* ModuleDef::_internal_mutable_pickle_arena() {
  _has_bits_[0] |= 0x00000004u;
  if (pickle_arena_ == nullptr) {
    auto* p = CreateMaybeMessage<::torch::RecordRef>(GetArenaNoVirtual());
    pickle_arena_ = p;
  }
  return pickle_arena_;
}
inline ::torch::RecordRef* ModuleDef::mutable_pickle_arena() {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.pickle_arena)
  return _internal_mutable_pickle_arena();
}
inline void ModuleDef::set_allocated_pickle_arena(::torch::RecordRef* pickle_arena) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pickle_arena_;
  }
  if (pickle_arena) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pickle_arena = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pickle_arena, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pickle_arena_ = pickle_arena;
  // @@protoc_insertion_point(field_set_allocated:torch.ModuleDef.pickle_arena)
}

// optional .torch.RecordRef cpp_arena = 5;
inline bool ModuleDef::_internal_has_cpp_arena() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || cpp_arena_ != nullptr);
  return value;
}
inline bool ModuleDef::has_cpp_arena() const {
  return _internal_has_cpp_arena();
}
inline void ModuleDef::clear_cpp_arena() {
  if (cpp_arena_ != nullptr) cpp_arena_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::torch::RecordRef& ModuleDef::_internal_cpp_arena() const {
  const ::torch::RecordRef* p = cpp_arena_;
  return p != nullptr ? *p : *reinterpret_cast<const ::torch::RecordRef*>(
      &::torch::_RecordRef_default_instance_);
}
inline const ::torch::RecordRef& ModuleDef::cpp_arena() const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.cpp_arena)
  return _internal_cpp_arena();
}
inline ::torch::RecordRef* ModuleDef::release_cpp_arena() {
  // @@protoc_insertion_point(field_release:torch.ModuleDef.cpp_arena)
  _has_bits_[0] &= ~0x00000008u;
  ::torch::RecordRef* temp = cpp_arena_;
  cpp_arena_ = nullptr;
  return temp;
}
inline ::torch::RecordRef* ModuleDef::_internal_mutable_cpp_arena() {
  _has_bits_[0] |= 0x00000008u;
  if (cpp_arena_ == nullptr) {
    auto* p = CreateMaybeMessage<::torch::RecordRef>(GetArenaNoVirtual());
    cpp_arena_ = p;
  }
  return cpp_arena_;
}
inline ::torch::RecordRef* ModuleDef::mutable_cpp_arena() {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.cpp_arena)
  return _internal_mutable_cpp_arena();
}
inline void ModuleDef::set_allocated_cpp_arena(::torch::RecordRef* cpp_arena) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cpp_arena_;
  }
  if (cpp_arena) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cpp_arena = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cpp_arena, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  cpp_arena_ = cpp_arena;
  // @@protoc_insertion_point(field_set_allocated:torch.ModuleDef.cpp_arena)
}

// repeated .torch.ParameterDef parameters = 6;
inline int ModuleDef::_internal_parameters_size() const {
  return parameters_.size();
}
inline int ModuleDef::parameters_size() const {
  return _internal_parameters_size();
}
inline void ModuleDef::clear_parameters() {
  parameters_.Clear();
}
inline ::torch::ParameterDef* ModuleDef::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.parameters)
  return parameters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::ParameterDef >*
ModuleDef::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModuleDef.parameters)
  return &parameters_;
}
inline const ::torch::ParameterDef& ModuleDef::_internal_parameters(int index) const {
  return parameters_.Get(index);
}
inline const ::torch::ParameterDef& ModuleDef::parameters(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.parameters)
  return _internal_parameters(index);
}
inline ::torch::ParameterDef* ModuleDef::_internal_add_parameters() {
  return parameters_.Add();
}
inline ::torch::ParameterDef* ModuleDef::add_parameters() {
  // @@protoc_insertion_point(field_add:torch.ModuleDef.parameters)
  return _internal_add_parameters();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::ParameterDef >&
ModuleDef::parameters() const {
  // @@protoc_insertion_point(field_list:torch.ModuleDef.parameters)
  return parameters_;
}

// optional string name = 7;
inline bool ModuleDef::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModuleDef::has_name() const {
  return _internal_has_name();
}
inline void ModuleDef::clear_name() {
  name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModuleDef::name() const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.name)
  return _internal_name();
}
inline void ModuleDef::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:torch.ModuleDef.name)
}
inline std::string* ModuleDef::mutable_name() {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.name)
  return _internal_mutable_name();
}
inline const std::string& ModuleDef::_internal_name() const {
  return name_.GetNoArena();
}
inline void ModuleDef::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ModuleDef::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ModuleDef.name)
}
inline void ModuleDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ModuleDef.name)
}
inline void ModuleDef::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ModuleDef.name)
}
inline std::string* ModuleDef::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ModuleDef::release_name() {
  // @@protoc_insertion_point(field_release:torch.ModuleDef.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModuleDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:torch.ModuleDef.name)
}

// optional bool optimize = 8;
inline bool ModuleDef::_internal_has_optimize() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool ModuleDef::has_optimize() const {
  return _internal_has_optimize();
}
inline void ModuleDef::clear_optimize() {
  optimize_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ModuleDef::_internal_optimize() const {
  return optimize_;
}
inline bool ModuleDef::optimize() const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.optimize)
  return _internal_optimize();
}
inline void ModuleDef::_internal_set_optimize(bool value) {
  _has_bits_[0] |= 0x00000040u;
  optimize_ = value;
}
inline void ModuleDef::set_optimize(bool value) {
  _internal_set_optimize(value);
  // @@protoc_insertion_point(field_set:torch.ModuleDef.optimize)
}

// repeated .torch.AttributeDef attributes = 9;
inline int ModuleDef::_internal_attributes_size() const {
  return attributes_.size();
}
inline int ModuleDef::attributes_size() const {
  return _internal_attributes_size();
}
inline void ModuleDef::clear_attributes() {
  attributes_.Clear();
}
inline ::torch::AttributeDef* ModuleDef::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.attributes)
  return attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::AttributeDef >*
ModuleDef::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModuleDef.attributes)
  return &attributes_;
}
inline const ::torch::AttributeDef& ModuleDef::_internal_attributes(int index) const {
  return attributes_.Get(index);
}
inline const ::torch::AttributeDef& ModuleDef::attributes(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.attributes)
  return _internal_attributes(index);
}
inline ::torch::AttributeDef* ModuleDef::_internal_add_attributes() {
  return attributes_.Add();
}
inline ::torch::AttributeDef* ModuleDef::add_attributes() {
  // @@protoc_insertion_point(field_add:torch.ModuleDef.attributes)
  return _internal_add_attributes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::AttributeDef >&
ModuleDef::attributes() const {
  // @@protoc_insertion_point(field_list:torch.ModuleDef.attributes)
  return attributes_;
}

// optional int64 get_state_attribute_id = 10;
inline bool ModuleDef::_internal_has_get_state_attribute_id() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool ModuleDef::has_get_state_attribute_id() const {
  return _internal_has_get_state_attribute_id();
}
inline void ModuleDef::clear_get_state_attribute_id() {
  get_state_attribute_id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModuleDef::_internal_get_state_attribute_id() const {
  return get_state_attribute_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModuleDef::get_state_attribute_id() const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.get_state_attribute_id)
  return _internal_get_state_attribute_id();
}
inline void ModuleDef::_internal_set_get_state_attribute_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000020u;
  get_state_attribute_id_ = value;
}
inline void ModuleDef::set_get_state_attribute_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_get_state_attribute_id(value);
  // @@protoc_insertion_point(field_set:torch.ModuleDef.get_state_attribute_id)
}

// optional .torch.RecordRef torchscript_debug_arena = 11;
inline bool ModuleDef::_internal_has_torchscript_debug_arena() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || torchscript_debug_arena_ != nullptr);
  return value;
}
inline bool ModuleDef::has_torchscript_debug_arena() const {
  return _internal_has_torchscript_debug_arena();
}
inline void ModuleDef::clear_torchscript_debug_arena() {
  if (torchscript_debug_arena_ != nullptr) torchscript_debug_arena_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::torch::RecordRef& ModuleDef::_internal_torchscript_debug_arena() const {
  const ::torch::RecordRef* p = torchscript_debug_arena_;
  return p != nullptr ? *p : *reinterpret_cast<const ::torch::RecordRef*>(
      &::torch::_RecordRef_default_instance_);
}
inline const ::torch::RecordRef& ModuleDef::torchscript_debug_arena() const {
  // @@protoc_insertion_point(field_get:torch.ModuleDef.torchscript_debug_arena)
  return _internal_torchscript_debug_arena();
}
inline ::torch::RecordRef* ModuleDef::release_torchscript_debug_arena() {
  // @@protoc_insertion_point(field_release:torch.ModuleDef.torchscript_debug_arena)
  _has_bits_[0] &= ~0x00000010u;
  ::torch::RecordRef* temp = torchscript_debug_arena_;
  torchscript_debug_arena_ = nullptr;
  return temp;
}
inline ::torch::RecordRef* ModuleDef::_internal_mutable_torchscript_debug_arena() {
  _has_bits_[0] |= 0x00000010u;
  if (torchscript_debug_arena_ == nullptr) {
    auto* p = CreateMaybeMessage<::torch::RecordRef>(GetArenaNoVirtual());
    torchscript_debug_arena_ = p;
  }
  return torchscript_debug_arena_;
}
inline ::torch::RecordRef* ModuleDef::mutable_torchscript_debug_arena() {
  // @@protoc_insertion_point(field_mutable:torch.ModuleDef.torchscript_debug_arena)
  return _internal_mutable_torchscript_debug_arena();
}
inline void ModuleDef::set_allocated_torchscript_debug_arena(::torch::RecordRef* torchscript_debug_arena) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete torchscript_debug_arena_;
  }
  if (torchscript_debug_arena) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      torchscript_debug_arena = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torchscript_debug_arena, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  torchscript_debug_arena_ = torchscript_debug_arena;
  // @@protoc_insertion_point(field_set_allocated:torch.ModuleDef.torchscript_debug_arena)
}

// -------------------------------------------------------------------

// LibDef

// optional .torch.RecordRef torchscript_arena = 1;
inline bool LibDef::_internal_has_torchscript_arena() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || torchscript_arena_ != nullptr);
  return value;
}
inline bool LibDef::has_torchscript_arena() const {
  return _internal_has_torchscript_arena();
}
inline void LibDef::clear_torchscript_arena() {
  if (torchscript_arena_ != nullptr) torchscript_arena_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::torch::RecordRef& LibDef::_internal_torchscript_arena() const {
  const ::torch::RecordRef* p = torchscript_arena_;
  return p != nullptr ? *p : *reinterpret_cast<const ::torch::RecordRef*>(
      &::torch::_RecordRef_default_instance_);
}
inline const ::torch::RecordRef& LibDef::torchscript_arena() const {
  // @@protoc_insertion_point(field_get:torch.LibDef.torchscript_arena)
  return _internal_torchscript_arena();
}
inline ::torch::RecordRef* LibDef::release_torchscript_arena() {
  // @@protoc_insertion_point(field_release:torch.LibDef.torchscript_arena)
  _has_bits_[0] &= ~0x00000001u;
  ::torch::RecordRef* temp = torchscript_arena_;
  torchscript_arena_ = nullptr;
  return temp;
}
inline ::torch::RecordRef* LibDef::_internal_mutable_torchscript_arena() {
  _has_bits_[0] |= 0x00000001u;
  if (torchscript_arena_ == nullptr) {
    auto* p = CreateMaybeMessage<::torch::RecordRef>(GetArenaNoVirtual());
    torchscript_arena_ = p;
  }
  return torchscript_arena_;
}
inline ::torch::RecordRef* LibDef::mutable_torchscript_arena() {
  // @@protoc_insertion_point(field_mutable:torch.LibDef.torchscript_arena)
  return _internal_mutable_torchscript_arena();
}
inline void LibDef::set_allocated_torchscript_arena(::torch::RecordRef* torchscript_arena) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete torchscript_arena_;
  }
  if (torchscript_arena) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      torchscript_arena = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, torchscript_arena, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  torchscript_arena_ = torchscript_arena;
  // @@protoc_insertion_point(field_set_allocated:torch.LibDef.torchscript_arena)
}

// -------------------------------------------------------------------

// ModelDef

// optional int64 proto_version = 1;
inline bool ModelDef::_internal_has_proto_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ModelDef::has_proto_version() const {
  return _internal_has_proto_version();
}
inline void ModelDef::clear_proto_version() {
  proto_version_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelDef::_internal_proto_version() const {
  return proto_version_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ModelDef::proto_version() const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.proto_version)
  return _internal_proto_version();
}
inline void ModelDef::_internal_set_proto_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  proto_version_ = value;
}
inline void ModelDef::set_proto_version(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_proto_version(value);
  // @@protoc_insertion_point(field_set:torch.ModelDef.proto_version)
}

// optional .torch.ModuleDef main_module = 2;
inline bool ModelDef::_internal_has_main_module() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || main_module_ != nullptr);
  return value;
}
inline bool ModelDef::has_main_module() const {
  return _internal_has_main_module();
}
inline void ModelDef::clear_main_module() {
  if (main_module_ != nullptr) main_module_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::torch::ModuleDef& ModelDef::_internal_main_module() const {
  const ::torch::ModuleDef* p = main_module_;
  return p != nullptr ? *p : *reinterpret_cast<const ::torch::ModuleDef*>(
      &::torch::_ModuleDef_default_instance_);
}
inline const ::torch::ModuleDef& ModelDef::main_module() const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.main_module)
  return _internal_main_module();
}
inline ::torch::ModuleDef* ModelDef::release_main_module() {
  // @@protoc_insertion_point(field_release:torch.ModelDef.main_module)
  _has_bits_[0] &= ~0x00000004u;
  ::torch::ModuleDef* temp = main_module_;
  main_module_ = nullptr;
  return temp;
}
inline ::torch::ModuleDef* ModelDef::_internal_mutable_main_module() {
  _has_bits_[0] |= 0x00000004u;
  if (main_module_ == nullptr) {
    auto* p = CreateMaybeMessage<::torch::ModuleDef>(GetArenaNoVirtual());
    main_module_ = p;
  }
  return main_module_;
}
inline ::torch::ModuleDef* ModelDef::mutable_main_module() {
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.main_module)
  return _internal_mutable_main_module();
}
inline void ModelDef::set_allocated_main_module(::torch::ModuleDef* main_module) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete main_module_;
  }
  if (main_module) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      main_module = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, main_module, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  main_module_ = main_module;
  // @@protoc_insertion_point(field_set_allocated:torch.ModelDef.main_module)
}

// optional string producer_name = 3;
inline bool ModelDef::_internal_has_producer_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModelDef::has_producer_name() const {
  return _internal_has_producer_name();
}
inline void ModelDef::clear_producer_name() {
  producer_name_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModelDef::producer_name() const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.producer_name)
  return _internal_producer_name();
}
inline void ModelDef::set_producer_name(const std::string& value) {
  _internal_set_producer_name(value);
  // @@protoc_insertion_point(field_set:torch.ModelDef.producer_name)
}
inline std::string* ModelDef::mutable_producer_name() {
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.producer_name)
  return _internal_mutable_producer_name();
}
inline const std::string& ModelDef::_internal_producer_name() const {
  return producer_name_.GetNoArena();
}
inline void ModelDef::_internal_set_producer_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  producer_name_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ModelDef::set_producer_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  producer_name_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ModelDef.producer_name)
}
inline void ModelDef::set_producer_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  producer_name_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ModelDef.producer_name)
}
inline void ModelDef::set_producer_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  producer_name_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ModelDef.producer_name)
}
inline std::string* ModelDef::_internal_mutable_producer_name() {
  _has_bits_[0] |= 0x00000001u;
  return producer_name_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ModelDef::release_producer_name() {
  // @@protoc_insertion_point(field_release:torch.ModelDef.producer_name)
  if (!_internal_has_producer_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return producer_name_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModelDef::set_allocated_producer_name(std::string* producer_name) {
  if (producer_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  producer_name_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), producer_name);
  // @@protoc_insertion_point(field_set_allocated:torch.ModelDef.producer_name)
}

// optional string producer_version = 4;
inline bool ModelDef::_internal_has_producer_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ModelDef::has_producer_version() const {
  return _internal_has_producer_version();
}
inline void ModelDef::clear_producer_version() {
  producer_version_.ClearToEmptyNoArena(&GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ModelDef::producer_version() const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.producer_version)
  return _internal_producer_version();
}
inline void ModelDef::set_producer_version(const std::string& value) {
  _internal_set_producer_version(value);
  // @@protoc_insertion_point(field_set:torch.ModelDef.producer_version)
}
inline std::string* ModelDef::mutable_producer_version() {
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.producer_version)
  return _internal_mutable_producer_version();
}
inline const std::string& ModelDef::_internal_producer_version() const {
  return producer_version_.GetNoArena();
}
inline void ModelDef::_internal_set_producer_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  producer_version_.SetNoArena(&GetEmptyStringAlreadyInited(), value);
}
inline void ModelDef::set_producer_version(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  producer_version_.SetNoArena(
    &GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:torch.ModelDef.producer_version)
}
inline void ModelDef::set_producer_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  producer_version_.SetNoArena(&GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:torch.ModelDef.producer_version)
}
inline void ModelDef::set_producer_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  producer_version_.SetNoArena(&GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:torch.ModelDef.producer_version)
}
inline std::string* ModelDef::_internal_mutable_producer_version() {
  _has_bits_[0] |= 0x00000002u;
  return producer_version_.MutableNoArena(&GetEmptyStringAlreadyInited());
}
inline std::string* ModelDef::release_producer_version() {
  // @@protoc_insertion_point(field_release:torch.ModelDef.producer_version)
  if (!_internal_has_producer_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return producer_version_.ReleaseNonDefaultNoArena(&GetEmptyStringAlreadyInited());
}
inline void ModelDef::set_allocated_producer_version(std::string* producer_version) {
  if (producer_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  producer_version_.SetAllocatedNoArena(&GetEmptyStringAlreadyInited(), producer_version);
  // @@protoc_insertion_point(field_set_allocated:torch.ModelDef.producer_version)
}

// repeated .torch.TensorDef tensors = 5;
inline int ModelDef::_internal_tensors_size() const {
  return tensors_.size();
}
inline int ModelDef::tensors_size() const {
  return _internal_tensors_size();
}
inline void ModelDef::clear_tensors() {
  tensors_.Clear();
}
inline ::torch::TensorDef* ModelDef::mutable_tensors(int index) {
  // @@protoc_insertion_point(field_mutable:torch.ModelDef.tensors)
  return tensors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::TensorDef >*
ModelDef::mutable_tensors() {
  // @@protoc_insertion_point(field_mutable_list:torch.ModelDef.tensors)
  return &tensors_;
}
inline const ::torch::TensorDef& ModelDef::_internal_tensors(int index) const {
  return tensors_.Get(index);
}
inline const ::torch::TensorDef& ModelDef::tensors(int index) const {
  // @@protoc_insertion_point(field_get:torch.ModelDef.tensors)
  return _internal_tensors(index);
}
inline ::torch::TensorDef* ModelDef::_internal_add_tensors() {
  return tensors_.Add();
}
inline ::torch::TensorDef* ModelDef::add_tensors() {
  // @@protoc_insertion_point(field_add:torch.ModelDef.tensors)
  return _internal_add_tensors();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::torch::TensorDef >&
ModelDef::tensors() const {
  // @@protoc_insertion_point(field_list:torch.ModelDef.tensors)
  return tensors_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace torch

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::torch::ProtoVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::torch::ProtoVersion>() {
  return ::torch::ProtoVersion_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_caffe2_2fproto_2ftorch_2eproto
